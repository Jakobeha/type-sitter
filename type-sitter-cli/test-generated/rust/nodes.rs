#[doc = "Typed node `_declaration_statement`\n\nThis node type has subtypes:\n\n- `associated_type` ([`AssociatedType`])\n- `attribute_item` ([`AttributeItem`])\n- `const_item` ([`ConstItem`])\n- `empty_statement` ([`EmptyStatement`])\n- `enum_item` ([`EnumItem`])\n- `extern_crate_declaration` ([`ExternCrateDeclaration`])\n- `foreign_mod_item` ([`ForeignModItem`])\n- `function_item` ([`FunctionItem`])\n- `function_signature_item` ([`FunctionSignatureItem`])\n- `impl_item` ([`ImplItem`])\n- `inner_attribute_item` ([`InnerAttributeItem`])\n- `let_declaration` ([`LetDeclaration`])\n- `macro_definition` ([`MacroDefinition`])\n- `macro_invocation` ([`MacroInvocation`])\n- `mod_item` ([`ModItem`])\n- `static_item` ([`StaticItem`])\n- `struct_item` ([`StructItem`])\n- `trait_item` ([`TraitItem`])\n- `type_item` ([`TypeItem`])\n- `union_item` ([`UnionItem`])\n- `use_declaration` ([`UseDeclaration`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum DeclarationStatement<'tree> {
    AssociatedType(AssociatedType<'tree>),
    AttributeItem(AttributeItem<'tree>),
    ConstItem(ConstItem<'tree>),
    EmptyStatement(EmptyStatement<'tree>),
    EnumItem(EnumItem<'tree>),
    ExternCrateDeclaration(ExternCrateDeclaration<'tree>),
    ForeignModItem(ForeignModItem<'tree>),
    FunctionItem(FunctionItem<'tree>),
    FunctionSignatureItem(FunctionSignatureItem<'tree>),
    ImplItem(ImplItem<'tree>),
    InnerAttributeItem(InnerAttributeItem<'tree>),
    LetDeclaration(LetDeclaration<'tree>),
    MacroDefinition(MacroDefinition<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    ModItem(ModItem<'tree>),
    StaticItem(StaticItem<'tree>),
    StructItem(StructItem<'tree>),
    TraitItem(TraitItem<'tree>),
    TypeItem(TypeItem<'tree>),
    UnionItem(UnionItem<'tree>),
    UseDeclaration(UseDeclaration<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> DeclarationStatement<'tree> {
    #[doc = "Returns the node if it is of type `associated_type` ([`AssociatedType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_associated_type(self) -> Option<AssociatedType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AssociatedType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AttributeItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `const_item` ([`ConstItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_const_item(self) -> Option<ConstItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConstItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `empty_statement` ([`EmptyStatement`]), otherwise returns `None`"]
    #[inline]
    pub fn as_empty_statement(self) -> Option<EmptyStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::EmptyStatement(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `enum_item` ([`EnumItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_enum_item(self) -> Option<EnumItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::EnumItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `extern_crate_declaration` ([`ExternCrateDeclaration`]), otherwise returns `None`"]
    #[inline]
    pub fn as_extern_crate_declaration(self) -> Option<ExternCrateDeclaration<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ExternCrateDeclaration(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `foreign_mod_item` ([`ForeignModItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_foreign_mod_item(self) -> Option<ForeignModItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ForeignModItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `function_item` ([`FunctionItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_function_item(self) -> Option<FunctionItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `function_signature_item` ([`FunctionSignatureItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_function_signature_item(self) -> Option<FunctionSignatureItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionSignatureItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `impl_item` ([`ImplItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_impl_item(self) -> Option<ImplItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ImplItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_inner_attribute_item(self) -> Option<InnerAttributeItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::InnerAttributeItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `let_declaration` ([`LetDeclaration`]), otherwise returns `None`"]
    #[inline]
    pub fn as_let_declaration(self) -> Option<LetDeclaration<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::LetDeclaration(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `macro_definition` ([`MacroDefinition`]), otherwise returns `None`"]
    #[inline]
    pub fn as_macro_definition(self) -> Option<MacroDefinition<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroDefinition(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`"]
    #[inline]
    pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `mod_item` ([`ModItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_mod_item(self) -> Option<ModItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ModItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `static_item` ([`StaticItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_static_item(self) -> Option<StaticItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StaticItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `struct_item` ([`StructItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_struct_item(self) -> Option<StructItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StructItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `trait_item` ([`TraitItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_trait_item(self) -> Option<TraitItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TraitItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `type_item` ([`TypeItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_type_item(self) -> Option<TypeItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `union_item` ([`UnionItem`]), otherwise returns `None`"]
    #[inline]
    pub fn as_union_item(self) -> Option<UnionItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnionItem(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `use_declaration` ([`UseDeclaration`]), otherwise returns `None`"]
    #[inline]
    pub fn as_use_declaration(self) -> Option<UseDeclaration<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UseDeclaration(x) = self {
            Some(x)
        } else {
            None
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for DeclarationStatement<'tree> {
    type WithLifetime<'a> = DeclarationStatement<'a>;
    const KIND: &'static str = "_declaration_statement";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        match node.kind() {
            "associated_type" => Ok(unsafe {
                Self::AssociatedType(
                    <AssociatedType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "attribute_item" => Ok(unsafe {
                Self::AttributeItem(
                    <AttributeItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "const_item" => Ok(unsafe {
                Self::ConstItem(
                    <ConstItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "empty_statement" => Ok(unsafe {
                Self::EmptyStatement(
                    <EmptyStatement<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "enum_item" => Ok(unsafe {
                Self::EnumItem(
                    <EnumItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "extern_crate_declaration" => {
                Ok(unsafe {
                    Self :: ExternCrateDeclaration (< ExternCrateDeclaration < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                })
            }
            "foreign_mod_item" => Ok(unsafe {
                Self::ForeignModItem(
                    <ForeignModItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "function_item" => Ok(unsafe {
                Self::FunctionItem(
                    <FunctionItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "function_signature_item" => {
                Ok(unsafe {
                    Self :: FunctionSignatureItem (< FunctionSignatureItem < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                })
            }
            "impl_item" => Ok(unsafe {
                Self::ImplItem(
                    <ImplItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "inner_attribute_item" => {
                Ok(unsafe {
                    Self::InnerAttributeItem(<InnerAttributeItem<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                })
            }
            "let_declaration" => Ok(unsafe {
                Self::LetDeclaration(
                    <LetDeclaration<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "macro_definition" => Ok(unsafe {
                Self::MacroDefinition(
                    <MacroDefinition<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "macro_invocation" => Ok(unsafe {
                Self::MacroInvocation(
                    <MacroInvocation<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "mod_item" => Ok(unsafe {
                Self::ModItem(
                    <ModItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "static_item" => Ok(unsafe {
                Self::StaticItem(
                    <StaticItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "struct_item" => Ok(unsafe {
                Self::StructItem(
                    <StructItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "trait_item" => Ok(unsafe {
                Self::TraitItem(
                    <TraitItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "type_item" => Ok(unsafe {
                Self::TypeItem(
                    <TypeItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "union_item" => Ok(unsafe {
                Self::UnionItem(
                    <UnionItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "use_declaration" => Ok(unsafe {
                Self::UseDeclaration(
                    <UseDeclaration<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        match self {
            Self::AssociatedType(x) => type_sitter::Node::raw(x),
            Self::AttributeItem(x) => type_sitter::Node::raw(x),
            Self::ConstItem(x) => type_sitter::Node::raw(x),
            Self::EmptyStatement(x) => type_sitter::Node::raw(x),
            Self::EnumItem(x) => type_sitter::Node::raw(x),
            Self::ExternCrateDeclaration(x) => type_sitter::Node::raw(x),
            Self::ForeignModItem(x) => type_sitter::Node::raw(x),
            Self::FunctionItem(x) => type_sitter::Node::raw(x),
            Self::FunctionSignatureItem(x) => type_sitter::Node::raw(x),
            Self::ImplItem(x) => type_sitter::Node::raw(x),
            Self::InnerAttributeItem(x) => type_sitter::Node::raw(x),
            Self::LetDeclaration(x) => type_sitter::Node::raw(x),
            Self::MacroDefinition(x) => type_sitter::Node::raw(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw(x),
            Self::ModItem(x) => type_sitter::Node::raw(x),
            Self::StaticItem(x) => type_sitter::Node::raw(x),
            Self::StructItem(x) => type_sitter::Node::raw(x),
            Self::TraitItem(x) => type_sitter::Node::raw(x),
            Self::TypeItem(x) => type_sitter::Node::raw(x),
            Self::UnionItem(x) => type_sitter::Node::raw(x),
            Self::UseDeclaration(x) => type_sitter::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        match self {
            Self::AssociatedType(x) => type_sitter::Node::raw_mut(x),
            Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
            Self::ConstItem(x) => type_sitter::Node::raw_mut(x),
            Self::EmptyStatement(x) => type_sitter::Node::raw_mut(x),
            Self::EnumItem(x) => type_sitter::Node::raw_mut(x),
            Self::ExternCrateDeclaration(x) => type_sitter::Node::raw_mut(x),
            Self::ForeignModItem(x) => type_sitter::Node::raw_mut(x),
            Self::FunctionItem(x) => type_sitter::Node::raw_mut(x),
            Self::FunctionSignatureItem(x) => type_sitter::Node::raw_mut(x),
            Self::ImplItem(x) => type_sitter::Node::raw_mut(x),
            Self::InnerAttributeItem(x) => type_sitter::Node::raw_mut(x),
            Self::LetDeclaration(x) => type_sitter::Node::raw_mut(x),
            Self::MacroDefinition(x) => type_sitter::Node::raw_mut(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw_mut(x),
            Self::ModItem(x) => type_sitter::Node::raw_mut(x),
            Self::StaticItem(x) => type_sitter::Node::raw_mut(x),
            Self::StructItem(x) => type_sitter::Node::raw_mut(x),
            Self::TraitItem(x) => type_sitter::Node::raw_mut(x),
            Self::TypeItem(x) => type_sitter::Node::raw_mut(x),
            Self::UnionItem(x) => type_sitter::Node::raw_mut(x),
            Self::UseDeclaration(x) => type_sitter::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        match self {
            Self::AssociatedType(x) => x.into_raw(),
            Self::AttributeItem(x) => x.into_raw(),
            Self::ConstItem(x) => x.into_raw(),
            Self::EmptyStatement(x) => x.into_raw(),
            Self::EnumItem(x) => x.into_raw(),
            Self::ExternCrateDeclaration(x) => x.into_raw(),
            Self::ForeignModItem(x) => x.into_raw(),
            Self::FunctionItem(x) => x.into_raw(),
            Self::FunctionSignatureItem(x) => x.into_raw(),
            Self::ImplItem(x) => x.into_raw(),
            Self::InnerAttributeItem(x) => x.into_raw(),
            Self::LetDeclaration(x) => x.into_raw(),
            Self::MacroDefinition(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::ModItem(x) => x.into_raw(),
            Self::StaticItem(x) => x.into_raw(),
            Self::StructItem(x) => x.into_raw(),
            Self::TraitItem(x) => x.into_raw(),
            Self::TypeItem(x) => x.into_raw(),
            Self::UnionItem(x) => x.into_raw(),
            Self::UseDeclaration(x) => x.into_raw(),
        }
    }
}
#[doc = "Typed node `_expression`\n\nThis node type has subtypes:\n\n- `_literal` ([`Literal`])\n- `array_expression` ([`ArrayExpression`])\n- `assignment_expression` ([`AssignmentExpression`])\n- `async_block` ([`AsyncBlock`])\n- `await_expression` ([`AwaitExpression`])\n- `binary_expression` ([`BinaryExpression`])\n- `block` ([`Block`])\n- `break_expression` ([`BreakExpression`])\n- `call_expression` ([`CallExpression`])\n- `closure_expression` ([`ClosureExpression`])\n- `compound_assignment_expr` ([`CompoundAssignmentExpr`])\n- `const_block` ([`ConstBlock`])\n- `continue_expression` ([`ContinueExpression`])\n- `field_expression` ([`FieldExpression`])\n- `for_expression` ([`ForExpression`])\n- `generic_function` ([`GenericFunction`])\n- `identifier` ([`Identifier`])\n- `if_expression` ([`IfExpression`])\n- `index_expression` ([`IndexExpression`])\n- `loop_expression` ([`LoopExpression`])\n- `macro_invocation` ([`MacroInvocation`])\n- `match_expression` ([`MatchExpression`])\n- `metavariable` ([`Metavariable`])\n- `parenthesized_expression` ([`ParenthesizedExpression`])\n- `range_expression` ([`RangeExpression`])\n- `reference_expression` ([`ReferenceExpression`])\n- `return_expression` ([`ReturnExpression`])\n- `scoped_identifier` ([`ScopedIdentifier`])\n- `self` ([`Self_`])\n- `struct_expression` ([`StructExpression`])\n- `try_block` ([`TryBlock`])\n- `try_expression` ([`TryExpression`])\n- `tuple_expression` ([`TupleExpression`])\n- `type_cast_expression` ([`TypeCastExpression`])\n- `unary_expression` ([`UnaryExpression`])\n- `unit_expression` ([`UnitExpression`])\n- `unsafe_block` ([`UnsafeBlock`])\n- `while_expression` ([`WhileExpression`])\n- `yield_expression` ([`YieldExpression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Expression<'tree> {
    Literal(Literal<'tree>),
    ArrayExpression(ArrayExpression<'tree>),
    AssignmentExpression(AssignmentExpression<'tree>),
    AsyncBlock(AsyncBlock<'tree>),
    AwaitExpression(AwaitExpression<'tree>),
    BinaryExpression(BinaryExpression<'tree>),
    Block(Block<'tree>),
    BreakExpression(BreakExpression<'tree>),
    CallExpression(CallExpression<'tree>),
    ClosureExpression(ClosureExpression<'tree>),
    CompoundAssignmentExpr(CompoundAssignmentExpr<'tree>),
    ConstBlock(ConstBlock<'tree>),
    ContinueExpression(ContinueExpression<'tree>),
    FieldExpression(FieldExpression<'tree>),
    ForExpression(ForExpression<'tree>),
    GenericFunction(GenericFunction<'tree>),
    Identifier(Identifier<'tree>),
    IfExpression(IfExpression<'tree>),
    IndexExpression(IndexExpression<'tree>),
    LoopExpression(LoopExpression<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    MatchExpression(MatchExpression<'tree>),
    Metavariable(Metavariable<'tree>),
    ParenthesizedExpression(ParenthesizedExpression<'tree>),
    RangeExpression(RangeExpression<'tree>),
    ReferenceExpression(ReferenceExpression<'tree>),
    ReturnExpression(ReturnExpression<'tree>),
    ScopedIdentifier(ScopedIdentifier<'tree>),
    Self_(Self_<'tree>),
    StructExpression(StructExpression<'tree>),
    TryBlock(TryBlock<'tree>),
    TryExpression(TryExpression<'tree>),
    TupleExpression(TupleExpression<'tree>),
    TypeCastExpression(TypeCastExpression<'tree>),
    UnaryExpression(UnaryExpression<'tree>),
    UnitExpression(UnitExpression<'tree>),
    UnsafeBlock(UnsafeBlock<'tree>),
    WhileExpression(WhileExpression<'tree>),
    YieldExpression(YieldExpression<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Expression<'tree> {
    #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`"]
    #[inline]
    pub fn as_literal(self) -> Option<Literal<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Literal(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_array_expression(self) -> Option<ArrayExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ArrayExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AssignmentExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`"]
    #[inline]
    pub fn as_async_block(self) -> Option<AsyncBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AsyncBlock(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_await_expression(self) -> Option<AwaitExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AwaitExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_binary_expression(self) -> Option<BinaryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BinaryExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`"]
    #[inline]
    pub fn as_block(self) -> Option<Block<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Block(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_break_expression(self) -> Option<BreakExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BreakExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_call_expression(self) -> Option<CallExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CallExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ClosureExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`"]
    #[inline]
    pub fn as_compound_assignment_expr(self) -> Option<CompoundAssignmentExpr<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CompoundAssignmentExpr(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`"]
    #[inline]
    pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConstBlock(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_continue_expression(self) -> Option<ContinueExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ContinueExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FieldExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_for_expression(self) -> Option<ForExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ForExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`"]
    #[inline]
    pub fn as_generic_function(self) -> Option<GenericFunction<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GenericFunction(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
    #[inline]
    pub fn as_identifier(self) -> Option<Identifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Identifier(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IfExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_index_expression(self) -> Option<IndexExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IndexExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_loop_expression(self) -> Option<LoopExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::LoopExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`"]
    #[inline]
    pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_match_expression(self) -> Option<MatchExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MatchExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"]
    #[inline]
    pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Metavariable(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ParenthesizedExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_range_expression(self) -> Option<RangeExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RangeExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_reference_expression(self) -> Option<ReferenceExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReferenceExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_return_expression(self) -> Option<ReturnExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReturnExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
    #[inline]
    pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ScopedIdentifier(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"]
    #[inline]
    pub fn as_self(self) -> Option<Self_<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Self_(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_struct_expression(self) -> Option<StructExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StructExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`"]
    #[inline]
    pub fn as_try_block(self) -> Option<TryBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TryBlock(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_try_expression(self) -> Option<TryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TryExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_tuple_expression(self) -> Option<TupleExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TupleExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_type_cast_expression(self) -> Option<TypeCastExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeCastExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_unary_expression(self) -> Option<UnaryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnaryExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_unit_expression(self) -> Option<UnitExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnitExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`"]
    #[inline]
    pub fn as_unsafe_block(self) -> Option<UnsafeBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnsafeBlock(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_while_expression(self) -> Option<WhileExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::WhileExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`"]
    #[inline]
    pub fn as_yield_expression(self) -> Option<YieldExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::YieldExpression(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
    #[inline]
    pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
        self.as_literal()?.as_boolean_literal()
    }
    #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
    #[inline]
    pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
        self.as_literal()?.as_char_literal()
    }
    #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
    #[inline]
    pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
        self.as_literal()?.as_float_literal()
    }
    #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
    #[inline]
    pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
        self.as_literal()?.as_integer_literal()
    }
    #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
    #[inline]
    pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
        self.as_literal()?.as_raw_string_literal()
    }
    #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
    #[inline]
    pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
        self.as_literal()?.as_string_literal()
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Expression<'tree> {
    type WithLifetime<'a> = Expression<'a>;
    const KIND: &'static str = "_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if let Ok(this) = <Literal<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Literal(this));
        }
        if let Ok(this) = <ArrayExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ArrayExpression(this));
        }
        if let Ok(this) =
            <AssignmentExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::AssignmentExpression(this));
        }
        if let Ok(this) = <AsyncBlock<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AsyncBlock(this));
        }
        if let Ok(this) = <AwaitExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AwaitExpression(this));
        }
        if let Ok(this) = <BinaryExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::BinaryExpression(this));
        }
        if let Ok(this) = <Block<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Block(this));
        }
        if let Ok(this) = <BreakExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::BreakExpression(this));
        }
        if let Ok(this) = <CallExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::CallExpression(this));
        }
        if let Ok(this) = <ClosureExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ClosureExpression(this));
        }
        if let Ok(this) =
            <CompoundAssignmentExpr<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::CompoundAssignmentExpr(this));
        }
        if let Ok(this) = <ConstBlock<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ConstBlock(this));
        }
        if let Ok(this) =
            <ContinueExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ContinueExpression(this));
        }
        if let Ok(this) = <FieldExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::FieldExpression(this));
        }
        if let Ok(this) = <ForExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ForExpression(this));
        }
        if let Ok(this) = <GenericFunction<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::GenericFunction(this));
        }
        if let Ok(this) = <Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Identifier(this));
        }
        if let Ok(this) = <IfExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::IfExpression(this));
        }
        if let Ok(this) = <IndexExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::IndexExpression(this));
        }
        if let Ok(this) = <LoopExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::LoopExpression(this));
        }
        if let Ok(this) = <MacroInvocation<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MacroInvocation(this));
        }
        if let Ok(this) = <MatchExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MatchExpression(this));
        }
        if let Ok(this) = <Metavariable<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Metavariable(this));
        }
        if let Ok(this) =
            <ParenthesizedExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ParenthesizedExpression(this));
        }
        if let Ok(this) = <RangeExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RangeExpression(this));
        }
        if let Ok(this) =
            <ReferenceExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ReferenceExpression(this));
        }
        if let Ok(this) = <ReturnExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ReturnExpression(this));
        }
        if let Ok(this) = <ScopedIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ScopedIdentifier(this));
        }
        if let Ok(this) = <Self_<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Self_(this));
        }
        if let Ok(this) = <StructExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::StructExpression(this));
        }
        if let Ok(this) = <TryBlock<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TryBlock(this));
        }
        if let Ok(this) = <TryExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TryExpression(this));
        }
        if let Ok(this) = <TupleExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TupleExpression(this));
        }
        if let Ok(this) =
            <TypeCastExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::TypeCastExpression(this));
        }
        if let Ok(this) = <UnaryExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnaryExpression(this));
        }
        if let Ok(this) = <UnitExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnitExpression(this));
        }
        if let Ok(this) = <UnsafeBlock<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnsafeBlock(this));
        }
        if let Ok(this) = <WhileExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::WhileExpression(this));
        }
        if let Ok(this) = <YieldExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::YieldExpression(this));
        }
        Err(type_sitter::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        match self {
            Self::Literal(x) => type_sitter::Node::raw(x),
            Self::ArrayExpression(x) => type_sitter::Node::raw(x),
            Self::AssignmentExpression(x) => type_sitter::Node::raw(x),
            Self::AsyncBlock(x) => type_sitter::Node::raw(x),
            Self::AwaitExpression(x) => type_sitter::Node::raw(x),
            Self::BinaryExpression(x) => type_sitter::Node::raw(x),
            Self::Block(x) => type_sitter::Node::raw(x),
            Self::BreakExpression(x) => type_sitter::Node::raw(x),
            Self::CallExpression(x) => type_sitter::Node::raw(x),
            Self::ClosureExpression(x) => type_sitter::Node::raw(x),
            Self::CompoundAssignmentExpr(x) => type_sitter::Node::raw(x),
            Self::ConstBlock(x) => type_sitter::Node::raw(x),
            Self::ContinueExpression(x) => type_sitter::Node::raw(x),
            Self::FieldExpression(x) => type_sitter::Node::raw(x),
            Self::ForExpression(x) => type_sitter::Node::raw(x),
            Self::GenericFunction(x) => type_sitter::Node::raw(x),
            Self::Identifier(x) => type_sitter::Node::raw(x),
            Self::IfExpression(x) => type_sitter::Node::raw(x),
            Self::IndexExpression(x) => type_sitter::Node::raw(x),
            Self::LoopExpression(x) => type_sitter::Node::raw(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw(x),
            Self::MatchExpression(x) => type_sitter::Node::raw(x),
            Self::Metavariable(x) => type_sitter::Node::raw(x),
            Self::ParenthesizedExpression(x) => type_sitter::Node::raw(x),
            Self::RangeExpression(x) => type_sitter::Node::raw(x),
            Self::ReferenceExpression(x) => type_sitter::Node::raw(x),
            Self::ReturnExpression(x) => type_sitter::Node::raw(x),
            Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
            Self::Self_(x) => type_sitter::Node::raw(x),
            Self::StructExpression(x) => type_sitter::Node::raw(x),
            Self::TryBlock(x) => type_sitter::Node::raw(x),
            Self::TryExpression(x) => type_sitter::Node::raw(x),
            Self::TupleExpression(x) => type_sitter::Node::raw(x),
            Self::TypeCastExpression(x) => type_sitter::Node::raw(x),
            Self::UnaryExpression(x) => type_sitter::Node::raw(x),
            Self::UnitExpression(x) => type_sitter::Node::raw(x),
            Self::UnsafeBlock(x) => type_sitter::Node::raw(x),
            Self::WhileExpression(x) => type_sitter::Node::raw(x),
            Self::YieldExpression(x) => type_sitter::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        match self {
            Self::Literal(x) => type_sitter::Node::raw_mut(x),
            Self::ArrayExpression(x) => type_sitter::Node::raw_mut(x),
            Self::AssignmentExpression(x) => type_sitter::Node::raw_mut(x),
            Self::AsyncBlock(x) => type_sitter::Node::raw_mut(x),
            Self::AwaitExpression(x) => type_sitter::Node::raw_mut(x),
            Self::BinaryExpression(x) => type_sitter::Node::raw_mut(x),
            Self::Block(x) => type_sitter::Node::raw_mut(x),
            Self::BreakExpression(x) => type_sitter::Node::raw_mut(x),
            Self::CallExpression(x) => type_sitter::Node::raw_mut(x),
            Self::ClosureExpression(x) => type_sitter::Node::raw_mut(x),
            Self::CompoundAssignmentExpr(x) => type_sitter::Node::raw_mut(x),
            Self::ConstBlock(x) => type_sitter::Node::raw_mut(x),
            Self::ContinueExpression(x) => type_sitter::Node::raw_mut(x),
            Self::FieldExpression(x) => type_sitter::Node::raw_mut(x),
            Self::ForExpression(x) => type_sitter::Node::raw_mut(x),
            Self::GenericFunction(x) => type_sitter::Node::raw_mut(x),
            Self::Identifier(x) => type_sitter::Node::raw_mut(x),
            Self::IfExpression(x) => type_sitter::Node::raw_mut(x),
            Self::IndexExpression(x) => type_sitter::Node::raw_mut(x),
            Self::LoopExpression(x) => type_sitter::Node::raw_mut(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw_mut(x),
            Self::MatchExpression(x) => type_sitter::Node::raw_mut(x),
            Self::Metavariable(x) => type_sitter::Node::raw_mut(x),
            Self::ParenthesizedExpression(x) => type_sitter::Node::raw_mut(x),
            Self::RangeExpression(x) => type_sitter::Node::raw_mut(x),
            Self::ReferenceExpression(x) => type_sitter::Node::raw_mut(x),
            Self::ReturnExpression(x) => type_sitter::Node::raw_mut(x),
            Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
            Self::Self_(x) => type_sitter::Node::raw_mut(x),
            Self::StructExpression(x) => type_sitter::Node::raw_mut(x),
            Self::TryBlock(x) => type_sitter::Node::raw_mut(x),
            Self::TryExpression(x) => type_sitter::Node::raw_mut(x),
            Self::TupleExpression(x) => type_sitter::Node::raw_mut(x),
            Self::TypeCastExpression(x) => type_sitter::Node::raw_mut(x),
            Self::UnaryExpression(x) => type_sitter::Node::raw_mut(x),
            Self::UnitExpression(x) => type_sitter::Node::raw_mut(x),
            Self::UnsafeBlock(x) => type_sitter::Node::raw_mut(x),
            Self::WhileExpression(x) => type_sitter::Node::raw_mut(x),
            Self::YieldExpression(x) => type_sitter::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        match self {
            Self::Literal(x) => x.into_raw(),
            Self::ArrayExpression(x) => x.into_raw(),
            Self::AssignmentExpression(x) => x.into_raw(),
            Self::AsyncBlock(x) => x.into_raw(),
            Self::AwaitExpression(x) => x.into_raw(),
            Self::BinaryExpression(x) => x.into_raw(),
            Self::Block(x) => x.into_raw(),
            Self::BreakExpression(x) => x.into_raw(),
            Self::CallExpression(x) => x.into_raw(),
            Self::ClosureExpression(x) => x.into_raw(),
            Self::CompoundAssignmentExpr(x) => x.into_raw(),
            Self::ConstBlock(x) => x.into_raw(),
            Self::ContinueExpression(x) => x.into_raw(),
            Self::FieldExpression(x) => x.into_raw(),
            Self::ForExpression(x) => x.into_raw(),
            Self::GenericFunction(x) => x.into_raw(),
            Self::Identifier(x) => x.into_raw(),
            Self::IfExpression(x) => x.into_raw(),
            Self::IndexExpression(x) => x.into_raw(),
            Self::LoopExpression(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::MatchExpression(x) => x.into_raw(),
            Self::Metavariable(x) => x.into_raw(),
            Self::ParenthesizedExpression(x) => x.into_raw(),
            Self::RangeExpression(x) => x.into_raw(),
            Self::ReferenceExpression(x) => x.into_raw(),
            Self::ReturnExpression(x) => x.into_raw(),
            Self::ScopedIdentifier(x) => x.into_raw(),
            Self::Self_(x) => x.into_raw(),
            Self::StructExpression(x) => x.into_raw(),
            Self::TryBlock(x) => x.into_raw(),
            Self::TryExpression(x) => x.into_raw(),
            Self::TupleExpression(x) => x.into_raw(),
            Self::TypeCastExpression(x) => x.into_raw(),
            Self::UnaryExpression(x) => x.into_raw(),
            Self::UnitExpression(x) => x.into_raw(),
            Self::UnsafeBlock(x) => x.into_raw(),
            Self::WhileExpression(x) => x.into_raw(),
            Self::YieldExpression(x) => x.into_raw(),
        }
    }
}
#[doc = "Typed node `_literal`\n\nThis node type has subtypes:\n\n- `boolean_literal` ([`BooleanLiteral`])\n- `char_literal` ([`CharLiteral`])\n- `float_literal` ([`FloatLiteral`])\n- `integer_literal` ([`IntegerLiteral`])\n- `raw_string_literal` ([`RawStringLiteral`])\n- `string_literal` ([`StringLiteral`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Literal<'tree> {
    BooleanLiteral(BooleanLiteral<'tree>),
    CharLiteral(CharLiteral<'tree>),
    FloatLiteral(FloatLiteral<'tree>),
    IntegerLiteral(IntegerLiteral<'tree>),
    RawStringLiteral(RawStringLiteral<'tree>),
    StringLiteral(StringLiteral<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Literal<'tree> {
    #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BooleanLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CharLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FloatLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IntegerLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RawStringLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StringLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Literal<'tree> {
    type WithLifetime<'a> = Literal<'a>;
    const KIND: &'static str = "_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        match node.kind() {
            "boolean_literal" => Ok(unsafe {
                Self::BooleanLiteral(
                    <BooleanLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "char_literal" => Ok(unsafe {
                Self::CharLiteral(
                    <CharLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "float_literal" => Ok(unsafe {
                Self::FloatLiteral(
                    <FloatLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "integer_literal" => Ok(unsafe {
                Self::IntegerLiteral(
                    <IntegerLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "raw_string_literal" => Ok(unsafe {
                Self::RawStringLiteral(
                    <RawStringLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "string_literal" => Ok(unsafe {
                Self::StringLiteral(
                    <StringLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => type_sitter::Node::raw(x),
            Self::CharLiteral(x) => type_sitter::Node::raw(x),
            Self::FloatLiteral(x) => type_sitter::Node::raw(x),
            Self::IntegerLiteral(x) => type_sitter::Node::raw(x),
            Self::RawStringLiteral(x) => type_sitter::Node::raw(x),
            Self::StringLiteral(x) => type_sitter::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::CharLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::FloatLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::IntegerLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::RawStringLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::StringLiteral(x) => type_sitter::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => x.into_raw(),
            Self::CharLiteral(x) => x.into_raw(),
            Self::FloatLiteral(x) => x.into_raw(),
            Self::IntegerLiteral(x) => x.into_raw(),
            Self::RawStringLiteral(x) => x.into_raw(),
            Self::StringLiteral(x) => x.into_raw(),
        }
    }
}
#[doc = "Typed node `_literal_pattern`\n\nThis node type has subtypes:\n\n- `boolean_literal` ([`BooleanLiteral`])\n- `char_literal` ([`CharLiteral`])\n- `float_literal` ([`FloatLiteral`])\n- `integer_literal` ([`IntegerLiteral`])\n- `negative_literal` ([`NegativeLiteral`])\n- `raw_string_literal` ([`RawStringLiteral`])\n- `string_literal` ([`StringLiteral`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum LiteralPattern<'tree> {
    BooleanLiteral(BooleanLiteral<'tree>),
    CharLiteral(CharLiteral<'tree>),
    FloatLiteral(FloatLiteral<'tree>),
    IntegerLiteral(IntegerLiteral<'tree>),
    NegativeLiteral(NegativeLiteral<'tree>),
    RawStringLiteral(RawStringLiteral<'tree>),
    StringLiteral(StringLiteral<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> LiteralPattern<'tree> {
    #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BooleanLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CharLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FloatLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IntegerLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_negative_literal(self) -> Option<NegativeLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::NegativeLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RawStringLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`"]
    #[inline]
    pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StringLiteral(x) = self {
            Some(x)
        } else {
            None
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for LiteralPattern<'tree> {
    type WithLifetime<'a> = LiteralPattern<'a>;
    const KIND: &'static str = "_literal_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        match node.kind() {
            "boolean_literal" => Ok(unsafe {
                Self::BooleanLiteral(
                    <BooleanLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "char_literal" => Ok(unsafe {
                Self::CharLiteral(
                    <CharLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "float_literal" => Ok(unsafe {
                Self::FloatLiteral(
                    <FloatLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "integer_literal" => Ok(unsafe {
                Self::IntegerLiteral(
                    <IntegerLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "negative_literal" => Ok(unsafe {
                Self::NegativeLiteral(
                    <NegativeLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "raw_string_literal" => Ok(unsafe {
                Self::RawStringLiteral(
                    <RawStringLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "string_literal" => Ok(unsafe {
                Self::StringLiteral(
                    <StringLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => type_sitter::Node::raw(x),
            Self::CharLiteral(x) => type_sitter::Node::raw(x),
            Self::FloatLiteral(x) => type_sitter::Node::raw(x),
            Self::IntegerLiteral(x) => type_sitter::Node::raw(x),
            Self::NegativeLiteral(x) => type_sitter::Node::raw(x),
            Self::RawStringLiteral(x) => type_sitter::Node::raw(x),
            Self::StringLiteral(x) => type_sitter::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::CharLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::FloatLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::IntegerLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::NegativeLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::RawStringLiteral(x) => type_sitter::Node::raw_mut(x),
            Self::StringLiteral(x) => type_sitter::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => x.into_raw(),
            Self::CharLiteral(x) => x.into_raw(),
            Self::FloatLiteral(x) => x.into_raw(),
            Self::IntegerLiteral(x) => x.into_raw(),
            Self::NegativeLiteral(x) => x.into_raw(),
            Self::RawStringLiteral(x) => x.into_raw(),
            Self::StringLiteral(x) => x.into_raw(),
        }
    }
}
#[doc = "Typed node `_pattern`\n\nThis node type has subtypes:\n\n- `_` ([`symbols::__`])\n- `_literal_pattern` ([`LiteralPattern`])\n- `captured_pattern` ([`CapturedPattern`])\n- `const_block` ([`ConstBlock`])\n- `identifier` ([`Identifier`])\n- `macro_invocation` ([`MacroInvocation`])\n- `mut_pattern` ([`MutPattern`])\n- `or_pattern` ([`OrPattern`])\n- `range_pattern` ([`RangePattern`])\n- `ref_pattern` ([`RefPattern`])\n- `reference_pattern` ([`ReferencePattern`])\n- `remaining_field_pattern` ([`RemainingFieldPattern`])\n- `scoped_identifier` ([`ScopedIdentifier`])\n- `slice_pattern` ([`SlicePattern`])\n- `struct_pattern` ([`StructPattern`])\n- `tuple_pattern` ([`TuplePattern`])\n- `tuple_struct_pattern` ([`TupleStructPattern`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Pattern<'tree> {
    __(symbols::__<'tree>),
    LiteralPattern(LiteralPattern<'tree>),
    CapturedPattern(CapturedPattern<'tree>),
    ConstBlock(ConstBlock<'tree>),
    Identifier(Identifier<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    MutPattern(MutPattern<'tree>),
    OrPattern(OrPattern<'tree>),
    RangePattern(RangePattern<'tree>),
    RefPattern(RefPattern<'tree>),
    ReferencePattern(ReferencePattern<'tree>),
    RemainingFieldPattern(RemainingFieldPattern<'tree>),
    ScopedIdentifier(ScopedIdentifier<'tree>),
    SlicePattern(SlicePattern<'tree>),
    StructPattern(StructPattern<'tree>),
    TuplePattern(TuplePattern<'tree>),
    TupleStructPattern(TupleStructPattern<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Pattern<'tree> {
    #[doc = "Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`"]
    #[inline]
    pub fn as___(self) -> Option<symbols::__<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::__(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_literal_pattern(self) -> Option<LiteralPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::LiteralPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_captured_pattern(self) -> Option<CapturedPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CapturedPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`"]
    #[inline]
    pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConstBlock(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
    #[inline]
    pub fn as_identifier(self) -> Option<Identifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Identifier(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`"]
    #[inline]
    pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_mut_pattern(self) -> Option<MutPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MutPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_or_pattern(self) -> Option<OrPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::OrPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_range_pattern(self) -> Option<RangePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RangePattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_ref_pattern(self) -> Option<RefPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RefPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_reference_pattern(self) -> Option<ReferencePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReferencePattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_remaining_field_pattern(self) -> Option<RemainingFieldPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RemainingFieldPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
    #[inline]
    pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ScopedIdentifier(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_slice_pattern(self) -> Option<SlicePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SlicePattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_struct_pattern(self) -> Option<StructPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StructPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_tuple_pattern(self) -> Option<TuplePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TuplePattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`"]
    #[inline]
    pub fn as_tuple_struct_pattern(self) -> Option<TupleStructPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TupleStructPattern(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
    #[inline]
    pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
        self.as_literal_pattern()?.as_boolean_literal()
    }
    #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
    #[inline]
    pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
        self.as_literal_pattern()?.as_char_literal()
    }
    #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
    #[inline]
    pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
        self.as_literal_pattern()?.as_float_literal()
    }
    #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
    #[inline]
    pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
        self.as_literal_pattern()?.as_integer_literal()
    }
    #[doc = "Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
    #[inline]
    pub fn as_negative_literal(self) -> Option<NegativeLiteral<'tree>> {
        self.as_literal_pattern()?.as_negative_literal()
    }
    #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
    #[inline]
    pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
        self.as_literal_pattern()?.as_raw_string_literal()
    }
    #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
    #[inline]
    pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
        self.as_literal_pattern()?.as_string_literal()
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Pattern<'tree> {
    type WithLifetime<'a> = Pattern<'a>;
    const KIND: &'static str = "_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if let Ok(this) = <symbols::__<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::__(this));
        }
        if let Ok(this) = <LiteralPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::LiteralPattern(this));
        }
        if let Ok(this) = <CapturedPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::CapturedPattern(this));
        }
        if let Ok(this) = <ConstBlock<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ConstBlock(this));
        }
        if let Ok(this) = <Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Identifier(this));
        }
        if let Ok(this) = <MacroInvocation<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MacroInvocation(this));
        }
        if let Ok(this) = <MutPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MutPattern(this));
        }
        if let Ok(this) = <OrPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::OrPattern(this));
        }
        if let Ok(this) = <RangePattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RangePattern(this));
        }
        if let Ok(this) = <RefPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RefPattern(this));
        }
        if let Ok(this) = <ReferencePattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ReferencePattern(this));
        }
        if let Ok(this) =
            <RemainingFieldPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::RemainingFieldPattern(this));
        }
        if let Ok(this) = <ScopedIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::ScopedIdentifier(this));
        }
        if let Ok(this) = <SlicePattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::SlicePattern(this));
        }
        if let Ok(this) = <StructPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::StructPattern(this));
        }
        if let Ok(this) = <TuplePattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TuplePattern(this));
        }
        if let Ok(this) =
            <TupleStructPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
        {
            return Ok(Self::TupleStructPattern(this));
        }
        Err(type_sitter::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        match self {
            Self::__(x) => type_sitter::Node::raw(x),
            Self::LiteralPattern(x) => type_sitter::Node::raw(x),
            Self::CapturedPattern(x) => type_sitter::Node::raw(x),
            Self::ConstBlock(x) => type_sitter::Node::raw(x),
            Self::Identifier(x) => type_sitter::Node::raw(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw(x),
            Self::MutPattern(x) => type_sitter::Node::raw(x),
            Self::OrPattern(x) => type_sitter::Node::raw(x),
            Self::RangePattern(x) => type_sitter::Node::raw(x),
            Self::RefPattern(x) => type_sitter::Node::raw(x),
            Self::ReferencePattern(x) => type_sitter::Node::raw(x),
            Self::RemainingFieldPattern(x) => type_sitter::Node::raw(x),
            Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
            Self::SlicePattern(x) => type_sitter::Node::raw(x),
            Self::StructPattern(x) => type_sitter::Node::raw(x),
            Self::TuplePattern(x) => type_sitter::Node::raw(x),
            Self::TupleStructPattern(x) => type_sitter::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        match self {
            Self::__(x) => type_sitter::Node::raw_mut(x),
            Self::LiteralPattern(x) => type_sitter::Node::raw_mut(x),
            Self::CapturedPattern(x) => type_sitter::Node::raw_mut(x),
            Self::ConstBlock(x) => type_sitter::Node::raw_mut(x),
            Self::Identifier(x) => type_sitter::Node::raw_mut(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw_mut(x),
            Self::MutPattern(x) => type_sitter::Node::raw_mut(x),
            Self::OrPattern(x) => type_sitter::Node::raw_mut(x),
            Self::RangePattern(x) => type_sitter::Node::raw_mut(x),
            Self::RefPattern(x) => type_sitter::Node::raw_mut(x),
            Self::ReferencePattern(x) => type_sitter::Node::raw_mut(x),
            Self::RemainingFieldPattern(x) => type_sitter::Node::raw_mut(x),
            Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
            Self::SlicePattern(x) => type_sitter::Node::raw_mut(x),
            Self::StructPattern(x) => type_sitter::Node::raw_mut(x),
            Self::TuplePattern(x) => type_sitter::Node::raw_mut(x),
            Self::TupleStructPattern(x) => type_sitter::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        match self {
            Self::__(x) => x.into_raw(),
            Self::LiteralPattern(x) => x.into_raw(),
            Self::CapturedPattern(x) => x.into_raw(),
            Self::ConstBlock(x) => x.into_raw(),
            Self::Identifier(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::MutPattern(x) => x.into_raw(),
            Self::OrPattern(x) => x.into_raw(),
            Self::RangePattern(x) => x.into_raw(),
            Self::RefPattern(x) => x.into_raw(),
            Self::ReferencePattern(x) => x.into_raw(),
            Self::RemainingFieldPattern(x) => x.into_raw(),
            Self::ScopedIdentifier(x) => x.into_raw(),
            Self::SlicePattern(x) => x.into_raw(),
            Self::StructPattern(x) => x.into_raw(),
            Self::TuplePattern(x) => x.into_raw(),
            Self::TupleStructPattern(x) => x.into_raw(),
        }
    }
}
#[doc = "Typed node `_type`\n\nThis node type has subtypes:\n\n- `abstract_type` ([`AbstractType`])\n- `array_type` ([`ArrayType`])\n- `bounded_type` ([`BoundedType`])\n- `dynamic_type` ([`DynamicType`])\n- `function_type` ([`FunctionType`])\n- `generic_type` ([`GenericType`])\n- `macro_invocation` ([`MacroInvocation`])\n- `metavariable` ([`Metavariable`])\n- `never_type` ([`NeverType`])\n- `pointer_type` ([`PointerType`])\n- `primitive_type` ([`PrimitiveType`])\n- `reference_type` ([`ReferenceType`])\n- `removed_trait_bound` ([`RemovedTraitBound`])\n- `scoped_type_identifier` ([`ScopedTypeIdentifier`])\n- `tuple_type` ([`TupleType`])\n- `type_identifier` ([`TypeIdentifier`])\n- `unit_type` ([`UnitType`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Type<'tree> {
    AbstractType(AbstractType<'tree>),
    ArrayType(ArrayType<'tree>),
    BoundedType(BoundedType<'tree>),
    DynamicType(DynamicType<'tree>),
    FunctionType(FunctionType<'tree>),
    GenericType(GenericType<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    Metavariable(Metavariable<'tree>),
    NeverType(NeverType<'tree>),
    PointerType(PointerType<'tree>),
    PrimitiveType(PrimitiveType<'tree>),
    ReferenceType(ReferenceType<'tree>),
    RemovedTraitBound(RemovedTraitBound<'tree>),
    ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
    TupleType(TupleType<'tree>),
    TypeIdentifier(TypeIdentifier<'tree>),
    UnitType(UnitType<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Type<'tree> {
    #[doc = "Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_abstract_type(self) -> Option<AbstractType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AbstractType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_array_type(self) -> Option<ArrayType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ArrayType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_bounded_type(self) -> Option<BoundedType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BoundedType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_dynamic_type(self) -> Option<DynamicType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::DynamicType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GenericType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`"]
    #[inline]
    pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"]
    #[inline]
    pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Metavariable(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_never_type(self) -> Option<NeverType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::NeverType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_pointer_type(self) -> Option<PointerType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PointerType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_primitive_type(self) -> Option<PrimitiveType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PrimitiveType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_reference_type(self) -> Option<ReferenceType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReferenceType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`"]
    #[inline]
    pub fn as_removed_trait_bound(self) -> Option<RemovedTraitBound<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RemovedTraitBound(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"]
    #[inline]
    pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ScopedTypeIdentifier(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_tuple_type(self) -> Option<TupleType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TupleType(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
    #[inline]
    pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeIdentifier(x) = self {
            Some(x)
        } else {
            None
        }
    }
    #[doc = "Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`"]
    #[inline]
    pub fn as_unit_type(self) -> Option<UnitType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnitType(x) = self {
            Some(x)
        } else {
            None
        }
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Type<'tree> {
    type WithLifetime<'a> = Type<'a>;
    const KIND: &'static str = "_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        match node.kind() {
            "abstract_type" => Ok(unsafe {
                Self::AbstractType(
                    <AbstractType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "array_type" => Ok(unsafe {
                Self::ArrayType(
                    <ArrayType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "bounded_type" => Ok(unsafe {
                Self::BoundedType(
                    <BoundedType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "dynamic_type" => Ok(unsafe {
                Self::DynamicType(
                    <DynamicType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "function_type" => Ok(unsafe {
                Self::FunctionType(
                    <FunctionType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "generic_type" => Ok(unsafe {
                Self::GenericType(
                    <GenericType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "macro_invocation" => Ok(unsafe {
                Self::MacroInvocation(
                    <MacroInvocation<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "metavariable" => Ok(unsafe {
                Self::Metavariable(
                    <Metavariable<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "never_type" => Ok(unsafe {
                Self::NeverType(
                    <NeverType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "pointer_type" => Ok(unsafe {
                Self::PointerType(
                    <PointerType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "primitive_type" => Ok(unsafe {
                Self::PrimitiveType(
                    <PrimitiveType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "reference_type" => Ok(unsafe {
                Self::ReferenceType(
                    <ReferenceType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "removed_trait_bound" => {
                Ok(unsafe {
                    Self::RemovedTraitBound(<RemovedTraitBound<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                })
            }
            "scoped_type_identifier" => Ok(unsafe {
                Self::ScopedTypeIdentifier(<ScopedTypeIdentifier<'tree> as type_sitter::Node<
                    'tree,
                >>::from_raw_unchecked(node))
            }),
            "tuple_type" => Ok(unsafe {
                Self::TupleType(
                    <TupleType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "type_identifier" => Ok(unsafe {
                Self::TypeIdentifier(
                    <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            "unit_type" => Ok(unsafe {
                Self::UnitType(
                    <UnitType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                )
            }),
            _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        match self {
            Self::AbstractType(x) => type_sitter::Node::raw(x),
            Self::ArrayType(x) => type_sitter::Node::raw(x),
            Self::BoundedType(x) => type_sitter::Node::raw(x),
            Self::DynamicType(x) => type_sitter::Node::raw(x),
            Self::FunctionType(x) => type_sitter::Node::raw(x),
            Self::GenericType(x) => type_sitter::Node::raw(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw(x),
            Self::Metavariable(x) => type_sitter::Node::raw(x),
            Self::NeverType(x) => type_sitter::Node::raw(x),
            Self::PointerType(x) => type_sitter::Node::raw(x),
            Self::PrimitiveType(x) => type_sitter::Node::raw(x),
            Self::ReferenceType(x) => type_sitter::Node::raw(x),
            Self::RemovedTraitBound(x) => type_sitter::Node::raw(x),
            Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw(x),
            Self::TupleType(x) => type_sitter::Node::raw(x),
            Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            Self::UnitType(x) => type_sitter::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        match self {
            Self::AbstractType(x) => type_sitter::Node::raw_mut(x),
            Self::ArrayType(x) => type_sitter::Node::raw_mut(x),
            Self::BoundedType(x) => type_sitter::Node::raw_mut(x),
            Self::DynamicType(x) => type_sitter::Node::raw_mut(x),
            Self::FunctionType(x) => type_sitter::Node::raw_mut(x),
            Self::GenericType(x) => type_sitter::Node::raw_mut(x),
            Self::MacroInvocation(x) => type_sitter::Node::raw_mut(x),
            Self::Metavariable(x) => type_sitter::Node::raw_mut(x),
            Self::NeverType(x) => type_sitter::Node::raw_mut(x),
            Self::PointerType(x) => type_sitter::Node::raw_mut(x),
            Self::PrimitiveType(x) => type_sitter::Node::raw_mut(x),
            Self::ReferenceType(x) => type_sitter::Node::raw_mut(x),
            Self::RemovedTraitBound(x) => type_sitter::Node::raw_mut(x),
            Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            Self::TupleType(x) => type_sitter::Node::raw_mut(x),
            Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            Self::UnitType(x) => type_sitter::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        match self {
            Self::AbstractType(x) => x.into_raw(),
            Self::ArrayType(x) => x.into_raw(),
            Self::BoundedType(x) => x.into_raw(),
            Self::DynamicType(x) => x.into_raw(),
            Self::FunctionType(x) => x.into_raw(),
            Self::GenericType(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::Metavariable(x) => x.into_raw(),
            Self::NeverType(x) => x.into_raw(),
            Self::PointerType(x) => x.into_raw(),
            Self::PrimitiveType(x) => x.into_raw(),
            Self::ReferenceType(x) => x.into_raw(),
            Self::RemovedTraitBound(x) => x.into_raw(),
            Self::ScopedTypeIdentifier(x) => x.into_raw(),
            Self::TupleType(x) => x.into_raw(),
            Self::TypeIdentifier(x) => x.into_raw(),
            Self::UnitType(x) => x.into_raw(),
        }
    }
}
#[doc = "Typed node `abstract_type`\n\nThis node has these fields:\n\n- `trait`: `{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}` ([`FunctionType`] | [`GenericType`] | [`RemovedTraitBound`] | [`ScopedTypeIdentifier`] | [`TupleType`] | [`TypeIdentifier`])\n\nAnd an optional additional named child of type `type_parameters?` ([`TypeParameters`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AbstractType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AbstractType<'tree> {
    #[doc = "Get the field `trait`.\n\nThis child has type `{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}`:\n\n- [`FunctionType`]\n- [`GenericType`]\n- [`RemovedTraitBound`]\n- [`ScopedTypeIdentifier`]\n- [`TupleType`]\n- [`TypeIdentifier`]\n"]
    #[inline]    pub fn r#trait (& self) -> type_sitter :: NodeResult < 'tree , anon_unions :: FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'tree > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("trait") . map (< anon_unions :: FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for AbstractType<'tree> {
    type WithLifetime<'a> = AbstractType<'a>;
    const KIND: &'static str = "abstract_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "abstract_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "abstract_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `arguments`\n\nThis node has named children of type `{_expression | attribute_item}*`:\n\n- [`Expression`]\n- [`AttributeItem`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Arguments<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Arguments<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_expression | attribute_item}*`:\n\n- [`Expression`]\n- [`AttributeItem`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Expression_AttributeItem<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Expression_AttributeItem < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Arguments<'tree> {
    type WithLifetime<'a> = Arguments<'a>;
    const KIND: &'static str = "arguments";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "arguments" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "arguments");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `array_expression`\n\nThis node has these fields:\n\n- `length`: `_expression?` ([`Expression`])\n\nAnd additional named children of type `{_expression | attribute_item}*`:\n\n- [`Expression`]\n- [`AttributeItem`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ArrayExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ArrayExpression<'tree> {
    #[doc = "Get the optional field `length`.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn length(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("length")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{_expression | attribute_item}*`:\n\n- [`Expression`]\n- [`AttributeItem`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Expression_AttributeItem<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: Expression_AttributeItem < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ArrayExpression<'tree> {
    type WithLifetime<'a> = ArrayExpression<'a>;
    const KIND: &'static str = "array_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "array_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "array_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `array_type`\n\nThis node has these fields:\n\n- `element`: `_type` ([`Type`])\n- `length`: `_expression?` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ArrayType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ArrayType<'tree> {
    #[doc = "Get the field `element`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn element(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("element")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `length`.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn length(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("length")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ArrayType<'tree> {
    type WithLifetime<'a> = ArrayType<'a>;
    const KIND: &'static str = "array_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "array_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "array_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `assignment_expression`\n\nThis node has these fields:\n\n- `left`: `_expression` ([`Expression`])\n- `right`: `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AssignmentExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AssignmentExpression<'tree> {
    #[doc = "Get the field `left`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn left(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("left")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `right`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn right(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("right")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for AssignmentExpression<'tree> {
    type WithLifetime<'a> = AssignmentExpression<'a>;
    const KIND: &'static str = "assignment_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "assignment_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "assignment_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `associated_type`\n\nThis node has these fields:\n\n- `bounds`: `trait_bounds?` ([`TraitBounds`])\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd an optional additional named child of type `where_clause?` ([`WhereClause`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AssociatedType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AssociatedType<'tree> {
    #[doc = "Get the optional field `bounds`.\n\nThis child has type `trait_bounds?` ([`TraitBounds`])"]
    #[inline]
    pub fn bounds(&self) -> Option<type_sitter::NodeResult<'tree, TraitBounds<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `where_clause?` ([`WhereClause`])"]
    #[inline]
    pub fn where_clause(&self) -> Option<type_sitter::NodeResult<'tree, WhereClause<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<WhereClause<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for AssociatedType<'tree> {
    type WithLifetime<'a> = AssociatedType<'a>;
    const KIND: &'static str = "associated_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "associated_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "associated_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `async_block`\n\nThis node has a named child of type `block` ([`Block`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AsyncBlock<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AsyncBlock<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn block(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for AsyncBlock<'tree> {
    type WithLifetime<'a> = AsyncBlock<'a>;
    const KIND: &'static str = "async_block";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "async_block" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "async_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `attribute`\n\nThis node has these fields:\n\n- `arguments`: `token_tree?` ([`TokenTree`])\n- `value`: `_expression?` ([`Expression`])\n\nAnd an additional named child of type `{crate | identifier | metavariable | scoped_identifier | self | super}`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Attribute<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Attribute<'tree> {
    #[doc = "Get the optional field `arguments`.\n\nThis child has type `token_tree?` ([`TokenTree`])"]
    #[inline]
    pub fn arguments(&self) -> Option<type_sitter::NodeResult<'tree, TokenTree<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("arguments")
            .map(<TokenTree<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `value`.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child.\n\nThis child has type `{crate | identifier | metavariable | scoped_identifier | self | super}`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[inline]
    pub fn other(
        &self,
    ) -> type_sitter::NodeResult<
        'tree,
        anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>,
    > {
        (0 .. type_sitter :: Node :: raw (self) . named_child_count ()) . filter (| i | type_sitter :: Node :: raw (self) . field_name_for_named_child (* i as _) . is_none ()) . map (| i | type_sitter :: Node :: raw (self) . named_child (i) . unwrap ()) . filter (| n | ! n . is_extra ()) . next () . map (< anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Attribute<'tree> {
    type WithLifetime<'a> = Attribute<'a>;
    const KIND: &'static str = "attribute";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "attribute" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attribute");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `attribute_item`\n\nThis node has a named child of type `attribute` ([`Attribute`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AttributeItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AttributeItem<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `attribute` ([`Attribute`])"]
    #[inline]
    pub fn attribute(&self) -> type_sitter::NodeResult<'tree, Attribute<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Attribute<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for AttributeItem<'tree> {
    type WithLifetime<'a> = AttributeItem<'a>;
    const KIND: &'static str = "attribute_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "attribute_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attribute_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `await_expression`\n\nThis node has a named child of type `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AwaitExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AwaitExpression<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for AwaitExpression<'tree> {
    type WithLifetime<'a> = AwaitExpression<'a>;
    const KIND: &'static str = "await_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "await_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "await_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `base_field_initializer`\n\nThis node has a named child of type `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BaseFieldInitializer<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BaseFieldInitializer<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for BaseFieldInitializer<'tree> {
    type WithLifetime<'a> = BaseFieldInitializer<'a>;
    const KIND: &'static str = "base_field_initializer";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "base_field_initializer" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "base_field_initializer");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `binary_expression`\n\nThis node has these fields:\n\n- `left`: `_expression` ([`Expression`])\n- `operator`: `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}` ([`symbols::NotEq`] | [`symbols::Mod`] | [`symbols::And`] | [`symbols::AndAnd`] | [`symbols::Mul`] | [`symbols::Add`] | [`symbols::Sub`] | [`symbols::Div`] | [`symbols::Lt`] | [`symbols::LtLt`] | [`symbols::LtEq`] | [`symbols::EqEq`] | [`symbols::Gt`] | [`symbols::GtEq`] | [`symbols::GtGt`] | [`symbols::BitXor`] | [`symbols::Or`] | [`symbols::OrOr`])\n- `right`: `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BinaryExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BinaryExpression<'tree> {
    #[doc = "Get the field `left`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn left(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("left")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `operator`.\n\nThis child has type `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}`:\n\n- [`symbols::NotEq`]\n- [`symbols::Mod`]\n- [`symbols::And`]\n- [`symbols::AndAnd`]\n- [`symbols::Mul`]\n- [`symbols::Add`]\n- [`symbols::Sub`]\n- [`symbols::Div`]\n- [`symbols::Lt`]\n- [`symbols::LtLt`]\n- [`symbols::LtEq`]\n- [`symbols::EqEq`]\n- [`symbols::Gt`]\n- [`symbols::GtEq`]\n- [`symbols::GtGt`]\n- [`symbols::BitXor`]\n- [`symbols::Or`]\n- [`symbols::OrOr`]\n"]
    #[inline]    pub fn operator (& self) -> type_sitter :: NodeResult < 'tree , anon_unions :: NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr < 'tree > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("operator") . map (< anon_unions :: NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn right(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("right")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for BinaryExpression<'tree> {
    type WithLifetime<'a> = BinaryExpression<'a>;
    const KIND: &'static str = "binary_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "binary_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "binary_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `block`\n\nThis node has named children of type `{_declaration_statement | _expression | expression_statement | label}*`:\n\n- [`DeclarationStatement`]\n- [`Expression`]\n- [`ExpressionStatement`]\n- [`Label`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Block<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Block<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_declaration_statement | _expression | expression_statement | label}*`:\n\n- [`DeclarationStatement`]\n- [`Expression`]\n- [`ExpressionStatement`]\n- [`Label`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::DeclarationStatement_Expression_ExpressionStatement_Label<'tree>,
        >,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: DeclarationStatement_Expression_ExpressionStatement_Label < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Block<'tree> {
    type WithLifetime<'a> = Block<'a>;
    const KIND: &'static str = "block";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "block" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `block_comment`\n\nThis node has these fields:\n\n- `doc`: `doc_comment?` ([`DocComment`])\n- `inner`: `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])\n- `outer`: `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BlockComment<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BlockComment<'tree> {
    #[doc = "Get the optional field `doc`.\n\nThis child has type `doc_comment?` ([`DocComment`])"]
    #[inline]
    pub fn doc(&self) -> Option<type_sitter::NodeResult<'tree, DocComment<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("doc")
            .map(<DocComment<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `inner`.\n\nThis child has type `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])"]
    #[inline]
    pub fn inner(&self) -> Option<type_sitter::NodeResult<'tree, InnerDocCommentMarker<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("inner")
            .map(<InnerDocCommentMarker<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `outer`.\n\nThis child has type `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])"]
    #[inline]
    pub fn outer(&self) -> Option<type_sitter::NodeResult<'tree, OuterDocCommentMarker<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("outer")
            .map(<OuterDocCommentMarker<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for BlockComment<'tree> {
    type WithLifetime<'a> = BlockComment<'a>;
    const KIND: &'static str = "block_comment";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "block_comment" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "block_comment");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `boolean_literal`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BooleanLiteral<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BooleanLiteral<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for BooleanLiteral<'tree> {
    type WithLifetime<'a> = BooleanLiteral<'a>;
    const KIND: &'static str = "boolean_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "boolean_literal" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "boolean_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `bounded_type`\n\nThis node has named children of type `{_type | lifetime}+`:\n\n- [`Type`]\n- [`Lifetime`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BoundedType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BoundedType<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_type | lifetime}+`:\n\n- [`Type`]\n- [`Lifetime`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, anon_unions::Type_Lifetime<'tree>>> + 'a
    {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<anon_unions::Type_Lifetime<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for BoundedType<'tree> {
    type WithLifetime<'a> = BoundedType<'a>;
    const KIND: &'static str = "bounded_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "bounded_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "bounded_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `bracketed_type`\n\nThis node has a named child of type `{_type | qualified_type}`:\n\n- [`Type`]\n- [`QualifiedType`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BracketedType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BracketedType<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `{_type | qualified_type}`:\n\n- [`Type`]\n- [`QualifiedType`]\n"]
    #[inline]
    pub fn child(&self) -> type_sitter::NodeResult<'tree, anon_unions::Type_QualifiedType<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<anon_unions::Type_QualifiedType<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for BracketedType<'tree> {
    type WithLifetime<'a> = BracketedType<'a>;
    const KIND: &'static str = "bracketed_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "bracketed_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "bracketed_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `break_expression`\n\nThis node has named children of type `{_expression | label}*`:\n\n- [`Expression`]\n- [`Label`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BreakExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BreakExpression<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_expression | label}*`:\n\n- [`Expression`]\n- [`Label`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, anon_unions::Expression_Label<'tree>>> + 'a
    {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<anon_unions::Expression_Label<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for BreakExpression<'tree> {
    type WithLifetime<'a> = BreakExpression<'a>;
    const KIND: &'static str = "break_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "break_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "break_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `call_expression`\n\nThis node has these fields:\n\n- `arguments`: `arguments` ([`Arguments`])\n- `function`: `{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}` ([`Literal`] | [`ArrayExpression`] | [`AssignmentExpression`] | [`AsyncBlock`] | [`AwaitExpression`] | [`BinaryExpression`] | [`Block`] | [`BreakExpression`] | [`CallExpression`] | [`ClosureExpression`] | [`CompoundAssignmentExpr`] | [`ConstBlock`] | [`ContinueExpression`] | [`FieldExpression`] | [`ForExpression`] | [`GenericFunction`] | [`Identifier`] | [`IfExpression`] | [`IndexExpression`] | [`LoopExpression`] | [`MacroInvocation`] | [`MatchExpression`] | [`Metavariable`] | [`ParenthesizedExpression`] | [`ReferenceExpression`] | [`ReturnExpression`] | [`ScopedIdentifier`] | [`Self_`] | [`StructExpression`] | [`TryBlock`] | [`TryExpression`] | [`TupleExpression`] | [`TypeCastExpression`] | [`UnaryExpression`] | [`UnitExpression`] | [`UnsafeBlock`] | [`WhileExpression`] | [`YieldExpression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CallExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CallExpression<'tree> {
    #[doc = "Get the field `arguments`.\n\nThis child has type `arguments` ([`Arguments`])"]
    #[inline]
    pub fn arguments(&self) -> type_sitter::NodeResult<'tree, Arguments<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("arguments")
            .map(<Arguments<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `function`.\n\nThis child has type `{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}`:\n\n- [`Literal`]\n- [`ArrayExpression`]\n- [`AssignmentExpression`]\n- [`AsyncBlock`]\n- [`AwaitExpression`]\n- [`BinaryExpression`]\n- [`Block`]\n- [`BreakExpression`]\n- [`CallExpression`]\n- [`ClosureExpression`]\n- [`CompoundAssignmentExpr`]\n- [`ConstBlock`]\n- [`ContinueExpression`]\n- [`FieldExpression`]\n- [`ForExpression`]\n- [`GenericFunction`]\n- [`Identifier`]\n- [`IfExpression`]\n- [`IndexExpression`]\n- [`LoopExpression`]\n- [`MacroInvocation`]\n- [`MatchExpression`]\n- [`Metavariable`]\n- [`ParenthesizedExpression`]\n- [`ReferenceExpression`]\n- [`ReturnExpression`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`StructExpression`]\n- [`TryBlock`]\n- [`TryExpression`]\n- [`TupleExpression`]\n- [`TypeCastExpression`]\n- [`UnaryExpression`]\n- [`UnitExpression`]\n- [`UnsafeBlock`]\n- [`WhileExpression`]\n- [`YieldExpression`]\n"]
    #[inline]    pub fn function (& self) -> type_sitter :: NodeResult < 'tree , anon_unions :: Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression < 'tree > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("function") . map (< anon_unions :: Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for CallExpression<'tree> {
    type WithLifetime<'a> = CallExpression<'a>;
    const KIND: &'static str = "call_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "call_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "call_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `captured_pattern`\n\nThis node has named children of type `_pattern+` ([`Pattern`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CapturedPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CapturedPattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `_pattern+` ([`Pattern`])"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Pattern<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for CapturedPattern<'tree> {
    type WithLifetime<'a> = CapturedPattern<'a>;
    const KIND: &'static str = "captured_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "captured_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "captured_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `char_literal`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CharLiteral<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CharLiteral<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for CharLiteral<'tree> {
    type WithLifetime<'a> = CharLiteral<'a>;
    const KIND: &'static str = "char_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "char_literal" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "char_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `closure_expression`\n\nThis node has these fields:\n\n- `body`: `{_ | _expression}` ([`symbols::__`] | [`Expression`])\n- `parameters`: `closure_parameters` ([`ClosureParameters`])\n- `return_type`: `_type?` ([`Type`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ClosureExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ClosureExpression<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `{_ | _expression}`:\n\n- [`symbols::__`]\n- [`Expression`]\n"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, anon_unions::___Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<anon_unions::___Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `parameters`.\n\nThis child has type `closure_parameters` ([`ClosureParameters`])"]
    #[inline]
    pub fn parameters(&self) -> type_sitter::NodeResult<'tree, ClosureParameters<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<ClosureParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `return_type`.\n\nThis child has type `_type?` ([`Type`])"]
    #[inline]
    pub fn return_type(&self) -> Option<type_sitter::NodeResult<'tree, Type<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ClosureExpression<'tree> {
    type WithLifetime<'a> = ClosureExpression<'a>;
    const KIND: &'static str = "closure_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "closure_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "closure_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `closure_parameters`\n\nThis node has named children of type `{_pattern | parameter}*`:\n\n- [`Pattern`]\n- [`Parameter`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ClosureParameters<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ClosureParameters<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_pattern | parameter}*`:\n\n- [`Pattern`]\n- [`Parameter`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, anon_unions::Pattern_Parameter<'tree>>> + 'a
    {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<anon_unions::Pattern_Parameter<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ClosureParameters<'tree> {
    type WithLifetime<'a> = ClosureParameters<'a>;
    const KIND: &'static str = "closure_parameters";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "closure_parameters" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "closure_parameters");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `compound_assignment_expr`\n\nThis node has these fields:\n\n- `left`: `_expression` ([`Expression`])\n- `operator`: `{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}` ([`symbols::ModEq`] | [`symbols::AndEq`] | [`symbols::MulEq`] | [`symbols::AddEq`] | [`symbols::SubEq`] | [`symbols::DivEq`] | [`symbols::LtLtEq`] | [`symbols::GtGtEq`] | [`symbols::BitXorEq`] | [`symbols::OrEq`])\n- `right`: `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CompoundAssignmentExpr<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CompoundAssignmentExpr<'tree> {
    #[doc = "Get the field `left`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn left(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("left")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `operator`.\n\nThis child has type `{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}`:\n\n- [`symbols::ModEq`]\n- [`symbols::AndEq`]\n- [`symbols::MulEq`]\n- [`symbols::AddEq`]\n- [`symbols::SubEq`]\n- [`symbols::DivEq`]\n- [`symbols::LtLtEq`]\n- [`symbols::GtGtEq`]\n- [`symbols::BitXorEq`]\n- [`symbols::OrEq`]\n"]
    #[inline]
    pub fn operator(
        &self,
    ) -> type_sitter::NodeResult<
        'tree,
        anon_unions::ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'tree>,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("operator") . map (< anon_unions :: ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `right`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn right(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("right")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for CompoundAssignmentExpr<'tree> {
    type WithLifetime<'a> = CompoundAssignmentExpr<'a>;
    const KIND: &'static str = "compound_assignment_expr";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "compound_assignment_expr" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "compound_assignment_expr");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `const_block`\n\nThis node has these fields:\n\n- `body`: `block` ([`Block`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstBlock<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstBlock<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ConstBlock<'tree> {
    type WithLifetime<'a> = ConstBlock<'a>;
    const KIND: &'static str = "const_block";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "const_block" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "const_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `const_item`\n\nThis node has these fields:\n\n- `name`: `identifier` ([`Identifier`])\n- `type`: `_type` ([`Type`])\n- `value`: `_expression?` ([`Expression`])\n\nAnd an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstItem<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `value`.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `visibility_modifier?` ([`VisibilityModifier`])"]
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, VisibilityModifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<VisibilityModifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ConstItem<'tree> {
    type WithLifetime<'a> = ConstItem<'a>;
    const KIND: &'static str = "const_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "const_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "const_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `const_parameter`\n\nThis node has these fields:\n\n- `name`: `identifier` ([`Identifier`])\n- `type`: `_type` ([`Type`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstParameter<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstParameter<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ConstParameter<'tree> {
    type WithLifetime<'a> = ConstParameter<'a>;
    const KIND: &'static str = "const_parameter";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "const_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "const_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `constrained_type_parameter`\n\nThis node has these fields:\n\n- `bounds`: `trait_bounds` ([`TraitBounds`])\n- `left`: `{lifetime | type_identifier}` ([`Lifetime`] | [`TypeIdentifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstrainedTypeParameter<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstrainedTypeParameter<'tree> {
    #[doc = "Get the field `bounds`.\n\nThis child has type `trait_bounds` ([`TraitBounds`])"]
    #[inline]
    pub fn bounds(&self) -> type_sitter::NodeResult<'tree, TraitBounds<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `left`.\n\nThis child has type `{lifetime | type_identifier}`:\n\n- [`Lifetime`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn left(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::Lifetime_TypeIdentifier<'tree>> {
        type_sitter :: Node :: raw (self) . child_by_field_name ("left") . map (< anon_unions :: Lifetime_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ConstrainedTypeParameter<'tree> {
    type WithLifetime<'a> = ConstrainedTypeParameter<'a>;
    const KIND: &'static str = "constrained_type_parameter";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "constrained_type_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "constrained_type_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `continue_expression`\n\nThis node has an optional named child of type `label?` ([`Label`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ContinueExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ContinueExpression<'tree> {
    #[doc = "Get the node's only not-extra named child, if it has one.\n\nThis child has type `label?` ([`Label`])"]
    #[inline]
    pub fn label(&self) -> Option<type_sitter::NodeResult<'tree, Label<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ContinueExpression<'tree> {
    type WithLifetime<'a> = ContinueExpression<'a>;
    const KIND: &'static str = "continue_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "continue_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "continue_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `crate`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Crate<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Crate<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Crate<'tree> {
    type WithLifetime<'a> = Crate<'a>;
    const KIND: &'static str = "crate";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "crate" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "crate");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `declaration_list`\n\nThis node has named children of type `_declaration_statement*` ([`DeclarationStatement`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DeclarationList<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DeclarationList<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `_declaration_statement*` ([`DeclarationStatement`])"]
    #[inline]
    pub fn declaration_statements<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, DeclarationStatement<'tree>>> + 'a
    {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<DeclarationStatement<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for DeclarationList<'tree> {
    type WithLifetime<'a> = DeclarationList<'a>;
    const KIND: &'static str = "declaration_list";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "declaration_list" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `doc_comment`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DocComment<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DocComment<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for DocComment<'tree> {
    type WithLifetime<'a> = DocComment<'a>;
    const KIND: &'static str = "doc_comment";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "doc_comment" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "doc_comment");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `dynamic_type`\n\nThis node has these fields:\n\n- `trait`: `{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}` ([`FunctionType`] | [`GenericType`] | [`HigherRankedTraitBound`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DynamicType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DynamicType<'tree> {
    #[doc = "Get the field `trait`.\n\nThis child has type `{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}`:\n\n- [`FunctionType`]\n- [`GenericType`]\n- [`HigherRankedTraitBound`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]\n"]
    #[inline]    pub fn r#trait (& self) -> type_sitter :: NodeResult < 'tree , anon_unions :: FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier < 'tree > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("trait") . map (< anon_unions :: FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for DynamicType<'tree> {
    type WithLifetime<'a> = DynamicType<'a>;
    const KIND: &'static str = "dynamic_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "dynamic_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "dynamic_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `else_clause`\n\nThis node has a named child of type `{block | if_expression}`:\n\n- [`Block`]\n- [`IfExpression`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ElseClause<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ElseClause<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `{block | if_expression}`:\n\n- [`Block`]\n- [`IfExpression`]\n"]
    #[inline]
    pub fn child(&self) -> type_sitter::NodeResult<'tree, anon_unions::Block_IfExpression<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<anon_unions::Block_IfExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ElseClause<'tree> {
    type WithLifetime<'a> = ElseClause<'a>;
    const KIND: &'static str = "else_clause";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "else_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "else_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `empty_statement`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EmptyStatement<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EmptyStatement<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for EmptyStatement<'tree> {
    type WithLifetime<'a> = EmptyStatement<'a>;
    const KIND: &'static str = "empty_statement";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "empty_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "empty_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `enum_item`\n\nThis node has these fields:\n\n- `body`: `enum_variant_list` ([`EnumVariantList`])\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd additional named children of type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumItem<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `enum_variant_list` ([`EnumVariantList`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, EnumVariantList<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<EnumVariantList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::VisibilityModifier_WhereClause<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: VisibilityModifier_WhereClause < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for EnumItem<'tree> {
    type WithLifetime<'a> = EnumItem<'a>;
    const KIND: &'static str = "enum_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "enum_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enum_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `enum_variant`\n\nThis node has these fields:\n\n- `body`: `{field_declaration_list | ordered_field_declaration_list}?` ([`FieldDeclarationList`] | [`OrderedFieldDeclarationList`])\n- `name`: `identifier` ([`Identifier`])\n- `value`: `_expression?` ([`Expression`])\n\nAnd an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumVariant<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumVariant<'tree> {
    #[doc = "Get the optional field `body`.\n\nThis child has type `{field_declaration_list | ordered_field_declaration_list}?`:\n\n- [`FieldDeclarationList`]\n- [`OrderedFieldDeclarationList`]\n"]
    #[inline]
    pub fn body(
        &self,
    ) -> Option<
        type_sitter::NodeResult<
            'tree,
            anon_unions::FieldDeclarationList_OrderedFieldDeclarationList<'tree>,
        >,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("body") . map (< anon_unions :: FieldDeclarationList_OrderedFieldDeclarationList < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
    #[doc = "Get the field `name`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `value`.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `visibility_modifier?` ([`VisibilityModifier`])"]
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, VisibilityModifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<VisibilityModifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for EnumVariant<'tree> {
    type WithLifetime<'a> = EnumVariant<'a>;
    const KIND: &'static str = "enum_variant";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "enum_variant" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enum_variant");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `enum_variant_list`\n\nThis node has named children of type `{attribute_item | enum_variant}*`:\n\n- [`AttributeItem`]\n- [`EnumVariant`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumVariantList<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumVariantList<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{attribute_item | enum_variant}*`:\n\n- [`AttributeItem`]\n- [`EnumVariant`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::AttributeItem_EnumVariant<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: AttributeItem_EnumVariant < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for EnumVariantList<'tree> {
    type WithLifetime<'a> = EnumVariantList<'a>;
    const KIND: &'static str = "enum_variant_list";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "enum_variant_list" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enum_variant_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `escape_sequence`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EscapeSequence<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EscapeSequence<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for EscapeSequence<'tree> {
    type WithLifetime<'a> = EscapeSequence<'a>;
    const KIND: &'static str = "escape_sequence";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "escape_sequence" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "escape_sequence");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `expression_statement`\n\nThis node has a named child of type `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExpressionStatement<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExpressionStatement<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ExpressionStatement<'tree> {
    type WithLifetime<'a> = ExpressionStatement<'a>;
    const KIND: &'static str = "expression_statement";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "expression_statement" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "expression_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `extern_crate_declaration`\n\nThis node has these fields:\n\n- `alias`: `identifier?` ([`Identifier`])\n- `name`: `identifier` ([`Identifier`])\n\nAnd additional named children of type `{crate | visibility_modifier}+`:\n\n- [`Crate`]\n- [`VisibilityModifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExternCrateDeclaration<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExternCrateDeclaration<'tree> {
    #[doc = "Get the optional field `alias`.\n\nThis child has type `identifier?` ([`Identifier`])"]
    #[inline]
    pub fn alias(&self) -> Option<type_sitter::NodeResult<'tree, Identifier<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("alias")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the field `name`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{crate | visibility_modifier}+`:\n\n- [`Crate`]\n- [`VisibilityModifier`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Crate_VisibilityModifier<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: Crate_VisibilityModifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ExternCrateDeclaration<'tree> {
    type WithLifetime<'a> = ExternCrateDeclaration<'a>;
    const KIND: &'static str = "extern_crate_declaration";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "extern_crate_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "extern_crate_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `extern_modifier`\n\nThis node has an optional named child of type `string_literal?` ([`StringLiteral`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExternModifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExternModifier<'tree> {
    #[doc = "Get the node's only not-extra named child, if it has one.\n\nThis child has type `string_literal?` ([`StringLiteral`])"]
    #[inline]
    pub fn string_literal(&self) -> Option<type_sitter::NodeResult<'tree, StringLiteral<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<StringLiteral<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ExternModifier<'tree> {
    type WithLifetime<'a> = ExternModifier<'a>;
    const KIND: &'static str = "extern_modifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "extern_modifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "extern_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `field_declaration`\n\nThis node has these fields:\n\n- `name`: `field_identifier` ([`FieldIdentifier`])\n- `type`: `_type` ([`Type`])\n\nAnd an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldDeclaration<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDeclaration<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `field_identifier` ([`FieldIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, FieldIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<FieldIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `visibility_modifier?` ([`VisibilityModifier`])"]
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, VisibilityModifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<VisibilityModifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FieldDeclaration<'tree> {
    type WithLifetime<'a> = FieldDeclaration<'a>;
    const KIND: &'static str = "field_declaration";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "field_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `field_declaration_list`\n\nThis node has named children of type `{attribute_item | field_declaration}*`:\n\n- [`AttributeItem`]\n- [`FieldDeclaration`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldDeclarationList<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDeclarationList<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{attribute_item | field_declaration}*`:\n\n- [`AttributeItem`]\n- [`FieldDeclaration`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::AttributeItem_FieldDeclaration<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: AttributeItem_FieldDeclaration < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FieldDeclarationList<'tree> {
    type WithLifetime<'a> = FieldDeclarationList<'a>;
    const KIND: &'static str = "field_declaration_list";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "field_declaration_list" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `field_expression`\n\nThis node has these fields:\n\n- `field`: `{field_identifier | integer_literal}` ([`FieldIdentifier`] | [`IntegerLiteral`])\n- `value`: `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldExpression<'tree> {
    #[doc = "Get the field `field`.\n\nThis child has type `{field_identifier | integer_literal}`:\n\n- [`FieldIdentifier`]\n- [`IntegerLiteral`]\n"]
    #[inline]
    pub fn field(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::FieldIdentifier_IntegerLiteral<'tree>> {
        type_sitter :: Node :: raw (self) . child_by_field_name ("field") . map (< anon_unions :: FieldIdentifier_IntegerLiteral < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FieldExpression<'tree> {
    type WithLifetime<'a> = FieldExpression<'a>;
    const KIND: &'static str = "field_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "field_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `field_identifier`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldIdentifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FieldIdentifier<'tree> {
    type WithLifetime<'a> = FieldIdentifier<'a>;
    const KIND: &'static str = "field_identifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "field_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `field_initializer`\n\nThis node has these fields:\n\n- `field`: `{field_identifier | integer_literal}` ([`FieldIdentifier`] | [`IntegerLiteral`])\n- `value`: `_expression` ([`Expression`])\n\nAnd additional named children of type `attribute_item*` ([`AttributeItem`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldInitializer<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldInitializer<'tree> {
    #[doc = "Get the field `field`.\n\nThis child has type `{field_identifier | integer_literal}`:\n\n- [`FieldIdentifier`]\n- [`IntegerLiteral`]\n"]
    #[inline]
    pub fn field(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::FieldIdentifier_IntegerLiteral<'tree>> {
        type_sitter :: Node :: raw (self) . child_by_field_name ("field") . map (< anon_unions :: FieldIdentifier_IntegerLiteral < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `attribute_item*` ([`AttributeItem`])"]
    #[inline]
    pub fn attribute_items<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, AttributeItem<'tree>>> + 'a {
        {
            let me = *type_sitter::Node::raw(self);
            type_sitter::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
        .map(<AttributeItem<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FieldInitializer<'tree> {
    type WithLifetime<'a> = FieldInitializer<'a>;
    const KIND: &'static str = "field_initializer";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "field_initializer" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_initializer");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `field_initializer_list`\n\nThis node has named children of type `{base_field_initializer | field_initializer | shorthand_field_initializer}*`:\n\n- [`BaseFieldInitializer`]\n- [`FieldInitializer`]\n- [`ShorthandFieldInitializer`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldInitializerList<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldInitializerList<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{base_field_initializer | field_initializer | shorthand_field_initializer}*`:\n\n- [`BaseFieldInitializer`]\n- [`FieldInitializer`]\n- [`ShorthandFieldInitializer`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'tree>,
        >,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FieldInitializerList<'tree> {
    type WithLifetime<'a> = FieldInitializerList<'a>;
    const KIND: &'static str = "field_initializer_list";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "field_initializer_list" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_initializer_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `field_pattern`\n\nThis node has these fields:\n\n- `name`: `{field_identifier | shorthand_field_identifier}` ([`FieldIdentifier`] | [`ShorthandFieldIdentifier`])\n- `pattern`: `_pattern?` ([`Pattern`])\n\nAnd an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldPattern<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `{field_identifier | shorthand_field_identifier}`:\n\n- [`FieldIdentifier`]\n- [`ShorthandFieldIdentifier`]\n"]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::FieldIdentifier_ShorthandFieldIdentifier<'tree>>
    {
        type_sitter :: Node :: raw (self) . child_by_field_name ("name") . map (< anon_unions :: FieldIdentifier_ShorthandFieldIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the optional field `pattern`.\n\nThis child has type `_pattern?` ([`Pattern`])"]
    #[inline]
    pub fn pattern(&self) -> Option<type_sitter::NodeResult<'tree, Pattern<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `mutable_specifier?` ([`MutableSpecifier`])"]
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, MutableSpecifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<MutableSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FieldPattern<'tree> {
    type WithLifetime<'a> = FieldPattern<'a>;
    const KIND: &'static str = "field_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "field_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `float_literal`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FloatLiteral<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FloatLiteral<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FloatLiteral<'tree> {
    type WithLifetime<'a> = FloatLiteral<'a>;
    const KIND: &'static str = "float_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "float_literal" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "float_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `for_expression`\n\nThis node has these fields:\n\n- `body`: `block` ([`Block`])\n- `pattern`: `_pattern` ([`Pattern`])\n- `value`: `_expression` ([`Expression`])\n\nAnd an optional additional named child of type `label?` ([`Label`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ForExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ForExpression<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `pattern`.\n\nThis child has type `_pattern` ([`Pattern`])"]
    #[inline]
    pub fn pattern(&self) -> type_sitter::NodeResult<'tree, Pattern<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `label?` ([`Label`])"]
    #[inline]
    pub fn label(&self) -> Option<type_sitter::NodeResult<'tree, Label<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ForExpression<'tree> {
    type WithLifetime<'a> = ForExpression<'a>;
    const KIND: &'static str = "for_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "for_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "for_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `for_lifetimes`\n\nThis node has named children of type `lifetime+` ([`Lifetime`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ForLifetimes<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ForLifetimes<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `lifetime+` ([`Lifetime`])"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn lifetimes<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Lifetime<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Lifetime<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ForLifetimes<'tree> {
    type WithLifetime<'a> = ForLifetimes<'a>;
    const KIND: &'static str = "for_lifetimes";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "for_lifetimes" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "for_lifetimes");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `foreign_mod_item`\n\nThis node has these fields:\n\n- `body`: `declaration_list?` ([`DeclarationList`])\n\nAnd additional named children of type `{extern_modifier | visibility_modifier}+`:\n\n- [`ExternModifier`]\n- [`VisibilityModifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ForeignModItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ForeignModItem<'tree> {
    #[doc = "Get the optional field `body`.\n\nThis child has type `declaration_list?` ([`DeclarationList`])"]
    #[inline]
    pub fn body(&self) -> Option<type_sitter::NodeResult<'tree, DeclarationList<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<DeclarationList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{extern_modifier | visibility_modifier}+`:\n\n- [`ExternModifier`]\n- [`VisibilityModifier`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::ExternModifier_VisibilityModifier<'tree>,
        >,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: ExternModifier_VisibilityModifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ForeignModItem<'tree> {
    type WithLifetime<'a> = ForeignModItem<'a>;
    const KIND: &'static str = "foreign_mod_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "foreign_mod_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "foreign_mod_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `fragment_specifier`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FragmentSpecifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FragmentSpecifier<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FragmentSpecifier<'tree> {
    type WithLifetime<'a> = FragmentSpecifier<'a>;
    const KIND: &'static str = "fragment_specifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "fragment_specifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "fragment_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `function_item`\n\nThis node has these fields:\n\n- `body`: `block` ([`Block`])\n- `name`: `{identifier | metavariable}` ([`Identifier`] | [`Metavariable`])\n- `parameters`: `parameters` ([`Parameters`])\n- `return_type`: `_type?` ([`Type`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd additional named children of type `{function_modifiers | visibility_modifier | where_clause}*`:\n\n- [`FunctionModifiers`]\n- [`VisibilityModifier`]\n- [`WhereClause`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionItem<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `name`.\n\nThis child has type `{identifier | metavariable}`:\n\n- [`Identifier`]\n- [`Metavariable`]\n"]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::Identifier_Metavariable<'tree>> {
        type_sitter :: Node :: raw (self) . child_by_field_name ("name") . map (< anon_unions :: Identifier_Metavariable < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `parameters`.\n\nThis child has type `parameters` ([`Parameters`])"]
    #[inline]
    pub fn parameters(&self) -> type_sitter::NodeResult<'tree, Parameters<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<Parameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `return_type`.\n\nThis child has type `_type?` ([`Type`])"]
    #[inline]
    pub fn return_type(&self) -> Option<type_sitter::NodeResult<'tree, Type<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{function_modifiers | visibility_modifier | where_clause}*`:\n\n- [`FunctionModifiers`]\n- [`VisibilityModifier`]\n- [`WhereClause`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::FunctionModifiers_VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: FunctionModifiers_VisibilityModifier_WhereClause < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FunctionItem<'tree> {
    type WithLifetime<'a> = FunctionItem<'a>;
    const KIND: &'static str = "function_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "function_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `function_modifiers`\n\nThis node has named children of type `extern_modifier*` ([`ExternModifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionModifiers<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionModifiers<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `extern_modifier*` ([`ExternModifier`])"]
    #[inline]
    pub fn extern_modifiers<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, ExternModifier<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<ExternModifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FunctionModifiers<'tree> {
    type WithLifetime<'a> = FunctionModifiers<'a>;
    const KIND: &'static str = "function_modifiers";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "function_modifiers" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_modifiers");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `function_signature_item`\n\nThis node has these fields:\n\n- `name`: `{identifier | metavariable}` ([`Identifier`] | [`Metavariable`])\n- `parameters`: `parameters` ([`Parameters`])\n- `return_type`: `_type?` ([`Type`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd additional named children of type `{function_modifiers | visibility_modifier | where_clause}*`:\n\n- [`FunctionModifiers`]\n- [`VisibilityModifier`]\n- [`WhereClause`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionSignatureItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionSignatureItem<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `{identifier | metavariable}`:\n\n- [`Identifier`]\n- [`Metavariable`]\n"]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::Identifier_Metavariable<'tree>> {
        type_sitter :: Node :: raw (self) . child_by_field_name ("name") . map (< anon_unions :: Identifier_Metavariable < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `parameters`.\n\nThis child has type `parameters` ([`Parameters`])"]
    #[inline]
    pub fn parameters(&self) -> type_sitter::NodeResult<'tree, Parameters<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<Parameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `return_type`.\n\nThis child has type `_type?` ([`Type`])"]
    #[inline]
    pub fn return_type(&self) -> Option<type_sitter::NodeResult<'tree, Type<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{function_modifiers | visibility_modifier | where_clause}*`:\n\n- [`FunctionModifiers`]\n- [`VisibilityModifier`]\n- [`WhereClause`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::FunctionModifiers_VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: FunctionModifiers_VisibilityModifier_WhereClause < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FunctionSignatureItem<'tree> {
    type WithLifetime<'a> = FunctionSignatureItem<'a>;
    const KIND: &'static str = "function_signature_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "function_signature_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_signature_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `function_type`\n\nThis node has these fields:\n\n- `parameters`: `parameters` ([`Parameters`])\n- `return_type`: `_type?` ([`Type`])\n- `trait`: `{scoped_type_identifier | type_identifier}?` ([`ScopedTypeIdentifier`] | [`TypeIdentifier`])\n\nAnd additional named children of type `{for_lifetimes | function_modifiers}*`:\n\n- [`ForLifetimes`]\n- [`FunctionModifiers`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionType<'tree> {
    #[doc = "Get the field `parameters`.\n\nThis child has type `parameters` ([`Parameters`])"]
    #[inline]
    pub fn parameters(&self) -> type_sitter::NodeResult<'tree, Parameters<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<Parameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `return_type`.\n\nThis child has type `_type?` ([`Type`])"]
    #[inline]
    pub fn return_type(&self) -> Option<type_sitter::NodeResult<'tree, Type<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `trait`.\n\nThis child has type `{scoped_type_identifier | type_identifier}?`:\n\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn r#trait(
        &self,
    ) -> Option<
        type_sitter::NodeResult<'tree, anon_unions::ScopedTypeIdentifier_TypeIdentifier<'tree>>,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("trait") . map (< anon_unions :: ScopedTypeIdentifier_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{for_lifetimes | function_modifiers}*`:\n\n- [`ForLifetimes`]\n- [`FunctionModifiers`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::ForLifetimes_FunctionModifiers<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: ForLifetimes_FunctionModifiers < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for FunctionType<'tree> {
    type WithLifetime<'a> = FunctionType<'a>;
    const KIND: &'static str = "function_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "function_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `generic_function`\n\nThis node has these fields:\n\n- `function`: `{field_expression | identifier | scoped_identifier}` ([`FieldExpression`] | [`Identifier`] | [`ScopedIdentifier`])\n- `type_arguments`: `type_arguments` ([`TypeArguments`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenericFunction<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenericFunction<'tree> {
    #[doc = "Get the field `function`.\n\nThis child has type `{field_expression | identifier | scoped_identifier}`:\n\n- [`FieldExpression`]\n- [`Identifier`]\n- [`ScopedIdentifier`]\n"]
    #[inline]
    pub fn function(
        &self,
    ) -> type_sitter::NodeResult<
        'tree,
        anon_unions::FieldExpression_Identifier_ScopedIdentifier<'tree>,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("function") . map (< anon_unions :: FieldExpression_Identifier_ScopedIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments`.\n\nThis child has type `type_arguments` ([`TypeArguments`])"]
    #[inline]
    pub fn type_arguments(&self) -> type_sitter::NodeResult<'tree, TypeArguments<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for GenericFunction<'tree> {
    type WithLifetime<'a> = GenericFunction<'a>;
    const KIND: &'static str = "generic_function";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "generic_function" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "generic_function");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `generic_type`\n\nThis node has these fields:\n\n- `type`: `{identifier | scoped_identifier | scoped_type_identifier | type_identifier}` ([`Identifier`] | [`ScopedIdentifier`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])\n- `type_arguments`: `type_arguments` ([`TypeArguments`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenericType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenericType<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `{identifier | scoped_identifier | scoped_type_identifier | type_identifier}`:\n\n- [`Identifier`]\n- [`ScopedIdentifier`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter::NodeResult<
        'tree,
        anon_unions::Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'tree>,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("type") . map (< anon_unions :: Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments`.\n\nThis child has type `type_arguments` ([`TypeArguments`])"]
    #[inline]
    pub fn type_arguments(&self) -> type_sitter::NodeResult<'tree, TypeArguments<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for GenericType<'tree> {
    type WithLifetime<'a> = GenericType<'a>;
    const KIND: &'static str = "generic_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "generic_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "generic_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `generic_type_with_turbofish`\n\nThis node has these fields:\n\n- `type`: `{scoped_identifier | type_identifier}` ([`ScopedIdentifier`] | [`TypeIdentifier`])\n- `type_arguments`: `type_arguments` ([`TypeArguments`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenericTypeWithTurbofish<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenericTypeWithTurbofish<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `{scoped_identifier | type_identifier}`:\n\n- [`ScopedIdentifier`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::ScopedIdentifier_TypeIdentifier<'tree>> {
        type_sitter :: Node :: raw (self) . child_by_field_name ("type") . map (< anon_unions :: ScopedIdentifier_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the field `type_arguments`.\n\nThis child has type `type_arguments` ([`TypeArguments`])"]
    #[inline]
    pub fn type_arguments(&self) -> type_sitter::NodeResult<'tree, TypeArguments<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for GenericTypeWithTurbofish<'tree> {
    type WithLifetime<'a> = GenericTypeWithTurbofish<'a>;
    const KIND: &'static str = "generic_type_with_turbofish";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "generic_type_with_turbofish" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "generic_type_with_turbofish");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `higher_ranked_trait_bound`\n\nThis node has these fields:\n\n- `type`: `_type` ([`Type`])\n- `type_parameters`: `type_parameters` ([`TypeParameters`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct HigherRankedTraitBound<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> HigherRankedTraitBound<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type_parameters`.\n\nThis child has type `type_parameters` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> type_sitter::NodeResult<'tree, TypeParameters<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for HigherRankedTraitBound<'tree> {
    type WithLifetime<'a> = HigherRankedTraitBound<'a>;
    const KIND: &'static str = "higher_ranked_trait_bound";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "higher_ranked_trait_bound" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "higher_ranked_trait_bound");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `identifier`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Identifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Identifier<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Identifier<'tree> {
    type WithLifetime<'a> = Identifier<'a>;
    const KIND: &'static str = "identifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `if_expression`\n\nThis node has these fields:\n\n- `alternative`: `else_clause?` ([`ElseClause`])\n- `condition`: `{_expression | let_chain | let_condition}` ([`Expression`] | [`LetChain`] | [`LetCondition`])\n- `consequence`: `block` ([`Block`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct IfExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> IfExpression<'tree> {
    #[doc = "Get the optional field `alternative`.\n\nThis child has type `else_clause?` ([`ElseClause`])"]
    #[inline]
    pub fn alternative(&self) -> Option<type_sitter::NodeResult<'tree, ElseClause<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("alternative")
            .map(<ElseClause<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the field `condition`.\n\nThis child has type `{_expression | let_chain | let_condition}`:\n\n- [`Expression`]\n- [`LetChain`]\n- [`LetCondition`]\n"]
    #[inline]
    pub fn condition(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::Expression_LetChain_LetCondition<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::Expression_LetChain_LetCondition<'tree> as type_sitter::Node<
                    'tree,
                >>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `consequence`.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn consequence(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("consequence")
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for IfExpression<'tree> {
    type WithLifetime<'a> = IfExpression<'a>;
    const KIND: &'static str = "if_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "if_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "if_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `impl_item`\n\nThis node has these fields:\n\n- `body`: `declaration_list?` ([`DeclarationList`])\n- `trait`: `{generic_type | scoped_type_identifier | type_identifier}?` ([`GenericType`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])\n- `type`: `_type` ([`Type`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd an optional additional named child of type `where_clause?` ([`WhereClause`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ImplItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ImplItem<'tree> {
    #[doc = "Get the optional field `body`.\n\nThis child has type `declaration_list?` ([`DeclarationList`])"]
    #[inline]
    pub fn body(&self) -> Option<type_sitter::NodeResult<'tree, DeclarationList<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<DeclarationList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `trait`.\n\nThis child has type `{generic_type | scoped_type_identifier | type_identifier}?`:\n\n- [`GenericType`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn r#trait(
        &self,
    ) -> Option<
        type_sitter::NodeResult<
            'tree,
            anon_unions::GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree>,
        >,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("trait") . map (< anon_unions :: GenericType_ScopedTypeIdentifier_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `where_clause?` ([`WhereClause`])"]
    #[inline]
    pub fn where_clause(&self) -> Option<type_sitter::NodeResult<'tree, WhereClause<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<WhereClause<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ImplItem<'tree> {
    type WithLifetime<'a> = ImplItem<'a>;
    const KIND: &'static str = "impl_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "impl_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "impl_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `index_expression`\n\nThis node has named children of type `_expression+` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct IndexExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> IndexExpression<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `_expression+` ([`Expression`])"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn expressions<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Expression<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for IndexExpression<'tree> {
    type WithLifetime<'a> = IndexExpression<'a>;
    const KIND: &'static str = "index_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "index_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "index_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `inner_attribute_item`\n\nThis node has a named child of type `attribute` ([`Attribute`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct InnerAttributeItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> InnerAttributeItem<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `attribute` ([`Attribute`])"]
    #[inline]
    pub fn attribute(&self) -> type_sitter::NodeResult<'tree, Attribute<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Attribute<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for InnerAttributeItem<'tree> {
    type WithLifetime<'a> = InnerAttributeItem<'a>;
    const KIND: &'static str = "inner_attribute_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "inner_attribute_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "inner_attribute_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `inner_doc_comment_marker`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct InnerDocCommentMarker<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> InnerDocCommentMarker<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for InnerDocCommentMarker<'tree> {
    type WithLifetime<'a> = InnerDocCommentMarker<'a>;
    const KIND: &'static str = "inner_doc_comment_marker";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "inner_doc_comment_marker" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "inner_doc_comment_marker");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `integer_literal`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct IntegerLiteral<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> IntegerLiteral<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for IntegerLiteral<'tree> {
    type WithLifetime<'a> = IntegerLiteral<'a>;
    const KIND: &'static str = "integer_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "integer_literal" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "integer_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `label`\n\nThis node has a named child of type `identifier` ([`Identifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Label<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Label<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn identifier(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Label<'tree> {
    type WithLifetime<'a> = Label<'a>;
    const KIND: &'static str = "label";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "label" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "label");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `let_chain`\n\nThis node has named children of type `{_expression | let_condition}+`:\n\n- [`Expression`]\n- [`LetCondition`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LetChain<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LetChain<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_expression | let_condition}+`:\n\n- [`Expression`]\n- [`LetCondition`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Expression_LetCondition<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Expression_LetCondition < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for LetChain<'tree> {
    type WithLifetime<'a> = LetChain<'a>;
    const KIND: &'static str = "let_chain";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "let_chain" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "let_chain");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `let_condition`\n\nThis node has these fields:\n\n- `pattern`: `_pattern` ([`Pattern`])\n- `value`: `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LetCondition<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LetCondition<'tree> {
    #[doc = "Get the field `pattern`.\n\nThis child has type `_pattern` ([`Pattern`])"]
    #[inline]
    pub fn pattern(&self) -> type_sitter::NodeResult<'tree, Pattern<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for LetCondition<'tree> {
    type WithLifetime<'a> = LetCondition<'a>;
    const KIND: &'static str = "let_condition";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "let_condition" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "let_condition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `let_declaration`\n\nThis node has these fields:\n\n- `alternative`: `block?` ([`Block`])\n- `pattern`: `_pattern` ([`Pattern`])\n- `type`: `_type?` ([`Type`])\n- `value`: `_expression?` ([`Expression`])\n\nAnd an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LetDeclaration<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LetDeclaration<'tree> {
    #[doc = "Get the optional field `alternative`.\n\nThis child has type `block?` ([`Block`])"]
    #[inline]
    pub fn alternative(&self) -> Option<type_sitter::NodeResult<'tree, Block<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("alternative")
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the field `pattern`.\n\nThis child has type `_pattern` ([`Pattern`])"]
    #[inline]
    pub fn pattern(&self) -> type_sitter::NodeResult<'tree, Pattern<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type`.\n\nThis child has type `_type?` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> Option<type_sitter::NodeResult<'tree, Type<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `value`.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `mutable_specifier?` ([`MutableSpecifier`])"]
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, MutableSpecifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<MutableSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for LetDeclaration<'tree> {
    type WithLifetime<'a> = LetDeclaration<'a>;
    const KIND: &'static str = "let_declaration";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "let_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "let_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `lifetime`\n\nThis node has a named child of type `identifier` ([`Identifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Lifetime<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Lifetime<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn identifier(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Lifetime<'tree> {
    type WithLifetime<'a> = Lifetime<'a>;
    const KIND: &'static str = "lifetime";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "lifetime" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "lifetime");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `line_comment`\n\nThis node has these fields:\n\n- `doc`: `doc_comment?` ([`DocComment`])\n- `inner`: `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])\n- `outer`: `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LineComment<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LineComment<'tree> {
    #[doc = "Get the optional field `doc`.\n\nThis child has type `doc_comment?` ([`DocComment`])"]
    #[inline]
    pub fn doc(&self) -> Option<type_sitter::NodeResult<'tree, DocComment<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("doc")
            .map(<DocComment<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `inner`.\n\nThis child has type `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])"]
    #[inline]
    pub fn inner(&self) -> Option<type_sitter::NodeResult<'tree, InnerDocCommentMarker<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("inner")
            .map(<InnerDocCommentMarker<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the optional field `outer`.\n\nThis child has type `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])"]
    #[inline]
    pub fn outer(&self) -> Option<type_sitter::NodeResult<'tree, OuterDocCommentMarker<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("outer")
            .map(<OuterDocCommentMarker<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for LineComment<'tree> {
    type WithLifetime<'a> = LineComment<'a>;
    const KIND: &'static str = "line_comment";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "line_comment" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "line_comment");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `loop_expression`\n\nThis node has these fields:\n\n- `body`: `block` ([`Block`])\n\nAnd an optional additional named child of type `label?` ([`Label`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LoopExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LoopExpression<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `label?` ([`Label`])"]
    #[inline]
    pub fn label(&self) -> Option<type_sitter::NodeResult<'tree, Label<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for LoopExpression<'tree> {
    type WithLifetime<'a> = LoopExpression<'a>;
    const KIND: &'static str = "loop_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "loop_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "loop_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `macro_definition`\n\nThis node has these fields:\n\n- `name`: `identifier` ([`Identifier`])\n\nAnd additional named children of type `macro_rule*` ([`MacroRule`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MacroDefinition<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MacroDefinition<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `macro_rule*` ([`MacroRule`])"]
    #[inline]
    pub fn macro_rules<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, MacroRule<'tree>>> + 'a {
        {
            let me = *type_sitter::Node::raw(self);
            type_sitter::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
        .map(<MacroRule<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MacroDefinition<'tree> {
    type WithLifetime<'a> = MacroDefinition<'a>;
    const KIND: &'static str = "macro_definition";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "macro_definition" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "macro_definition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `macro_invocation`\n\nThis node has these fields:\n\n- `macro`: `{identifier | scoped_identifier}` ([`Identifier`] | [`ScopedIdentifier`])\n\nAnd an additional named child of type `token_tree` ([`TokenTree`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MacroInvocation<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MacroInvocation<'tree> {
    #[doc = "Get the field `macro`.\n\nThis child has type `{identifier | scoped_identifier}`:\n\n- [`Identifier`]\n- [`ScopedIdentifier`]\n"]
    #[inline]
    pub fn r#macro(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::Identifier_ScopedIdentifier<'tree>> {
        type_sitter :: Node :: raw (self) . child_by_field_name ("macro") . map (< anon_unions :: Identifier_ScopedIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's only non-field not-extra named child.\n\nThis child has type `token_tree` ([`TokenTree`])"]
    #[inline]
    pub fn token_tree(&self) -> type_sitter::NodeResult<'tree, TokenTree<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<TokenTree<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MacroInvocation<'tree> {
    type WithLifetime<'a> = MacroInvocation<'a>;
    const KIND: &'static str = "macro_invocation";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "macro_invocation" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "macro_invocation");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `macro_rule`\n\nThis node has these fields:\n\n- `left`: `token_tree_pattern` ([`TokenTreePattern`])\n- `right`: `token_tree` ([`TokenTree`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MacroRule<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MacroRule<'tree> {
    #[doc = "Get the field `left`.\n\nThis child has type `token_tree_pattern` ([`TokenTreePattern`])"]
    #[inline]
    pub fn left(&self) -> type_sitter::NodeResult<'tree, TokenTreePattern<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("left")
            .map(<TokenTreePattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `right`.\n\nThis child has type `token_tree` ([`TokenTree`])"]
    #[inline]
    pub fn right(&self) -> type_sitter::NodeResult<'tree, TokenTree<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("right")
            .map(<TokenTree<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MacroRule<'tree> {
    type WithLifetime<'a> = MacroRule<'a>;
    const KIND: &'static str = "macro_rule";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "macro_rule" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "macro_rule");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `match_arm`\n\nThis node has these fields:\n\n- `pattern`: `match_pattern` ([`MatchPattern`])\n- `value`: `_expression` ([`Expression`])\n\nAnd additional named children of type `{attribute_item | inner_attribute_item}*`:\n\n- [`AttributeItem`]\n- [`InnerAttributeItem`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchArm<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchArm<'tree> {
    #[doc = "Get the field `pattern`.\n\nThis child has type `match_pattern` ([`MatchPattern`])"]
    #[inline]
    pub fn pattern(&self) -> type_sitter::NodeResult<'tree, MatchPattern<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<MatchPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{attribute_item | inner_attribute_item}*`:\n\n- [`AttributeItem`]\n- [`InnerAttributeItem`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::AttributeItem_InnerAttributeItem<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: AttributeItem_InnerAttributeItem < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MatchArm<'tree> {
    type WithLifetime<'a> = MatchArm<'a>;
    const KIND: &'static str = "match_arm";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "match_arm" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_arm");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `match_block`\n\nThis node has named children of type `match_arm*` ([`MatchArm`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchBlock<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchBlock<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `match_arm*` ([`MatchArm`])"]
    #[inline]
    pub fn match_arms<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, MatchArm<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<MatchArm<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MatchBlock<'tree> {
    type WithLifetime<'a> = MatchBlock<'a>;
    const KIND: &'static str = "match_block";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "match_block" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `match_expression`\n\nThis node has these fields:\n\n- `body`: `match_block` ([`MatchBlock`])\n- `value`: `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchExpression<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `match_block` ([`MatchBlock`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, MatchBlock<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<MatchBlock<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MatchExpression<'tree> {
    type WithLifetime<'a> = MatchExpression<'a>;
    const KIND: &'static str = "match_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "match_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `match_pattern`\n\nThis node has these fields:\n\n- `condition`: `{_expression | let_chain | let_condition}?` ([`Expression`] | [`LetChain`] | [`LetCondition`])\n\nAnd an additional named child of type `_pattern` ([`Pattern`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchPattern<'tree> {
    #[doc = "Get the optional field `condition`.\n\nThis child has type `{_expression | let_chain | let_condition}?`:\n\n- [`Expression`]\n- [`LetChain`]\n- [`LetCondition`]\n"]
    #[inline]
    pub fn condition(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, anon_unions::Expression_LetChain_LetCondition<'tree>>>
    {
        type_sitter::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::Expression_LetChain_LetCondition<'tree> as type_sitter::Node<
                    'tree,
                >>::try_from_raw,
            )
    }
    #[doc = "Get the node's only non-field not-extra named child.\n\nThis child has type `_pattern` ([`Pattern`])"]
    #[inline]
    pub fn pattern(&self) -> type_sitter::NodeResult<'tree, Pattern<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MatchPattern<'tree> {
    type WithLifetime<'a> = MatchPattern<'a>;
    const KIND: &'static str = "match_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "match_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `metavariable`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Metavariable<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Metavariable<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Metavariable<'tree> {
    type WithLifetime<'a> = Metavariable<'a>;
    const KIND: &'static str = "metavariable";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "metavariable" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "metavariable");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `mod_item`\n\nThis node has these fields:\n\n- `body`: `declaration_list?` ([`DeclarationList`])\n- `name`: `identifier` ([`Identifier`])\n\nAnd an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ModItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ModItem<'tree> {
    #[doc = "Get the optional field `body`.\n\nThis child has type `declaration_list?` ([`DeclarationList`])"]
    #[inline]
    pub fn body(&self) -> Option<type_sitter::NodeResult<'tree, DeclarationList<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<DeclarationList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the field `name`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `visibility_modifier?` ([`VisibilityModifier`])"]
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, VisibilityModifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<VisibilityModifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ModItem<'tree> {
    type WithLifetime<'a> = ModItem<'a>;
    const KIND: &'static str = "mod_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "mod_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "mod_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `mut_pattern`\n\nThis node has named children of type `{_pattern | mutable_specifier}+`:\n\n- [`Pattern`]\n- [`MutableSpecifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MutPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MutPattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_pattern | mutable_specifier}+`:\n\n- [`Pattern`]\n- [`MutableSpecifier`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Pattern_MutableSpecifier<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Pattern_MutableSpecifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MutPattern<'tree> {
    type WithLifetime<'a> = MutPattern<'a>;
    const KIND: &'static str = "mut_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "mut_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "mut_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `mutable_specifier`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MutableSpecifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MutableSpecifier<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for MutableSpecifier<'tree> {
    type WithLifetime<'a> = MutableSpecifier<'a>;
    const KIND: &'static str = "mutable_specifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "mutable_specifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "mutable_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `negative_literal`\n\nThis node has a named child of type `{float_literal | integer_literal}`:\n\n- [`FloatLiteral`]\n- [`IntegerLiteral`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct NegativeLiteral<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> NegativeLiteral<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `{float_literal | integer_literal}`:\n\n- [`FloatLiteral`]\n- [`IntegerLiteral`]\n"]
    #[inline]
    pub fn child(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::FloatLiteral_IntegerLiteral<'tree>> {
        (0 .. type_sitter :: Node :: raw (self) . named_child_count ()) . map (| i | type_sitter :: Node :: raw (self) . named_child (i) . unwrap ()) . filter (| n | ! n . is_extra ()) . next () . map (< anon_unions :: FloatLiteral_IntegerLiteral < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for NegativeLiteral<'tree> {
    type WithLifetime<'a> = NegativeLiteral<'a>;
    const KIND: &'static str = "negative_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "negative_literal" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "negative_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `never_type`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct NeverType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> NeverType<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for NeverType<'tree> {
    type WithLifetime<'a> = NeverType<'a>;
    const KIND: &'static str = "never_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "never_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "never_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `optional_type_parameter`\n\nThis node has these fields:\n\n- `default_type`: `_type` ([`Type`])\n- `name`: `{constrained_type_parameter | type_identifier}` ([`ConstrainedTypeParameter`] | [`TypeIdentifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OptionalTypeParameter<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OptionalTypeParameter<'tree> {
    #[doc = "Get the field `default_type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn default_type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("default_type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `name`.\n\nThis child has type `{constrained_type_parameter | type_identifier}`:\n\n- [`ConstrainedTypeParameter`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::ConstrainedTypeParameter_TypeIdentifier<'tree>>
    {
        type_sitter :: Node :: raw (self) . child_by_field_name ("name") . map (< anon_unions :: ConstrainedTypeParameter_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for OptionalTypeParameter<'tree> {
    type WithLifetime<'a> = OptionalTypeParameter<'a>;
    const KIND: &'static str = "optional_type_parameter";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "optional_type_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "optional_type_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `or_pattern`\n\nThis node has named children of type `_pattern+` ([`Pattern`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OrPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OrPattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `_pattern+` ([`Pattern`])"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Pattern<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for OrPattern<'tree> {
    type WithLifetime<'a> = OrPattern<'a>;
    const KIND: &'static str = "or_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "or_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "or_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `ordered_field_declaration_list`\n\nThis node has these fields:\n\n- `type`: `_type*` ([`Type`])\n\nAnd additional named children of type `{attribute_item | visibility_modifier}*`:\n\n- [`AttributeItem`]\n- [`VisibilityModifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OrderedFieldDeclarationList<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OrderedFieldDeclarationList<'tree> {
    #[doc = "Get the children of field `type`.\n\nThese children have type `_type*` ([`Type`])"]
    #[inline]
    pub fn types<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Type<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .children_by_field_name("type", &mut c.0)
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{attribute_item | visibility_modifier}*`:\n\n- [`AttributeItem`]\n- [`VisibilityModifier`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::AttributeItem_VisibilityModifier<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: AttributeItem_VisibilityModifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for OrderedFieldDeclarationList<'tree> {
    type WithLifetime<'a> = OrderedFieldDeclarationList<'a>;
    const KIND: &'static str = "ordered_field_declaration_list";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "ordered_field_declaration_list" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ordered_field_declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `outer_doc_comment_marker`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OuterDocCommentMarker<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OuterDocCommentMarker<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for OuterDocCommentMarker<'tree> {
    type WithLifetime<'a> = OuterDocCommentMarker<'a>;
    const KIND: &'static str = "outer_doc_comment_marker";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "outer_doc_comment_marker" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "outer_doc_comment_marker");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `parameter`\n\nThis node has these fields:\n\n- `pattern`: `{_pattern | self}` ([`Pattern`] | [`Self_`])\n- `type`: `_type` ([`Type`])\n\nAnd an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Parameter<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Parameter<'tree> {
    #[doc = "Get the field `pattern`.\n\nThis child has type `{_pattern | self}`:\n\n- [`Pattern`]\n- [`Self_`]\n"]
    #[inline]
    pub fn pattern(&self) -> type_sitter::NodeResult<'tree, anon_unions::Pattern_Self_<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<anon_unions::Pattern_Self_<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `mutable_specifier?` ([`MutableSpecifier`])"]
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, MutableSpecifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<MutableSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Parameter<'tree> {
    type WithLifetime<'a> = Parameter<'a>;
    const KIND: &'static str = "parameter";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `parameters`\n\nThis node has named children of type `{_type | attribute_item | parameter | self_parameter | variadic_parameter}*`:\n\n- [`Type`]\n- [`AttributeItem`]\n- [`Parameter`]\n- [`SelfParameter`]\n- [`VariadicParameter`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Parameters<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Parameters<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_type | attribute_item | parameter | self_parameter | variadic_parameter}*`:\n\n- [`Type`]\n- [`AttributeItem`]\n- [`Parameter`]\n- [`SelfParameter`]\n- [`VariadicParameter`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'tree>,
        >,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Type_AttributeItem_Parameter_SelfParameter_VariadicParameter < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Parameters<'tree> {
    type WithLifetime<'a> = Parameters<'a>;
    const KIND: &'static str = "parameters";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "parameters" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parameters");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `parenthesized_expression`\n\nThis node has a named child of type `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ParenthesizedExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ParenthesizedExpression<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ParenthesizedExpression<'tree> {
    type WithLifetime<'a> = ParenthesizedExpression<'a>;
    const KIND: &'static str = "parenthesized_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "parenthesized_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parenthesized_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `pointer_type`\n\nThis node has these fields:\n\n- `type`: `_type` ([`Type`])\n\nAnd an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PointerType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PointerType<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `mutable_specifier?` ([`MutableSpecifier`])"]
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, MutableSpecifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<MutableSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for PointerType<'tree> {
    type WithLifetime<'a> = PointerType<'a>;
    const KIND: &'static str = "pointer_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "pointer_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "pointer_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `primitive_type`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PrimitiveType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PrimitiveType<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for PrimitiveType<'tree> {
    type WithLifetime<'a> = PrimitiveType<'a>;
    const KIND: &'static str = "primitive_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "primitive_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "primitive_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `qualified_type`\n\nThis node has these fields:\n\n- `alias`: `_type` ([`Type`])\n- `type`: `_type` ([`Type`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct QualifiedType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> QualifiedType<'tree> {
    #[doc = "Get the field `alias`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn alias(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("alias")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for QualifiedType<'tree> {
    type WithLifetime<'a> = QualifiedType<'a>;
    const KIND: &'static str = "qualified_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "qualified_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "qualified_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `range_expression`\n\nThis node has named children of type `_expression*` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RangeExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RangeExpression<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `_expression*` ([`Expression`])"]
    #[inline]
    pub fn expressions<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Expression<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for RangeExpression<'tree> {
    type WithLifetime<'a> = RangeExpression<'a>;
    const KIND: &'static str = "range_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "range_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "range_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `range_pattern`\n\nThis node has named children of type `{_literal_pattern | crate | identifier | metavariable | scoped_identifier | self | super}+`:\n\n- [`LiteralPattern`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RangePattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RangePattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_literal_pattern | crate | identifier | metavariable | scoped_identifier | self | super}+`:\n\n- [`LiteralPattern`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                'tree,
            >,
        >,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for RangePattern<'tree> {
    type WithLifetime<'a> = RangePattern<'a>;
    const KIND: &'static str = "range_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "range_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "range_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `raw_string_literal`\n\nThis node has a named child of type `string_content` ([`StringContent`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RawStringLiteral<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RawStringLiteral<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `string_content` ([`StringContent`])"]
    #[inline]
    pub fn string_content(&self) -> type_sitter::NodeResult<'tree, StringContent<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<StringContent<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for RawStringLiteral<'tree> {
    type WithLifetime<'a> = RawStringLiteral<'a>;
    const KIND: &'static str = "raw_string_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "raw_string_literal" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "raw_string_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `ref_pattern`\n\nThis node has a named child of type `_pattern` ([`Pattern`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RefPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RefPattern<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_pattern` ([`Pattern`])"]
    #[inline]
    pub fn pattern(&self) -> type_sitter::NodeResult<'tree, Pattern<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for RefPattern<'tree> {
    type WithLifetime<'a> = RefPattern<'a>;
    const KIND: &'static str = "ref_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "ref_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ref_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `reference_expression`\n\nThis node has these fields:\n\n- `value`: `_expression` ([`Expression`])\n\nAnd an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReferenceExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReferenceExpression<'tree> {
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `mutable_specifier?` ([`MutableSpecifier`])"]
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, MutableSpecifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<MutableSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ReferenceExpression<'tree> {
    type WithLifetime<'a> = ReferenceExpression<'a>;
    const KIND: &'static str = "reference_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "reference_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "reference_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `reference_pattern`\n\nThis node has named children of type `{_pattern | mutable_specifier}+`:\n\n- [`Pattern`]\n- [`MutableSpecifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReferencePattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReferencePattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_pattern | mutable_specifier}+`:\n\n- [`Pattern`]\n- [`MutableSpecifier`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Pattern_MutableSpecifier<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Pattern_MutableSpecifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ReferencePattern<'tree> {
    type WithLifetime<'a> = ReferencePattern<'a>;
    const KIND: &'static str = "reference_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "reference_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "reference_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `reference_type`\n\nThis node has these fields:\n\n- `type`: `_type` ([`Type`])\n\nAnd additional named children of type `{lifetime | mutable_specifier}*`:\n\n- [`Lifetime`]\n- [`MutableSpecifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReferenceType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReferenceType<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{lifetime | mutable_specifier}*`:\n\n- [`Lifetime`]\n- [`MutableSpecifier`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Lifetime_MutableSpecifier<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: Lifetime_MutableSpecifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ReferenceType<'tree> {
    type WithLifetime<'a> = ReferenceType<'a>;
    const KIND: &'static str = "reference_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "reference_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "reference_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `remaining_field_pattern`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RemainingFieldPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RemainingFieldPattern<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for RemainingFieldPattern<'tree> {
    type WithLifetime<'a> = RemainingFieldPattern<'a>;
    const KIND: &'static str = "remaining_field_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "remaining_field_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "remaining_field_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `removed_trait_bound`\n\nThis node has a named child of type `_type` ([`Type`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RemovedTraitBound<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RemovedTraitBound<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for RemovedTraitBound<'tree> {
    type WithLifetime<'a> = RemovedTraitBound<'a>;
    const KIND: &'static str = "removed_trait_bound";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "removed_trait_bound" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "removed_trait_bound");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `return_expression`\n\nThis node has an optional named child of type `_expression?` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReturnExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReturnExpression<'tree> {
    #[doc = "Get the node's only not-extra named child, if it has one.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ReturnExpression<'tree> {
    type WithLifetime<'a> = ReturnExpression<'a>;
    const KIND: &'static str = "return_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "return_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "return_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `scoped_identifier`\n\nThis node has these fields:\n\n- `name`: `{identifier | super}` ([`Identifier`] | [`Super`])\n- `path`: `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?` ([`BracketedType`] | [`Crate`] | [`GenericType`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ScopedIdentifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ScopedIdentifier<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `{identifier | super}`:\n\n- [`Identifier`]\n- [`Super`]\n"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, anon_unions::Identifier_Super<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<anon_unions::Identifier_Super<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `path`.\n\nThis child has type `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?`:\n\n- [`BracketedType`]\n- [`Crate`]\n- [`GenericType`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[inline]    pub fn path (& self) -> Option < type_sitter :: NodeResult < 'tree , anon_unions :: BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("path") . map (< anon_unions :: BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ScopedIdentifier<'tree> {
    type WithLifetime<'a> = ScopedIdentifier<'a>;
    const KIND: &'static str = "scoped_identifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "scoped_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "scoped_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `scoped_type_identifier`\n\nThis node has these fields:\n\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `path`: `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?` ([`BracketedType`] | [`Crate`] | [`GenericType`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ScopedTypeIdentifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ScopedTypeIdentifier<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `path`.\n\nThis child has type `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?`:\n\n- [`BracketedType`]\n- [`Crate`]\n- [`GenericType`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[inline]    pub fn path (& self) -> Option < type_sitter :: NodeResult < 'tree , anon_unions :: BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("path") . map (< anon_unions :: BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ScopedTypeIdentifier<'tree> {
    type WithLifetime<'a> = ScopedTypeIdentifier<'a>;
    const KIND: &'static str = "scoped_type_identifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "scoped_type_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "scoped_type_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `scoped_use_list`\n\nThis node has these fields:\n\n- `list`: `use_list` ([`UseList`])\n- `path`: `{crate | identifier | metavariable | scoped_identifier | self | super}?` ([`Crate`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ScopedUseList<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ScopedUseList<'tree> {
    #[doc = "Get the field `list`.\n\nThis child has type `use_list` ([`UseList`])"]
    #[inline]
    pub fn list(&self) -> type_sitter::NodeResult<'tree, UseList<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("list")
            .map(<UseList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `path`.\n\nThis child has type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[inline]
    pub fn path(
        &self,
    ) -> Option<
        type_sitter::NodeResult<
            'tree,
            anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>,
        >,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("path") . map (< anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ScopedUseList<'tree> {
    type WithLifetime<'a> = ScopedUseList<'a>;
    const KIND: &'static str = "scoped_use_list";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "scoped_use_list" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "scoped_use_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `self`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Self_<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Self_<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Self_<'tree> {
    type WithLifetime<'a> = Self_<'a>;
    const KIND: &'static str = "self";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "self" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "self");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `self_parameter`\n\nThis node has named children of type `{lifetime | mutable_specifier | self}+`:\n\n- [`Lifetime`]\n- [`MutableSpecifier`]\n- [`Self_`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SelfParameter<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SelfParameter<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{lifetime | mutable_specifier | self}+`:\n\n- [`Lifetime`]\n- [`MutableSpecifier`]\n- [`Self_`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Lifetime_MutableSpecifier_Self_<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Lifetime_MutableSpecifier_Self_ < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for SelfParameter<'tree> {
    type WithLifetime<'a> = SelfParameter<'a>;
    const KIND: &'static str = "self_parameter";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "self_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "self_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `shebang`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Shebang<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Shebang<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Shebang<'tree> {
    type WithLifetime<'a> = Shebang<'a>;
    const KIND: &'static str = "shebang";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "shebang" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "shebang");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `shorthand_field_identifier`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ShorthandFieldIdentifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ShorthandFieldIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ShorthandFieldIdentifier<'tree> {
    type WithLifetime<'a> = ShorthandFieldIdentifier<'a>;
    const KIND: &'static str = "shorthand_field_identifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "shorthand_field_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "shorthand_field_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `shorthand_field_initializer`\n\nThis node has named children of type `{attribute_item | identifier}+`:\n\n- [`AttributeItem`]\n- [`Identifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ShorthandFieldInitializer<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ShorthandFieldInitializer<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{attribute_item | identifier}+`:\n\n- [`AttributeItem`]\n- [`Identifier`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::AttributeItem_Identifier<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: AttributeItem_Identifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for ShorthandFieldInitializer<'tree> {
    type WithLifetime<'a> = ShorthandFieldInitializer<'a>;
    const KIND: &'static str = "shorthand_field_initializer";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "shorthand_field_initializer" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "shorthand_field_initializer");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `slice_pattern`\n\nThis node has named children of type `_pattern*` ([`Pattern`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SlicePattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SlicePattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `_pattern*` ([`Pattern`])"]
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Pattern<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for SlicePattern<'tree> {
    type WithLifetime<'a> = SlicePattern<'a>;
    const KIND: &'static str = "slice_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "slice_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "slice_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `source_file`\n\nThis node has named children of type `{_declaration_statement | expression_statement | shebang}*`:\n\n- [`DeclarationStatement`]\n- [`ExpressionStatement`]\n- [`Shebang`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SourceFile<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SourceFile<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_declaration_statement | expression_statement | shebang}*`:\n\n- [`DeclarationStatement`]\n- [`ExpressionStatement`]\n- [`Shebang`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::DeclarationStatement_ExpressionStatement_Shebang<'tree>,
        >,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: DeclarationStatement_ExpressionStatement_Shebang < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for SourceFile<'tree> {
    type WithLifetime<'a> = SourceFile<'a>;
    const KIND: &'static str = "source_file";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "source_file" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "source_file");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `static_item`\n\nThis node has these fields:\n\n- `name`: `identifier` ([`Identifier`])\n- `type`: `_type` ([`Type`])\n- `value`: `_expression?` ([`Expression`])\n\nAnd additional named children of type `{mutable_specifier | visibility_modifier}*`:\n\n- [`MutableSpecifier`]\n- [`VisibilityModifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StaticItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StaticItem<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `value`.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{mutable_specifier | visibility_modifier}*`:\n\n- [`MutableSpecifier`]\n- [`VisibilityModifier`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::MutableSpecifier_VisibilityModifier<'tree>,
        >,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: MutableSpecifier_VisibilityModifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for StaticItem<'tree> {
    type WithLifetime<'a> = StaticItem<'a>;
    const KIND: &'static str = "static_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "static_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "static_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `string_content`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StringContent<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StringContent<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for StringContent<'tree> {
    type WithLifetime<'a> = StringContent<'a>;
    const KIND: &'static str = "string_content";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "string_content" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "string_content");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `string_literal`\n\nThis node has named children of type `{escape_sequence | string_content}*`:\n\n- [`EscapeSequence`]\n- [`StringContent`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StringLiteral<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StringLiteral<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{escape_sequence | string_content}*`:\n\n- [`EscapeSequence`]\n- [`StringContent`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::EscapeSequence_StringContent<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: EscapeSequence_StringContent < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for StringLiteral<'tree> {
    type WithLifetime<'a> = StringLiteral<'a>;
    const KIND: &'static str = "string_literal";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "string_literal" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "string_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `struct_expression`\n\nThis node has these fields:\n\n- `body`: `field_initializer_list` ([`FieldInitializerList`])\n- `name`: `{generic_type_with_turbofish | scoped_type_identifier | type_identifier}` ([`GenericTypeWithTurbofish`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StructExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StructExpression<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `field_initializer_list` ([`FieldInitializerList`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, FieldInitializerList<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<FieldInitializerList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `name`.\n\nThis child has type `{generic_type_with_turbofish | scoped_type_identifier | type_identifier}`:\n\n- [`GenericTypeWithTurbofish`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn name(
        &self,
    ) -> type_sitter::NodeResult<
        'tree,
        anon_unions::GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree>,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("name") . map (< anon_unions :: GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for StructExpression<'tree> {
    type WithLifetime<'a> = StructExpression<'a>;
    const KIND: &'static str = "struct_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "struct_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "struct_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `struct_item`\n\nThis node has these fields:\n\n- `body`: `{field_declaration_list | ordered_field_declaration_list}?` ([`FieldDeclarationList`] | [`OrderedFieldDeclarationList`])\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd additional named children of type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StructItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StructItem<'tree> {
    #[doc = "Get the optional field `body`.\n\nThis child has type `{field_declaration_list | ordered_field_declaration_list}?`:\n\n- [`FieldDeclarationList`]\n- [`OrderedFieldDeclarationList`]\n"]
    #[inline]
    pub fn body(
        &self,
    ) -> Option<
        type_sitter::NodeResult<
            'tree,
            anon_unions::FieldDeclarationList_OrderedFieldDeclarationList<'tree>,
        >,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("body") . map (< anon_unions :: FieldDeclarationList_OrderedFieldDeclarationList < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::VisibilityModifier_WhereClause<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: VisibilityModifier_WhereClause < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for StructItem<'tree> {
    type WithLifetime<'a> = StructItem<'a>;
    const KIND: &'static str = "struct_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "struct_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "struct_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `struct_pattern`\n\nThis node has these fields:\n\n- `type`: `{scoped_type_identifier | type_identifier}` ([`ScopedTypeIdentifier`] | [`TypeIdentifier`])\n\nAnd additional named children of type `{field_pattern | remaining_field_pattern}*`:\n\n- [`FieldPattern`]\n- [`RemainingFieldPattern`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StructPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StructPattern<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `{scoped_type_identifier | type_identifier}`:\n\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]\n"]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::ScopedTypeIdentifier_TypeIdentifier<'tree>>
    {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(
                <anon_unions::ScopedTypeIdentifier_TypeIdentifier<'tree> as type_sitter::Node<
                    'tree,
                >>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{field_pattern | remaining_field_pattern}*`:\n\n- [`FieldPattern`]\n- [`RemainingFieldPattern`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::FieldPattern_RemainingFieldPattern<'tree>,
        >,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: FieldPattern_RemainingFieldPattern < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for StructPattern<'tree> {
    type WithLifetime<'a> = StructPattern<'a>;
    const KIND: &'static str = "struct_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "struct_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "struct_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `super`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Super<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Super<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for Super<'tree> {
    type WithLifetime<'a> = Super<'a>;
    const KIND: &'static str = "super";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "super" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "super");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `token_binding_pattern`\n\nThis node has these fields:\n\n- `name`: `metavariable` ([`Metavariable`])\n- `type`: `fragment_specifier` ([`FragmentSpecifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenBindingPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenBindingPattern<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `metavariable` ([`Metavariable`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, Metavariable<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<Metavariable<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `fragment_specifier` ([`FragmentSpecifier`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, FragmentSpecifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<FragmentSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TokenBindingPattern<'tree> {
    type WithLifetime<'a> = TokenBindingPattern<'a>;
    const KIND: &'static str = "token_binding_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "token_binding_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_binding_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `token_repetition`\n\nThis node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenRepetition`]\n- [`TokenTree`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenRepetition<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenRepetition<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenRepetition`]\n- [`TokenTree`]\n"]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut type_sitter :: TreeCursor < 'tree >) -> impl Iterator < Item = type_sitter :: NodeResult < 'tree , anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree < 'tree > >> + 'a{
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TokenRepetition<'tree> {
    type WithLifetime<'a> = TokenRepetition<'a>;
    const KIND: &'static str = "token_repetition";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "token_repetition" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_repetition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `token_repetition_pattern`\n\nThis node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenBindingPattern`]\n- [`TokenRepetitionPattern`]\n- [`TokenTreePattern`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenRepetitionPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenRepetitionPattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenBindingPattern`]\n- [`TokenRepetitionPattern`]\n- [`TokenTreePattern`]\n"]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut type_sitter :: TreeCursor < 'tree >) -> impl Iterator < Item = type_sitter :: NodeResult < 'tree , anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern < 'tree > >> + 'a{
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TokenRepetitionPattern<'tree> {
    type WithLifetime<'a> = TokenRepetitionPattern<'a>;
    const KIND: &'static str = "token_repetition_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "token_repetition_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_repetition_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `token_tree`\n\nThis node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenRepetition`]\n- [`TokenTree`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenTree<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenTree<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenRepetition`]\n- [`TokenTree`]\n"]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut type_sitter :: TreeCursor < 'tree >) -> impl Iterator < Item = type_sitter :: NodeResult < 'tree , anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree < 'tree > >> + 'a{
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TokenTree<'tree> {
    type WithLifetime<'a> = TokenTree<'a>;
    const KIND: &'static str = "token_tree";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "token_tree" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_tree");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `token_tree_pattern`\n\nThis node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenBindingPattern`]\n- [`TokenRepetitionPattern`]\n- [`TokenTreePattern`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenTreePattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenTreePattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}*`:\n\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenBindingPattern`]\n- [`TokenRepetitionPattern`]\n- [`TokenTreePattern`]\n"]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut type_sitter :: TreeCursor < 'tree >) -> impl Iterator < Item = type_sitter :: NodeResult < 'tree , anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern < 'tree > >> + 'a{
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TokenTreePattern<'tree> {
    type WithLifetime<'a> = TokenTreePattern<'a>;
    const KIND: &'static str = "token_tree_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "token_tree_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_tree_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `trait_bounds`\n\nThis node has named children of type `{_type | higher_ranked_trait_bound | lifetime}+`:\n\n- [`Type`]\n- [`HigherRankedTraitBound`]\n- [`Lifetime`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TraitBounds<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TraitBounds<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_type | higher_ranked_trait_bound | lifetime}+`:\n\n- [`Type`]\n- [`HigherRankedTraitBound`]\n- [`Lifetime`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::Type_HigherRankedTraitBound_Lifetime<'tree>,
        >,
    > + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(
                <anon_unions::Type_HigherRankedTraitBound_Lifetime<'tree> as type_sitter::Node<
                    'tree,
                >>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TraitBounds<'tree> {
    type WithLifetime<'a> = TraitBounds<'a>;
    const KIND: &'static str = "trait_bounds";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "trait_bounds" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "trait_bounds");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `trait_item`\n\nThis node has these fields:\n\n- `body`: `declaration_list` ([`DeclarationList`])\n- `bounds`: `trait_bounds?` ([`TraitBounds`])\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd additional named children of type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TraitItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TraitItem<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `declaration_list` ([`DeclarationList`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, DeclarationList<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<DeclarationList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `bounds`.\n\nThis child has type `trait_bounds?` ([`TraitBounds`])"]
    #[inline]
    pub fn bounds(&self) -> Option<type_sitter::NodeResult<'tree, TraitBounds<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::VisibilityModifier_WhereClause<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: VisibilityModifier_WhereClause < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TraitItem<'tree> {
    type WithLifetime<'a> = TraitItem<'a>;
    const KIND: &'static str = "trait_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "trait_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "trait_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `try_block`\n\nThis node has a named child of type `block` ([`Block`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TryBlock<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TryBlock<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn block(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TryBlock<'tree> {
    type WithLifetime<'a> = TryBlock<'a>;
    const KIND: &'static str = "try_block";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "try_block" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "try_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `try_expression`\n\nThis node has a named child of type `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TryExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TryExpression<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TryExpression<'tree> {
    type WithLifetime<'a> = TryExpression<'a>;
    const KIND: &'static str = "try_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "try_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "try_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `tuple_expression`\n\nThis node has named children of type `{_expression | attribute_item}+`:\n\n- [`Expression`]\n- [`AttributeItem`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TupleExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TupleExpression<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_expression | attribute_item}+`:\n\n- [`Expression`]\n- [`AttributeItem`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Expression_AttributeItem<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Expression_AttributeItem < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TupleExpression<'tree> {
    type WithLifetime<'a> = TupleExpression<'a>;
    const KIND: &'static str = "tuple_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "tuple_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `tuple_pattern`\n\nThis node has named children of type `{_pattern | closure_expression}*`:\n\n- [`Pattern`]\n- [`ClosureExpression`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TuplePattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TuplePattern<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_pattern | closure_expression}*`:\n\n- [`Pattern`]\n- [`ClosureExpression`]\n"]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::Pattern_ClosureExpression<'tree>>,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Pattern_ClosureExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TuplePattern<'tree> {
    type WithLifetime<'a> = TuplePattern<'a>;
    const KIND: &'static str = "tuple_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "tuple_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `tuple_struct_pattern`\n\nThis node has these fields:\n\n- `type`: `{generic_type | identifier | scoped_identifier}` ([`GenericType`] | [`Identifier`] | [`ScopedIdentifier`])\n\nAnd additional named children of type `_pattern*` ([`Pattern`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TupleStructPattern<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TupleStructPattern<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `{generic_type | identifier | scoped_identifier}`:\n\n- [`GenericType`]\n- [`Identifier`]\n- [`ScopedIdentifier`]\n"]
    #[inline]
    pub fn r#type(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::GenericType_Identifier_ScopedIdentifier<'tree>>
    {
        type_sitter :: Node :: raw (self) . child_by_field_name ("type") . map (< anon_unions :: GenericType_Identifier_ScopedIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `_pattern*` ([`Pattern`])"]
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Pattern<'tree>>> + 'a {
        {
            let me = *type_sitter::Node::raw(self);
            type_sitter::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
        .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TupleStructPattern<'tree> {
    type WithLifetime<'a> = TupleStructPattern<'a>;
    const KIND: &'static str = "tuple_struct_pattern";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "tuple_struct_pattern" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_struct_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `tuple_type`\n\nThis node has named children of type `_type+` ([`Type`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TupleType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TupleType<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `_type+` ([`Type`])"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn types<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, Type<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TupleType<'tree> {
    type WithLifetime<'a> = TupleType<'a>;
    const KIND: &'static str = "tuple_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "tuple_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `type_arguments`\n\nThis node has named children of type `{_literal | _type | block | lifetime | trait_bounds | type_binding}+`:\n\n- [`Literal`]\n- [`Type`]\n- [`Block`]\n- [`Lifetime`]\n- [`TraitBounds`]\n- [`TypeBinding`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeArguments<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeArguments<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{_literal | _type | block | lifetime | trait_bounds | type_binding}+`:\n\n- [`Literal`]\n- [`Type`]\n- [`Block`]\n- [`Lifetime`]\n- [`TraitBounds`]\n- [`TypeBinding`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn children<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<
            'tree,
            anon_unions::Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree>,
        >,
    > + 'a {
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Literal_Type_Block_Lifetime_TraitBounds_TypeBinding < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TypeArguments<'tree> {
    type WithLifetime<'a> = TypeArguments<'a>;
    const KIND: &'static str = "type_arguments";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "type_arguments" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_arguments");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `type_binding`\n\nThis node has these fields:\n\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `type`: `_type` ([`Type`])\n- `type_arguments`: `type_arguments?` ([`TypeArguments`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeBinding<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeBinding<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_arguments`.\n\nThis child has type `type_arguments?` ([`TypeArguments`])"]
    #[inline]
    pub fn type_arguments(&self) -> Option<type_sitter::NodeResult<'tree, TypeArguments<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TypeBinding<'tree> {
    type WithLifetime<'a> = TypeBinding<'a>;
    const KIND: &'static str = "type_binding";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "type_binding" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_binding");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `type_cast_expression`\n\nThis node has these fields:\n\n- `type`: `_type` ([`Type`])\n- `value`: `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeCastExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeCastExpression<'tree> {
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `value`.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn value(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TypeCastExpression<'tree> {
    type WithLifetime<'a> = TypeCastExpression<'a>;
    const KIND: &'static str = "type_cast_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "type_cast_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_cast_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `type_identifier`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeIdentifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TypeIdentifier<'tree> {
    type WithLifetime<'a> = TypeIdentifier<'a>;
    const KIND: &'static str = "type_identifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "type_identifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `type_item`\n\nThis node has these fields:\n\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `type`: `_type` ([`Type`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd additional named children of type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeItem<'tree> {
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `type`.\n\nThis child has type `_type` ([`Type`])"]
    #[inline]
    pub fn r#type(&self) -> type_sitter::NodeResult<'tree, Type<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::VisibilityModifier_WhereClause<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: VisibilityModifier_WhereClause < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TypeItem<'tree> {
    type WithLifetime<'a> = TypeItem<'a>;
    const KIND: &'static str = "type_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "type_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `type_parameters`\n\nThis node has named children of type `{attribute_item | const_parameter | constrained_type_parameter | lifetime | metavariable | optional_type_parameter | type_identifier}+`:\n\n- [`AttributeItem`]\n- [`ConstParameter`]\n- [`ConstrainedTypeParameter`]\n- [`Lifetime`]\n- [`Metavariable`]\n- [`OptionalTypeParameter`]\n- [`TypeIdentifier`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeParameters<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeParameters<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{attribute_item | const_parameter | constrained_type_parameter | lifetime | metavariable | optional_type_parameter | type_identifier}+`:\n\n- [`AttributeItem`]\n- [`ConstParameter`]\n- [`ConstrainedTypeParameter`]\n- [`Lifetime`]\n- [`Metavariable`]\n- [`OptionalTypeParameter`]\n- [`TypeIdentifier`]\n"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut type_sitter :: TreeCursor < 'tree >) -> impl Iterator < Item = type_sitter :: NodeResult < 'tree , anon_unions :: AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier < 'tree > >> + 'a{
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for TypeParameters<'tree> {
    type WithLifetime<'a> = TypeParameters<'a>;
    const KIND: &'static str = "type_parameters";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "type_parameters" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_parameters");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `unary_expression`\n\nThis node has a named child of type `_expression` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnaryExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnaryExpression<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `_expression` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> type_sitter::NodeResult<'tree, Expression<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UnaryExpression<'tree> {
    type WithLifetime<'a> = UnaryExpression<'a>;
    const KIND: &'static str = "unary_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "unary_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unary_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `union_item`\n\nThis node has these fields:\n\n- `body`: `field_declaration_list` ([`FieldDeclarationList`])\n- `name`: `type_identifier` ([`TypeIdentifier`])\n- `type_parameters`: `type_parameters?` ([`TypeParameters`])\n\nAnd additional named children of type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnionItem<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnionItem<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `field_declaration_list` ([`FieldDeclarationList`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, FieldDeclarationList<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<FieldDeclarationList<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `name`.\n\nThis child has type `type_identifier` ([`TypeIdentifier`])"]
    #[inline]
    pub fn name(&self) -> type_sitter::NodeResult<'tree, TypeIdentifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the optional field `type_parameters`.\n\nThis child has type `type_parameters?` ([`TypeParameters`])"]
    #[inline]
    pub fn type_parameters(&self) -> Option<type_sitter::NodeResult<'tree, TypeParameters<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's non-field not-extra named children.\n\nThese children have type `{visibility_modifier | where_clause}*`:\n\n- [`VisibilityModifier`]\n- [`WhereClause`]\n"]
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<
        Item = type_sitter::NodeResult<'tree, anon_unions::VisibilityModifier_WhereClause<'tree>>,
    > + 'a {
        { let me = * type_sitter :: Node :: raw (self) ; type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . enumerate () . filter (move | (i , n) | ! n . is_extra () && me . field_name_for_named_child (* i as _) . is_none ()) . map (| (_ , n) | n) } . map (< anon_unions :: VisibilityModifier_WhereClause < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UnionItem<'tree> {
    type WithLifetime<'a> = UnionItem<'a>;
    const KIND: &'static str = "union_item";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "union_item" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "union_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `unit_expression`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnitExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnitExpression<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UnitExpression<'tree> {
    type WithLifetime<'a> = UnitExpression<'a>;
    const KIND: &'static str = "unit_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "unit_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unit_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `unit_type`\n\nThis node has no named children\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnitType<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnitType<'tree> {}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UnitType<'tree> {
    type WithLifetime<'a> = UnitType<'a>;
    const KIND: &'static str = "unit_type";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "unit_type" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unit_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `unsafe_block`\n\nThis node has a named child of type `block` ([`Block`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnsafeBlock<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnsafeBlock<'tree> {
    #[doc = "Get the node's only not-extra named child.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn block(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UnsafeBlock<'tree> {
    type WithLifetime<'a> = UnsafeBlock<'a>;
    const KIND: &'static str = "unsafe_block";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "unsafe_block" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unsafe_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `use_as_clause`\n\nThis node has these fields:\n\n- `alias`: `identifier` ([`Identifier`])\n- `path`: `{crate | identifier | metavariable | scoped_identifier | self | super}` ([`Crate`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseAsClause<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseAsClause<'tree> {
    #[doc = "Get the field `alias`.\n\nThis child has type `identifier` ([`Identifier`])"]
    #[inline]
    pub fn alias(&self) -> type_sitter::NodeResult<'tree, Identifier<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("alias")
            .map(<Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `path`.\n\nThis child has type `{crate | identifier | metavariable | scoped_identifier | self | super}`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[inline]
    pub fn path(
        &self,
    ) -> type_sitter::NodeResult<
        'tree,
        anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>,
    > {
        type_sitter :: Node :: raw (self) . child_by_field_name ("path") . map (< anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UseAsClause<'tree> {
    type WithLifetime<'a> = UseAsClause<'a>;
    const KIND: &'static str = "use_as_clause";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "use_as_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_as_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `use_declaration`\n\nThis node has these fields:\n\n- `argument`: `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}` ([`Crate`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`ScopedUseList`] | [`Self_`] | [`Super`] | [`UseAsClause`] | [`UseList`] | [`UseWildcard`])\n\nAnd an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseDeclaration<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseDeclaration<'tree> {
    #[doc = "Get the field `argument`.\n\nThis child has type `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`ScopedUseList`]\n- [`Self_`]\n- [`Super`]\n- [`UseAsClause`]\n- [`UseList`]\n- [`UseWildcard`]\n"]
    #[inline]    pub fn argument (& self) -> type_sitter :: NodeResult < 'tree , anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard < 'tree > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("argument") . map (< anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `visibility_modifier?` ([`VisibilityModifier`])"]
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, VisibilityModifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<VisibilityModifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UseDeclaration<'tree> {
    type WithLifetime<'a> = UseDeclaration<'a>;
    const KIND: &'static str = "use_declaration";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "use_declaration" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `use_list`\n\nThis node has named children of type `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}*`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`ScopedUseList`]\n- [`Self_`]\n- [`Super`]\n- [`UseAsClause`]\n- [`UseList`]\n- [`UseWildcard`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseList<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseList<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}*`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`ScopedUseList`]\n- [`Self_`]\n- [`Super`]\n- [`UseAsClause`]\n- [`UseList`]\n- [`UseWildcard`]\n"]
    #[inline]    pub fn children < 'a > (& self , c : & 'a mut type_sitter :: TreeCursor < 'tree >) -> impl Iterator < Item = type_sitter :: NodeResult < 'tree , anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard < 'tree > >> + 'a{
        type_sitter :: Node :: raw (self) . named_children (& mut c . 0) . filter (| n | ! n . is_extra ()) . map (< anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UseList<'tree> {
    type WithLifetime<'a> = UseList<'a>;
    const KIND: &'static str = "use_list";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "use_list" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `use_wildcard`\n\nThis node has an optional named child of type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseWildcard<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseWildcard<'tree> {
    #[doc = "Get the node's only not-extra named child, if it has one.\n\nThis child has type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[inline]
    pub fn child(
        &self,
    ) -> Option<
        type_sitter::NodeResult<
            'tree,
            anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>,
        >,
    > {
        (0 .. type_sitter :: Node :: raw (self) . named_child_count ()) . map (| i | type_sitter :: Node :: raw (self) . named_child (i) . unwrap ()) . filter (| n | ! n . is_extra ()) . next () . map (< anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for UseWildcard<'tree> {
    type WithLifetime<'a> = UseWildcard<'a>;
    const KIND: &'static str = "use_wildcard";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "use_wildcard" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_wildcard");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `variadic_parameter`\n\nThis node has these fields:\n\n- `pattern`: `_pattern?` ([`Pattern`])\n\nAnd an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct VariadicParameter<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> VariadicParameter<'tree> {
    #[doc = "Get the optional field `pattern`.\n\nThis child has type `_pattern?` ([`Pattern`])"]
    #[inline]
    pub fn pattern(&self) -> Option<type_sitter::NodeResult<'tree, Pattern<'tree>>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `mutable_specifier?` ([`MutableSpecifier`])"]
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> Option<type_sitter::NodeResult<'tree, MutableSpecifier<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<MutableSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for VariadicParameter<'tree> {
    type WithLifetime<'a> = VariadicParameter<'a>;
    const KIND: &'static str = "variadic_parameter";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "variadic_parameter" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "variadic_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `visibility_modifier`\n\nThis node has an optional named child of type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct VisibilityModifier<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> VisibilityModifier<'tree> {
    #[doc = "Get the node's only not-extra named child, if it has one.\n\nThis child has type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:\n\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]\n"]
    #[inline]
    pub fn child(
        &self,
    ) -> Option<
        type_sitter::NodeResult<
            'tree,
            anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>,
        >,
    > {
        (0 .. type_sitter :: Node :: raw (self) . named_child_count ()) . map (| i | type_sitter :: Node :: raw (self) . named_child (i) . unwrap ()) . filter (| n | ! n . is_extra ()) . next () . map (< anon_unions :: Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for VisibilityModifier<'tree> {
    type WithLifetime<'a> = VisibilityModifier<'a>;
    const KIND: &'static str = "visibility_modifier";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "visibility_modifier" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "visibility_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `where_clause`\n\nThis node has named children of type `where_predicate+` ([`WherePredicate`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct WhereClause<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> WhereClause<'tree> {
    #[doc = "Get the node's not-extra named children.\n\nThese children have type `where_predicate+` ([`WherePredicate`])"]
    #[doc = "\n\nThis is guaranteed to return at least one child."]
    #[inline]
    pub fn where_predicates<'a>(
        &self,
        c: &'a mut type_sitter::TreeCursor<'tree>,
    ) -> impl Iterator<Item = type_sitter::NodeResult<'tree, WherePredicate<'tree>>> + 'a {
        type_sitter::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<WherePredicate<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for WhereClause<'tree> {
    type WithLifetime<'a> = WhereClause<'a>;
    const KIND: &'static str = "where_clause";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "where_clause" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "where_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `where_predicate`\n\nThis node has these fields:\n\n- `bounds`: `trait_bounds` ([`TraitBounds`])\n- `left`: `{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}` ([`ArrayType`] | [`GenericType`] | [`HigherRankedTraitBound`] | [`Lifetime`] | [`PointerType`] | [`PrimitiveType`] | [`ReferenceType`] | [`ScopedTypeIdentifier`] | [`TupleType`] | [`TypeIdentifier`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct WherePredicate<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> WherePredicate<'tree> {
    #[doc = "Get the field `bounds`.\n\nThis child has type `trait_bounds` ([`TraitBounds`])"]
    #[inline]
    pub fn bounds(&self) -> type_sitter::NodeResult<'tree, TraitBounds<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `left`.\n\nThis child has type `{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}`:\n\n- [`ArrayType`]\n- [`GenericType`]\n- [`HigherRankedTraitBound`]\n- [`Lifetime`]\n- [`PointerType`]\n- [`PrimitiveType`]\n- [`ReferenceType`]\n- [`ScopedTypeIdentifier`]\n- [`TupleType`]\n- [`TypeIdentifier`]\n"]
    #[inline]    pub fn left (& self) -> type_sitter :: NodeResult < 'tree , anon_unions :: ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'tree > >{
        type_sitter :: Node :: raw (self) . child_by_field_name ("left") . map (< anon_unions :: ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw) . expect ("required child not present, there should at least be a MISSING node in its place")
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for WherePredicate<'tree> {
    type WithLifetime<'a> = WherePredicate<'a>;
    const KIND: &'static str = "where_predicate";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "where_predicate" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "where_predicate");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `while_expression`\n\nThis node has these fields:\n\n- `body`: `block` ([`Block`])\n- `condition`: `{_expression | let_chain | let_condition}` ([`Expression`] | [`LetChain`] | [`LetCondition`])\n\nAnd an optional additional named child of type `label?` ([`Label`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct WhileExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> WhileExpression<'tree> {
    #[doc = "Get the field `body`.\n\nThis child has type `block` ([`Block`])"]
    #[inline]
    pub fn body(&self) -> type_sitter::NodeResult<'tree, Block<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as type_sitter::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the field `condition`.\n\nThis child has type `{_expression | let_chain | let_condition}`:\n\n- [`Expression`]\n- [`LetChain`]\n- [`LetCondition`]\n"]
    #[inline]
    pub fn condition(
        &self,
    ) -> type_sitter::NodeResult<'tree, anon_unions::Expression_LetChain_LetCondition<'tree>> {
        type_sitter::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::Expression_LetChain_LetCondition<'tree> as type_sitter::Node<
                    'tree,
                >>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    #[doc = "Get the node's only non-field not-extra named child, if it has one.\n\nThis child has type `label?` ([`Label`])"]
    #[inline]
    pub fn label(&self) -> Option<type_sitter::NodeResult<'tree, Label<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .filter(|i| {
                type_sitter::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for WhileExpression<'tree> {
    type WithLifetime<'a> = WhileExpression<'a>;
    const KIND: &'static str = "while_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "while_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "while_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
#[doc = "Typed node `yield_expression`\n\nThis node has an optional named child of type `_expression?` ([`Expression`])\n"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct YieldExpression<'tree>(type_sitter::raw::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> YieldExpression<'tree> {
    #[doc = "Get the node's only not-extra named child, if it has one.\n\nThis child has type `_expression?` ([`Expression`])"]
    #[inline]
    pub fn expression(&self) -> Option<type_sitter::NodeResult<'tree, Expression<'tree>>> {
        (0..type_sitter::Node::raw(self).named_child_count())
            .map(|i| type_sitter::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> type_sitter::Node<'tree> for YieldExpression<'tree> {
    type WithLifetime<'a> = YieldExpression<'a>;
    const KIND: &'static str = "yield_expression";
    #[inline]
    fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
        if node.kind() == "yield_expression" {
            Ok(Self(node))
        } else {
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "yield_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &type_sitter::raw::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> type_sitter::raw::Node<'tree> {
        self.0
    }
}
pub mod unnamed {
    #[allow(unused_imports)]
    use super::*;
    #[doc = "Typed node `as`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct As<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> As<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for As<'tree> {
        type WithLifetime<'a> = As<'a>;
        const KIND: &'static str = "as";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "as" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "as");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `async`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Async<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Async<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Async<'tree> {
        type WithLifetime<'a> = Async<'a>;
        const KIND: &'static str = "async";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "async" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "async");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `await`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Await<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Await<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Await<'tree> {
        type WithLifetime<'a> = Await<'a>;
        const KIND: &'static str = "await";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "await" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "await");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `block`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Block<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Block<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Block<'tree> {
        type WithLifetime<'a> = Block<'a>;
        const KIND: &'static str = "block";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "block" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "block");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `break`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Break<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Break<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Break<'tree> {
        type WithLifetime<'a> = Break<'a>;
        const KIND: &'static str = "break";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "break" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "break");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `const`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Const<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Const<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Const<'tree> {
        type WithLifetime<'a> = Const<'a>;
        const KIND: &'static str = "const";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "const" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "const");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `continue`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Continue<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Continue<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Continue<'tree> {
        type WithLifetime<'a> = Continue<'a>;
        const KIND: &'static str = "continue";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "continue" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "continue");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `default`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Default<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Default<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Default<'tree> {
        type WithLifetime<'a> = Default<'a>;
        const KIND: &'static str = "default";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "default" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "default");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `dyn`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Dyn<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Dyn<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Dyn<'tree> {
        type WithLifetime<'a> = Dyn<'a>;
        const KIND: &'static str = "dyn";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "dyn" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "dyn");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `else`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Else<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Else<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Else<'tree> {
        type WithLifetime<'a> = Else<'a>;
        const KIND: &'static str = "else";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "else" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "else");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `enum`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Enum<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Enum<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Enum<'tree> {
        type WithLifetime<'a> = Enum<'a>;
        const KIND: &'static str = "enum";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "enum" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "enum");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `expr`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Expr<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expr<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Expr<'tree> {
        type WithLifetime<'a> = Expr<'a>;
        const KIND: &'static str = "expr";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "expr" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "expr");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `extern`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Extern<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Extern<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Extern<'tree> {
        type WithLifetime<'a> = Extern<'a>;
        const KIND: &'static str = "extern";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "extern" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "extern");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `false`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct False<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> False<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for False<'tree> {
        type WithLifetime<'a> = False<'a>;
        const KIND: &'static str = "false";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "false" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "false");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `fn`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Fn<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Fn<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Fn<'tree> {
        type WithLifetime<'a> = Fn<'a>;
        const KIND: &'static str = "fn";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "fn" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "fn");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `for`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct For<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> For<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for For<'tree> {
        type WithLifetime<'a> = For<'a>;
        const KIND: &'static str = "for";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "for" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "for");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `ident`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Ident<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Ident<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Ident<'tree> {
        type WithLifetime<'a> = Ident<'a>;
        const KIND: &'static str = "ident";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "ident" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "ident");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `if`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct If<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> If<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for If<'tree> {
        type WithLifetime<'a> = If<'a>;
        const KIND: &'static str = "if";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "if" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "if");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `impl`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Impl<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Impl<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Impl<'tree> {
        type WithLifetime<'a> = Impl<'a>;
        const KIND: &'static str = "impl";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "impl" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "impl");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `in`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct In<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> In<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for In<'tree> {
        type WithLifetime<'a> = In<'a>;
        const KIND: &'static str = "in";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "in" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "in");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `item`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Item<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Item<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Item<'tree> {
        type WithLifetime<'a> = Item<'a>;
        const KIND: &'static str = "item";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "item" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "item");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `let`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Let<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Let<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Let<'tree> {
        type WithLifetime<'a> = Let<'a>;
        const KIND: &'static str = "let";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "let" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "let");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `lifetime`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Lifetime<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Lifetime<'tree> {
        type WithLifetime<'a> = Lifetime<'a>;
        const KIND: &'static str = "lifetime";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "lifetime" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "lifetime");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `literal`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Literal<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Literal<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Literal<'tree> {
        type WithLifetime<'a> = Literal<'a>;
        const KIND: &'static str = "literal";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "literal" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "literal");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `loop`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Loop<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Loop<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Loop<'tree> {
        type WithLifetime<'a> = Loop<'a>;
        const KIND: &'static str = "loop";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "loop" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "loop");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `match`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Match<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Match<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Match<'tree> {
        type WithLifetime<'a> = Match<'a>;
        const KIND: &'static str = "match";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "match" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "match");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `meta`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Meta<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Meta<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Meta<'tree> {
        type WithLifetime<'a> = Meta<'a>;
        const KIND: &'static str = "meta";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "meta" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "meta");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `mod`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mod<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mod<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Mod<'tree> {
        type WithLifetime<'a> = Mod<'a>;
        const KIND: &'static str = "mod";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "mod" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "mod");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `move`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Move<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Move<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Move<'tree> {
        type WithLifetime<'a> = Move<'a>;
        const KIND: &'static str = "move";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "move" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "move");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `pat`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Pat<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pat<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Pat<'tree> {
        type WithLifetime<'a> = Pat<'a>;
        const KIND: &'static str = "pat";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "pat" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "pat");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `path`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Path<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Path<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Path<'tree> {
        type WithLifetime<'a> = Path<'a>;
        const KIND: &'static str = "path";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "path" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "path");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `pub`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Pub<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pub<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Pub<'tree> {
        type WithLifetime<'a> = Pub<'a>;
        const KIND: &'static str = "pub";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "pub" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "pub");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `ref`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Ref<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Ref<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Ref<'tree> {
        type WithLifetime<'a> = Ref<'a>;
        const KIND: &'static str = "ref";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "ref" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "ref");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `return`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Return<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Return<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Return<'tree> {
        type WithLifetime<'a> = Return<'a>;
        const KIND: &'static str = "return";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "return" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "return");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `static`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Static<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Static<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Static<'tree> {
        type WithLifetime<'a> = Static<'a>;
        const KIND: &'static str = "static";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "static" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "static");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `stmt`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Stmt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Stmt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Stmt<'tree> {
        type WithLifetime<'a> = Stmt<'a>;
        const KIND: &'static str = "stmt";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "stmt" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "stmt");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `struct`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Struct<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Struct<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Struct<'tree> {
        type WithLifetime<'a> = Struct<'a>;
        const KIND: &'static str = "struct";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "struct" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "struct");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `trait`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Trait<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Trait<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Trait<'tree> {
        type WithLifetime<'a> = Trait<'a>;
        const KIND: &'static str = "trait";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "trait" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "trait");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `true`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct True<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> True<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for True<'tree> {
        type WithLifetime<'a> = True<'a>;
        const KIND: &'static str = "true";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "true" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "true");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `try`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Try<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Try<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Try<'tree> {
        type WithLifetime<'a> = Try<'a>;
        const KIND: &'static str = "try";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "try" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "try");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `tt`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Tt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Tt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Tt<'tree> {
        type WithLifetime<'a> = Tt<'a>;
        const KIND: &'static str = "tt";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "tt" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "tt");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `ty`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Ty<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Ty<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Ty<'tree> {
        type WithLifetime<'a> = Ty<'a>;
        const KIND: &'static str = "ty";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "ty" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "ty");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `type`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Type<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Type<'tree> {
        type WithLifetime<'a> = Type<'a>;
        const KIND: &'static str = "type";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "type" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "type");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `union`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Union<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Union<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Union<'tree> {
        type WithLifetime<'a> = Union<'a>;
        const KIND: &'static str = "union";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "union" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "union");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `unsafe`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Unsafe<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Unsafe<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Unsafe<'tree> {
        type WithLifetime<'a> = Unsafe<'a>;
        const KIND: &'static str = "unsafe";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "unsafe" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "unsafe");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `use`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Use<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Use<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Use<'tree> {
        type WithLifetime<'a> = Use<'a>;
        const KIND: &'static str = "use";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "use" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "use");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `vis`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Vis<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Vis<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Vis<'tree> {
        type WithLifetime<'a> = Vis<'a>;
        const KIND: &'static str = "vis";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "vis" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "vis");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `where`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Where<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Where<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Where<'tree> {
        type WithLifetime<'a> = Where<'a>;
        const KIND: &'static str = "where";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "where" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "where");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `while`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct While<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> While<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for While<'tree> {
        type WithLifetime<'a> = While<'a>;
        const KIND: &'static str = "while";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "while" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "while");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `yield`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Yield<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Yield<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Yield<'tree> {
        type WithLifetime<'a> = Yield<'a>;
        const KIND: &'static str = "yield";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "yield" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "yield");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
}
pub mod symbols {
    #[allow(unused_imports)]
    use super::*;
    #[doc = "Typed node `!`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Not<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Not<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Not<'tree> {
        type WithLifetime<'a> = Not<'a>;
        const KIND: &'static str = "!";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "!" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "!");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `!=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct NotEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> NotEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for NotEq<'tree> {
        type WithLifetime<'a> = NotEq<'a>;
        const KIND: &'static str = "!=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "!=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "!=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `\"`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DoubleQuote<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DoubleQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DoubleQuote<'tree> {
        type WithLifetime<'a> = DoubleQuote<'a>;
        const KIND: &'static str = "\"";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "\"" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "\"");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `#`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hash<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hash<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Hash<'tree> {
        type WithLifetime<'a> = Hash<'a>;
        const KIND: &'static str = "#";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "#" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `$`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Dollar<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Dollar<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Dollar<'tree> {
        type WithLifetime<'a> = Dollar<'a>;
        const KIND: &'static str = "$";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "$" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "$");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `%`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mod<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mod<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Mod<'tree> {
        type WithLifetime<'a> = Mod<'a>;
        const KIND: &'static str = "%";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "%" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "%");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `%=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct ModEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ModEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ModEq<'tree> {
        type WithLifetime<'a> = ModEq<'a>;
        const KIND: &'static str = "%=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "%=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "%=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `&`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct And<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> And<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for And<'tree> {
        type WithLifetime<'a> = And<'a>;
        const KIND: &'static str = "&";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "&" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `&&`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AndAnd<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AndAnd<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AndAnd<'tree> {
        type WithLifetime<'a> = AndAnd<'a>;
        const KIND: &'static str = "&&";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "&&" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&&");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `&=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AndEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AndEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AndEq<'tree> {
        type WithLifetime<'a> = AndEq<'a>;
        const KIND: &'static str = "&=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "&=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `'`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Quote<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Quote<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Quote<'tree> {
        type WithLifetime<'a> = Quote<'a>;
        const KIND: &'static str = "'";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "'" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "'");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `(`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LParen<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LParen<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for LParen<'tree> {
        type WithLifetime<'a> = LParen<'a>;
        const KIND: &'static str = "(";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "(" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "(");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `)`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RParen<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RParen<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for RParen<'tree> {
        type WithLifetime<'a> = RParen<'a>;
        const KIND: &'static str = ")";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ")" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ")");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `*`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mul<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mul<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Mul<'tree> {
        type WithLifetime<'a> = Mul<'a>;
        const KIND: &'static str = "*";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "*" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `*/`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct MulDiv<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MulDiv<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for MulDiv<'tree> {
        type WithLifetime<'a> = MulDiv<'a>;
        const KIND: &'static str = "*/";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "*/" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*/");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `*=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct MulEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MulEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for MulEq<'tree> {
        type WithLifetime<'a> = MulEq<'a>;
        const KIND: &'static str = "*=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "*=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `+`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Add<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Add<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Add<'tree> {
        type WithLifetime<'a> = Add<'a>;
        const KIND: &'static str = "+";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "+" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "+");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `+=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AddEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AddEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AddEq<'tree> {
        type WithLifetime<'a> = AddEq<'a>;
        const KIND: &'static str = "+=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "+=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "+=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `,`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Comma<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Comma<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Comma<'tree> {
        type WithLifetime<'a> = Comma<'a>;
        const KIND: &'static str = ",";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "," {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ",");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `-`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Sub<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Sub<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Sub<'tree> {
        type WithLifetime<'a> = Sub<'a>;
        const KIND: &'static str = "-";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "-" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "-");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `-=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct SubEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for SubEq<'tree> {
        type WithLifetime<'a> = SubEq<'a>;
        const KIND: &'static str = "-=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "-=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "-=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `->`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct SubGt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubGt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for SubGt<'tree> {
        type WithLifetime<'a> = SubGt<'a>;
        const KIND: &'static str = "->";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "->" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "->");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `.`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Dot<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Dot<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Dot<'tree> {
        type WithLifetime<'a> = Dot<'a>;
        const KIND: &'static str = ".";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "." {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ".");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `..`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DotDot<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DotDot<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DotDot<'tree> {
        type WithLifetime<'a> = DotDot<'a>;
        const KIND: &'static str = "..";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ".." {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "..");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `...`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DotDotDot<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DotDotDot<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DotDotDot<'tree> {
        type WithLifetime<'a> = DotDotDot<'a>;
        const KIND: &'static str = "...";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "..." {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "...");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `..=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DotDotEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DotDotEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DotDotEq<'tree> {
        type WithLifetime<'a> = DotDotEq<'a>;
        const KIND: &'static str = "..=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "..=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "..=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `/`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Div<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Div<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Div<'tree> {
        type WithLifetime<'a> = Div<'a>;
        const KIND: &'static str = "/";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "/" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `/*`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DivMul<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DivMul<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DivMul<'tree> {
        type WithLifetime<'a> = DivMul<'a>;
        const KIND: &'static str = "/*";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "/*" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/*");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `//`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DivDiv<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DivDiv<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DivDiv<'tree> {
        type WithLifetime<'a> = DivDiv<'a>;
        const KIND: &'static str = "//";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "//" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "//");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `/=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DivEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DivEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DivEq<'tree> {
        type WithLifetime<'a> = DivEq<'a>;
        const KIND: &'static str = "/=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "/=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `:`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Colon<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Colon<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Colon<'tree> {
        type WithLifetime<'a> = Colon<'a>;
        const KIND: &'static str = ":";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ":" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ":");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `::`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct ColonColon<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ColonColon<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ColonColon<'tree> {
        type WithLifetime<'a> = ColonColon<'a>;
        const KIND: &'static str = "::";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "::" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "::");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `;`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Semicolon<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Semicolon<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Semicolon<'tree> {
        type WithLifetime<'a> = Semicolon<'a>;
        const KIND: &'static str = ";";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ";" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ";");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `<`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Lt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Lt<'tree> {
        type WithLifetime<'a> = Lt<'a>;
        const KIND: &'static str = "<";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "<" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `<<`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtLt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtLt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for LtLt<'tree> {
        type WithLifetime<'a> = LtLt<'a>;
        const KIND: &'static str = "<<";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "<<" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<<");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `<<=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtLtEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtLtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for LtLtEq<'tree> {
        type WithLifetime<'a> = LtLtEq<'a>;
        const KIND: &'static str = "<<=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "<<=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<<=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `<=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for LtEq<'tree> {
        type WithLifetime<'a> = LtEq<'a>;
        const KIND: &'static str = "<=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "<=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Eq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Eq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Eq<'tree> {
        type WithLifetime<'a> = Eq<'a>;
        const KIND: &'static str = "=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `==`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct EqEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EqEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for EqEq<'tree> {
        type WithLifetime<'a> = EqEq<'a>;
        const KIND: &'static str = "==";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "==" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "==");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `=>`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct EqGt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EqGt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for EqGt<'tree> {
        type WithLifetime<'a> = EqGt<'a>;
        const KIND: &'static str = "=>";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "=>" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "=>");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `>`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Gt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Gt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Gt<'tree> {
        type WithLifetime<'a> = Gt<'a>;
        const KIND: &'static str = ">";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ">" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `>=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for GtEq<'tree> {
        type WithLifetime<'a> = GtEq<'a>;
        const KIND: &'static str = ">=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ">=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `>>`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtGt<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtGt<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for GtGt<'tree> {
        type WithLifetime<'a> = GtGt<'a>;
        const KIND: &'static str = ">>";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ">>" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">>");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `>>=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtGtEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtGtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for GtGtEq<'tree> {
        type WithLifetime<'a> = GtGtEq<'a>;
        const KIND: &'static str = ">>=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == ">>=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">>=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `?`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Question<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Question<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Question<'tree> {
        type WithLifetime<'a> = Question<'a>;
        const KIND: &'static str = "?";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "?" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "?");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `@`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct At<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> At<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for At<'tree> {
        type WithLifetime<'a> = At<'a>;
        const KIND: &'static str = "@";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "@" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "@");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `[`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LBracket<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for LBracket<'tree> {
        type WithLifetime<'a> = LBracket<'a>;
        const KIND: &'static str = "[";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "[" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "[");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `]`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RBracket<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for RBracket<'tree> {
        type WithLifetime<'a> = RBracket<'a>;
        const KIND: &'static str = "]";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "]" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "]");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `^`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct BitXor<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BitXor<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for BitXor<'tree> {
        type WithLifetime<'a> = BitXor<'a>;
        const KIND: &'static str = "^";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "^" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "^");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `^=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct BitXorEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BitXorEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for BitXorEq<'tree> {
        type WithLifetime<'a> = BitXorEq<'a>;
        const KIND: &'static str = "^=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "^=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "^=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `_`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct __<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> __<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for __<'tree> {
        type WithLifetime<'a> = __<'a>;
        const KIND: &'static str = "_";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "_" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `macro_rules!`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct MacroRulesNot<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MacroRulesNot<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for MacroRulesNot<'tree> {
        type WithLifetime<'a> = MacroRulesNot<'a>;
        const KIND: &'static str = "macro_rules!";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "macro_rules!" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "macro_rules!");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `{`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LBrace<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for LBrace<'tree> {
        type WithLifetime<'a> = LBrace<'a>;
        const KIND: &'static str = "{";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "{" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "{");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `|`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Or<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Or<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Or<'tree> {
        type WithLifetime<'a> = Or<'a>;
        const KIND: &'static str = "|";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "|" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "|");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `|=`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct OrEq<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> OrEq<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for OrEq<'tree> {
        type WithLifetime<'a> = OrEq<'a>;
        const KIND: &'static str = "|=";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "|=" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "|=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `||`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct OrOr<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> OrOr<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for OrOr<'tree> {
        type WithLifetime<'a> = OrOr<'a>;
        const KIND: &'static str = "||";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "||" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "||");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `}`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RBrace<'tree>(type_sitter::raw::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for RBrace<'tree> {
        type WithLifetime<'a> = RBrace<'a>;
        const KIND: &'static str = "}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if node.kind() == "}" {
                Ok(Self(node))
            } else {
                Err(type_sitter::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: type_sitter::raw::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "}");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            self.0
        }
    }
}
pub mod anon_unions {
    #[allow(unused_imports)]
    use super::*;
    #[doc = "One of `{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}`:\n- [`ArrayType`]\n- [`GenericType`]\n- [`HigherRankedTraitBound`]\n- [`Lifetime`]\n- [`PointerType`]\n- [`PrimitiveType`]\n- [`ReferenceType`]\n- [`ScopedTypeIdentifier`]\n- [`TupleType`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        ArrayType(ArrayType<'tree>),
        GenericType(GenericType<'tree>),
        HigherRankedTraitBound(HigherRankedTraitBound<'tree>),
        Lifetime(Lifetime<'tree>),
        PointerType(PointerType<'tree>),
        PrimitiveType(PrimitiveType<'tree>),
        ReferenceType(ReferenceType<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TupleType(TupleType<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl < 'tree > ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'tree > { # [doc = "Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`"] # [inline] pub fn as_array_type (self) -> Option < ArrayType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ArrayType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`"] # [inline] pub fn as_generic_type (self) -> Option < GenericType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: GenericType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `higher_ranked_trait_bound` ([`HigherRankedTraitBound`]), otherwise returns `None`"] # [inline] pub fn as_higher_ranked_trait_bound (self) -> Option < HigherRankedTraitBound < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: HigherRankedTraitBound (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"] # [inline] pub fn as_lifetime (self) -> Option < Lifetime < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Lifetime (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`"] # [inline] pub fn as_pointer_type (self) -> Option < PointerType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: PointerType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`"] # [inline] pub fn as_primitive_type (self) -> Option < PrimitiveType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: PrimitiveType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`"] # [inline] pub fn as_reference_type (self) -> Option < ReferenceType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ReferenceType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"] # [inline] pub fn as_scoped_type_identifier (self) -> Option < ScopedTypeIdentifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ScopedTypeIdentifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`"] # [inline] pub fn as_tuple_type (self) -> Option < TupleType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TupleType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"] # [inline] pub fn as_type_identifier (self) -> Option < TypeIdentifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TypeIdentifier (x) = self { Some (x) } else { None } } }
    #[automatically_derived]
    impl < 'tree > type_sitter :: Node < 'tree > for ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'tree > { type WithLifetime < 'a > = ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'a > ; const KIND : & 'static str = "{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}" ; # [inline] fn try_from_raw (node : type_sitter :: raw :: Node < 'tree >) -> type_sitter :: NodeResult < Self > { match node . kind () { "array_type" => Ok (unsafe { Self :: ArrayType (< ArrayType < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "generic_type" => Ok (unsafe { Self :: GenericType (< GenericType < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "higher_ranked_trait_bound" => Ok (unsafe { Self :: HigherRankedTraitBound (< HigherRankedTraitBound < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "lifetime" => Ok (unsafe { Self :: Lifetime (< Lifetime < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "pointer_type" => Ok (unsafe { Self :: PointerType (< PointerType < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "primitive_type" => Ok (unsafe { Self :: PrimitiveType (< PrimitiveType < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "reference_type" => Ok (unsafe { Self :: ReferenceType (< ReferenceType < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "scoped_type_identifier" => Ok (unsafe { Self :: ScopedTypeIdentifier (< ScopedTypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "tuple_type" => Ok (unsafe { Self :: TupleType (< TupleType < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "type_identifier" => Ok (unsafe { Self :: TypeIdentifier (< TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , _ => Err (type_sitter :: IncorrectKind :: new :: < Self > (node)) } } # [inline] fn raw (& self) -> & type_sitter :: raw :: Node < 'tree > { match self { Self :: ArrayType (x) => type_sitter :: Node :: raw (x) , Self :: GenericType (x) => type_sitter :: Node :: raw (x) , Self :: HigherRankedTraitBound (x) => type_sitter :: Node :: raw (x) , Self :: Lifetime (x) => type_sitter :: Node :: raw (x) , Self :: PointerType (x) => type_sitter :: Node :: raw (x) , Self :: PrimitiveType (x) => type_sitter :: Node :: raw (x) , Self :: ReferenceType (x) => type_sitter :: Node :: raw (x) , Self :: ScopedTypeIdentifier (x) => type_sitter :: Node :: raw (x) , Self :: TupleType (x) => type_sitter :: Node :: raw (x) , Self :: TypeIdentifier (x) => type_sitter :: Node :: raw (x) , } } # [inline] fn raw_mut (& mut self) -> & mut type_sitter :: raw :: Node < 'tree > { match self { Self :: ArrayType (x) => type_sitter :: Node :: raw_mut (x) , Self :: GenericType (x) => type_sitter :: Node :: raw_mut (x) , Self :: HigherRankedTraitBound (x) => type_sitter :: Node :: raw_mut (x) , Self :: Lifetime (x) => type_sitter :: Node :: raw_mut (x) , Self :: PointerType (x) => type_sitter :: Node :: raw_mut (x) , Self :: PrimitiveType (x) => type_sitter :: Node :: raw_mut (x) , Self :: ReferenceType (x) => type_sitter :: Node :: raw_mut (x) , Self :: ScopedTypeIdentifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: TupleType (x) => type_sitter :: Node :: raw_mut (x) , Self :: TypeIdentifier (x) => type_sitter :: Node :: raw_mut (x) , } } # [inline] fn into_raw (self) -> type_sitter :: raw :: Node < 'tree > { match self { Self :: ArrayType (x) => x . into_raw () , Self :: GenericType (x) => x . into_raw () , Self :: HigherRankedTraitBound (x) => x . into_raw () , Self :: Lifetime (x) => x . into_raw () , Self :: PointerType (x) => x . into_raw () , Self :: PrimitiveType (x) => x . into_raw () , Self :: ReferenceType (x) => x . into_raw () , Self :: ScopedTypeIdentifier (x) => x . into_raw () , Self :: TupleType (x) => x . into_raw () , Self :: TypeIdentifier (x) => x . into_raw () , } } }
    #[doc = "One of `{attribute_item | const_parameter | constrained_type_parameter | lifetime | metavariable | optional_type_parameter | type_identifier}`:\n- [`AttributeItem`]\n- [`ConstParameter`]\n- [`ConstrainedTypeParameter`]\n- [`Lifetime`]\n- [`Metavariable`]\n- [`OptionalTypeParameter`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier<
        'tree,
    > {
        AttributeItem(AttributeItem<'tree>),
        ConstParameter(ConstParameter<'tree>),
        ConstrainedTypeParameter(ConstrainedTypeParameter<'tree>),
        Lifetime(Lifetime<'tree>),
        Metavariable(Metavariable<'tree>),
        OptionalTypeParameter(OptionalTypeParameter<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl < 'tree > AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier < 'tree > { # [doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"] # [inline] pub fn as_attribute_item (self) -> Option < AttributeItem < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: AttributeItem (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `const_parameter` ([`ConstParameter`]), otherwise returns `None`"] # [inline] pub fn as_const_parameter (self) -> Option < ConstParameter < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ConstParameter (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `constrained_type_parameter` ([`ConstrainedTypeParameter`]), otherwise returns `None`"] # [inline] pub fn as_constrained_type_parameter (self) -> Option < ConstrainedTypeParameter < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ConstrainedTypeParameter (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"] # [inline] pub fn as_lifetime (self) -> Option < Lifetime < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Lifetime (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"] # [inline] pub fn as_metavariable (self) -> Option < Metavariable < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Metavariable (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `optional_type_parameter` ([`OptionalTypeParameter`]), otherwise returns `None`"] # [inline] pub fn as_optional_type_parameter (self) -> Option < OptionalTypeParameter < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: OptionalTypeParameter (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"] # [inline] pub fn as_type_identifier (self) -> Option < TypeIdentifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TypeIdentifier (x) = self { Some (x) } else { None } } }
    #[automatically_derived]
    impl < 'tree > type_sitter :: Node < 'tree > for AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier < 'tree > { type WithLifetime < 'a > = AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier < 'a > ; const KIND : & 'static str = "{attribute_item | const_parameter | constrained_type_parameter | lifetime | metavariable | optional_type_parameter | type_identifier}" ; # [inline] fn try_from_raw (node : type_sitter :: raw :: Node < 'tree >) -> type_sitter :: NodeResult < Self > { match node . kind () { "attribute_item" => Ok (unsafe { Self :: AttributeItem (< AttributeItem < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "const_parameter" => Ok (unsafe { Self :: ConstParameter (< ConstParameter < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "constrained_type_parameter" => Ok (unsafe { Self :: ConstrainedTypeParameter (< ConstrainedTypeParameter < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "lifetime" => Ok (unsafe { Self :: Lifetime (< Lifetime < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "metavariable" => Ok (unsafe { Self :: Metavariable (< Metavariable < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "optional_type_parameter" => Ok (unsafe { Self :: OptionalTypeParameter (< OptionalTypeParameter < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "type_identifier" => Ok (unsafe { Self :: TypeIdentifier (< TypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , _ => Err (type_sitter :: IncorrectKind :: new :: < Self > (node)) } } # [inline] fn raw (& self) -> & type_sitter :: raw :: Node < 'tree > { match self { Self :: AttributeItem (x) => type_sitter :: Node :: raw (x) , Self :: ConstParameter (x) => type_sitter :: Node :: raw (x) , Self :: ConstrainedTypeParameter (x) => type_sitter :: Node :: raw (x) , Self :: Lifetime (x) => type_sitter :: Node :: raw (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw (x) , Self :: OptionalTypeParameter (x) => type_sitter :: Node :: raw (x) , Self :: TypeIdentifier (x) => type_sitter :: Node :: raw (x) , } } # [inline] fn raw_mut (& mut self) -> & mut type_sitter :: raw :: Node < 'tree > { match self { Self :: AttributeItem (x) => type_sitter :: Node :: raw_mut (x) , Self :: ConstParameter (x) => type_sitter :: Node :: raw_mut (x) , Self :: ConstrainedTypeParameter (x) => type_sitter :: Node :: raw_mut (x) , Self :: Lifetime (x) => type_sitter :: Node :: raw_mut (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw_mut (x) , Self :: OptionalTypeParameter (x) => type_sitter :: Node :: raw_mut (x) , Self :: TypeIdentifier (x) => type_sitter :: Node :: raw_mut (x) , } } # [inline] fn into_raw (self) -> type_sitter :: raw :: Node < 'tree > { match self { Self :: AttributeItem (x) => x . into_raw () , Self :: ConstParameter (x) => x . into_raw () , Self :: ConstrainedTypeParameter (x) => x . into_raw () , Self :: Lifetime (x) => x . into_raw () , Self :: Metavariable (x) => x . into_raw () , Self :: OptionalTypeParameter (x) => x . into_raw () , Self :: TypeIdentifier (x) => x . into_raw () , } } }
    #[doc = "One of `{attribute_item | enum_variant}`:\n- [`AttributeItem`]\n- [`EnumVariant`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_EnumVariant<'tree> {
        AttributeItem(AttributeItem<'tree>),
        EnumVariant(EnumVariant<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_EnumVariant<'tree> {
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `enum_variant` ([`EnumVariant`]), otherwise returns `None`"]
        #[inline]
        pub fn as_enum_variant(self) -> Option<EnumVariant<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EnumVariant(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AttributeItem_EnumVariant<'tree> {
        type WithLifetime<'a> = AttributeItem_EnumVariant<'a>;
        const KIND: &'static str = "{attribute_item | enum_variant}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "attribute_item" => Ok(unsafe {
                    Self::AttributeItem(
                        <AttributeItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "enum_variant" => Ok(unsafe {
                    Self::EnumVariant(
                        <EnumVariant<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw(x),
                Self::EnumVariant(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
                Self::EnumVariant(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::EnumVariant(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{attribute_item | field_declaration}`:\n- [`AttributeItem`]\n- [`FieldDeclaration`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_FieldDeclaration<'tree> {
        AttributeItem(AttributeItem<'tree>),
        FieldDeclaration(FieldDeclaration<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_FieldDeclaration<'tree> {
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `field_declaration` ([`FieldDeclaration`]), otherwise returns `None`"]
        #[inline]
        pub fn as_field_declaration(self) -> Option<FieldDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclaration(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AttributeItem_FieldDeclaration<'tree> {
        type WithLifetime<'a> = AttributeItem_FieldDeclaration<'a>;
        const KIND: &'static str = "{attribute_item | field_declaration}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "attribute_item" => Ok(unsafe {
                    Self::AttributeItem(
                        <AttributeItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "field_declaration" => {
                    Ok(unsafe {
                        Self::FieldDeclaration(<FieldDeclaration<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw(x),
                Self::FieldDeclaration(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
                Self::FieldDeclaration(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::FieldDeclaration(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{attribute_item | identifier}`:\n- [`AttributeItem`]\n- [`Identifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_Identifier<'tree> {
        AttributeItem(AttributeItem<'tree>),
        Identifier(Identifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_Identifier<'tree> {
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AttributeItem_Identifier<'tree> {
        type WithLifetime<'a> = AttributeItem_Identifier<'a>;
        const KIND: &'static str = "{attribute_item | identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "attribute_item" => Ok(unsafe {
                    Self::AttributeItem(
                        <AttributeItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw(x),
                Self::Identifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{attribute_item | inner_attribute_item}`:\n- [`AttributeItem`]\n- [`InnerAttributeItem`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_InnerAttributeItem<'tree> {
        AttributeItem(AttributeItem<'tree>),
        InnerAttributeItem(InnerAttributeItem<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_InnerAttributeItem<'tree> {
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_inner_attribute_item(self) -> Option<InnerAttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::InnerAttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AttributeItem_InnerAttributeItem<'tree> {
        type WithLifetime<'a> = AttributeItem_InnerAttributeItem<'a>;
        const KIND: &'static str = "{attribute_item | inner_attribute_item}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "attribute_item" => Ok(unsafe {
                    Self::AttributeItem(
                        <AttributeItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "inner_attribute_item" => Ok(unsafe {
                    Self::InnerAttributeItem(<InnerAttributeItem<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw(x),
                Self::InnerAttributeItem(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
                Self::InnerAttributeItem(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::InnerAttributeItem(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{attribute_item | visibility_modifier}`:\n- [`AttributeItem`]\n- [`VisibilityModifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_VisibilityModifier<'tree> {
        AttributeItem(AttributeItem<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_VisibilityModifier<'tree> {
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_visibility_modifier(self) -> Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for AttributeItem_VisibilityModifier<'tree> {
        type WithLifetime<'a> = AttributeItem_VisibilityModifier<'a>;
        const KIND: &'static str = "{attribute_item | visibility_modifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "attribute_item" => Ok(unsafe {
                    Self::AttributeItem(
                        <AttributeItem<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "visibility_modifier" => Ok(unsafe {
                    Self::VisibilityModifier(<VisibilityModifier<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{base_field_initializer | field_initializer | shorthand_field_initializer}`:\n- [`BaseFieldInitializer`]\n- [`FieldInitializer`]\n- [`ShorthandFieldInitializer`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'tree> {
        BaseFieldInitializer(BaseFieldInitializer<'tree>),
        FieldInitializer(FieldInitializer<'tree>),
        ShorthandFieldInitializer(ShorthandFieldInitializer<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'tree> {
        #[doc = "Returns the node if it is of type `base_field_initializer` ([`BaseFieldInitializer`]), otherwise returns `None`"]
        #[inline]
        pub fn as_base_field_initializer(self) -> Option<BaseFieldInitializer<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BaseFieldInitializer(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `field_initializer` ([`FieldInitializer`]), otherwise returns `None`"]
        #[inline]
        pub fn as_field_initializer(self) -> Option<FieldInitializer<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldInitializer(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `shorthand_field_initializer` ([`ShorthandFieldInitializer`]), otherwise returns `None`"]
        #[inline]
        pub fn as_shorthand_field_initializer(self) -> Option<ShorthandFieldInitializer<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ShorthandFieldInitializer(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'tree>
    {
        type WithLifetime<'a> = BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'a>;
        const KIND: &'static str =
            "{base_field_initializer | field_initializer | shorthand_field_initializer}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "base_field_initializer" => {
                    Ok(unsafe {
                        Self :: BaseFieldInitializer (< BaseFieldInitializer < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "field_initializer" => {
                    Ok(unsafe {
                        Self::FieldInitializer(<FieldInitializer<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "shorthand_field_initializer" => Ok(unsafe {
                    Self :: ShorthandFieldInitializer (< ShorthandFieldInitializer < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::BaseFieldInitializer(x) => type_sitter::Node::raw(x),
                Self::FieldInitializer(x) => type_sitter::Node::raw(x),
                Self::ShorthandFieldInitializer(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::BaseFieldInitializer(x) => type_sitter::Node::raw_mut(x),
                Self::FieldInitializer(x) => type_sitter::Node::raw_mut(x),
                Self::ShorthandFieldInitializer(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::BaseFieldInitializer(x) => x.into_raw(),
                Self::FieldInitializer(x) => x.into_raw(),
                Self::ShorthandFieldInitializer(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{block | if_expression}`:\n- [`Block`]\n- [`IfExpression`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Block_IfExpression<'tree> {
        Block(Block<'tree>),
        IfExpression(IfExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Block_IfExpression<'tree> {
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Block(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IfExpression(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Block_IfExpression<'tree> {
        type WithLifetime<'a> = Block_IfExpression<'a>;
        const KIND: &'static str = "{block | if_expression}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "block" => Ok(unsafe {
                    Self::Block(
                        <Block<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "if_expression" => Ok(unsafe {
                    Self::IfExpression(
                        <IfExpression<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Block(x) => type_sitter::Node::raw(x),
                Self::IfExpression(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Block(x) => type_sitter::Node::raw_mut(x),
                Self::IfExpression(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Block(x) => x.into_raw(),
                Self::IfExpression(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}`:\n- [`BracketedType`]\n- [`Crate`]\n- [`GenericType`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    > {
        BracketedType(BracketedType<'tree>),
        Crate(Crate<'tree>),
        GenericType(GenericType<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree>
        BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>
    {
        #[doc = "Returns the node if it is of type `bracketed_type` ([`BracketedType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_bracketed_type(self) -> Option<BracketedType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BracketedType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`"]
        #[inline]
        pub fn as_crate(self) -> Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`"]
        #[inline]
        pub fn as_super(self) -> Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
            'tree,
        >
    {
        type WithLifetime<'a> =
            BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                'a,
            >;
        const KIND : & 'static str = "{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}" ;
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "bracketed_type" => Ok(unsafe {
                    Self::BracketedType(
                        <BracketedType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "crate" => Ok(unsafe {
                    Self::Crate(
                        <Crate<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "generic_type" => Ok(unsafe {
                    Self::GenericType(
                        <GenericType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "metavariable" => Ok(unsafe {
                    Self::Metavariable(
                        <Metavariable<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "scoped_identifier" => {
                    Ok(unsafe {
                        Self::ScopedIdentifier(<ScopedIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "self" => Ok(unsafe {
                    Self::Self_(
                        <Self_<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "super" => Ok(unsafe {
                    Self::Super(
                        <Super<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::BracketedType(x) => type_sitter::Node::raw(x),
                Self::Crate(x) => type_sitter::Node::raw(x),
                Self::GenericType(x) => type_sitter::Node::raw(x),
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::Metavariable(x) => type_sitter::Node::raw(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
                Self::Self_(x) => type_sitter::Node::raw(x),
                Self::Super(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::BracketedType(x) => type_sitter::Node::raw_mut(x),
                Self::Crate(x) => type_sitter::Node::raw_mut(x),
                Self::GenericType(x) => type_sitter::Node::raw_mut(x),
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::Metavariable(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::Self_(x) => type_sitter::Node::raw_mut(x),
                Self::Super(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::BracketedType(x) => x.into_raw(),
                Self::Crate(x) => x.into_raw(),
                Self::GenericType(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{constrained_type_parameter | type_identifier}`:\n- [`ConstrainedTypeParameter`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ConstrainedTypeParameter_TypeIdentifier<'tree> {
        ConstrainedTypeParameter(ConstrainedTypeParameter<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ConstrainedTypeParameter_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `constrained_type_parameter` ([`ConstrainedTypeParameter`]), otherwise returns `None`"]
        #[inline]
        pub fn as_constrained_type_parameter(self) -> Option<ConstrainedTypeParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ConstrainedTypeParameter(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ConstrainedTypeParameter_TypeIdentifier<'tree> {
        type WithLifetime<'a> = ConstrainedTypeParameter_TypeIdentifier<'a>;
        const KIND: &'static str = "{constrained_type_parameter | type_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "constrained_type_parameter" => Ok(unsafe {
                    Self :: ConstrainedTypeParameter (< ConstrainedTypeParameter < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                }),
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::ConstrainedTypeParameter(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::ConstrainedTypeParameter(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::ConstrainedTypeParameter(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}`:\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`ScopedUseList`]\n- [`Self_`]\n- [`Super`]\n- [`UseAsClause`]\n- [`UseList`]\n- [`UseWildcard`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
        'tree,
    > {
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        ScopedUseList(ScopedUseList<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
        UseAsClause(UseAsClause<'tree>),
        UseList(UseList<'tree>),
        UseWildcard(UseWildcard<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl < 'tree > Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard < 'tree > { # [doc = "Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`"] # [inline] pub fn as_crate (self) -> Option < Crate < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Crate (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"] # [inline] pub fn as_identifier (self) -> Option < Identifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Identifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"] # [inline] pub fn as_metavariable (self) -> Option < Metavariable < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Metavariable (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"] # [inline] pub fn as_scoped_identifier (self) -> Option < ScopedIdentifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ScopedIdentifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `scoped_use_list` ([`ScopedUseList`]), otherwise returns `None`"] # [inline] pub fn as_scoped_use_list (self) -> Option < ScopedUseList < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ScopedUseList (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"] # [inline] pub fn as_self (self) -> Option < Self_ < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Self_ (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`"] # [inline] pub fn as_super (self) -> Option < Super < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Super (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `use_as_clause` ([`UseAsClause`]), otherwise returns `None`"] # [inline] pub fn as_use_as_clause (self) -> Option < UseAsClause < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: UseAsClause (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `use_list` ([`UseList`]), otherwise returns `None`"] # [inline] pub fn as_use_list (self) -> Option < UseList < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: UseList (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `use_wildcard` ([`UseWildcard`]), otherwise returns `None`"] # [inline] pub fn as_use_wildcard (self) -> Option < UseWildcard < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: UseWildcard (x) = self { Some (x) } else { None } } }
    #[automatically_derived]
    impl < 'tree > type_sitter :: Node < 'tree > for Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard < 'tree > { type WithLifetime < 'a > = Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard < 'a > ; const KIND : & 'static str = "{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}" ; # [inline] fn try_from_raw (node : type_sitter :: raw :: Node < 'tree >) -> type_sitter :: NodeResult < Self > { match node . kind () { "crate" => Ok (unsafe { Self :: Crate (< Crate < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "identifier" => Ok (unsafe { Self :: Identifier (< Identifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "metavariable" => Ok (unsafe { Self :: Metavariable (< Metavariable < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "scoped_identifier" => Ok (unsafe { Self :: ScopedIdentifier (< ScopedIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "scoped_use_list" => Ok (unsafe { Self :: ScopedUseList (< ScopedUseList < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "self" => Ok (unsafe { Self :: Self_ (< Self_ < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "super" => Ok (unsafe { Self :: Super (< Super < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "use_as_clause" => Ok (unsafe { Self :: UseAsClause (< UseAsClause < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "use_list" => Ok (unsafe { Self :: UseList (< UseList < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , "use_wildcard" => Ok (unsafe { Self :: UseWildcard (< UseWildcard < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node)) }) , _ => Err (type_sitter :: IncorrectKind :: new :: < Self > (node)) } } # [inline] fn raw (& self) -> & type_sitter :: raw :: Node < 'tree > { match self { Self :: Crate (x) => type_sitter :: Node :: raw (x) , Self :: Identifier (x) => type_sitter :: Node :: raw (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw (x) , Self :: ScopedIdentifier (x) => type_sitter :: Node :: raw (x) , Self :: ScopedUseList (x) => type_sitter :: Node :: raw (x) , Self :: Self_ (x) => type_sitter :: Node :: raw (x) , Self :: Super (x) => type_sitter :: Node :: raw (x) , Self :: UseAsClause (x) => type_sitter :: Node :: raw (x) , Self :: UseList (x) => type_sitter :: Node :: raw (x) , Self :: UseWildcard (x) => type_sitter :: Node :: raw (x) , } } # [inline] fn raw_mut (& mut self) -> & mut type_sitter :: raw :: Node < 'tree > { match self { Self :: Crate (x) => type_sitter :: Node :: raw_mut (x) , Self :: Identifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw_mut (x) , Self :: ScopedIdentifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: ScopedUseList (x) => type_sitter :: Node :: raw_mut (x) , Self :: Self_ (x) => type_sitter :: Node :: raw_mut (x) , Self :: Super (x) => type_sitter :: Node :: raw_mut (x) , Self :: UseAsClause (x) => type_sitter :: Node :: raw_mut (x) , Self :: UseList (x) => type_sitter :: Node :: raw_mut (x) , Self :: UseWildcard (x) => type_sitter :: Node :: raw_mut (x) , } } # [inline] fn into_raw (self) -> type_sitter :: raw :: Node < 'tree > { match self { Self :: Crate (x) => x . into_raw () , Self :: Identifier (x) => x . into_raw () , Self :: Metavariable (x) => x . into_raw () , Self :: ScopedIdentifier (x) => x . into_raw () , Self :: ScopedUseList (x) => x . into_raw () , Self :: Self_ (x) => x . into_raw () , Self :: Super (x) => x . into_raw () , Self :: UseAsClause (x) => x . into_raw () , Self :: UseList (x) => x . into_raw () , Self :: UseWildcard (x) => x . into_raw () , } } }
    #[doc = "One of `{crate | identifier | metavariable | scoped_identifier | self | super}`:\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        #[doc = "Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`"]
        #[inline]
        pub fn as_crate(self) -> Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`"]
        #[inline]
        pub fn as_super(self) -> Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>
    {
        type WithLifetime<'a> = Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'a>;
        const KIND: &'static str =
            "{crate | identifier | metavariable | scoped_identifier | self | super}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "crate" => Ok(unsafe {
                    Self::Crate(
                        <Crate<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "metavariable" => Ok(unsafe {
                    Self::Metavariable(
                        <Metavariable<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "scoped_identifier" => {
                    Ok(unsafe {
                        Self::ScopedIdentifier(<ScopedIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "self" => Ok(unsafe {
                    Self::Self_(
                        <Self_<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "super" => Ok(unsafe {
                    Self::Super(
                        <Super<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Crate(x) => type_sitter::Node::raw(x),
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::Metavariable(x) => type_sitter::Node::raw(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
                Self::Self_(x) => type_sitter::Node::raw(x),
                Self::Super(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Crate(x) => type_sitter::Node::raw_mut(x),
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::Metavariable(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::Self_(x) => type_sitter::Node::raw_mut(x),
                Self::Super(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Crate(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{crate | visibility_modifier}`:\n- [`Crate`]\n- [`VisibilityModifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Crate_VisibilityModifier<'tree> {
        Crate(Crate<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Crate_VisibilityModifier<'tree> {
        #[doc = "Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`"]
        #[inline]
        pub fn as_crate(self) -> Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_visibility_modifier(self) -> Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Crate_VisibilityModifier<'tree> {
        type WithLifetime<'a> = Crate_VisibilityModifier<'a>;
        const KIND: &'static str = "{crate | visibility_modifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "crate" => Ok(unsafe {
                    Self::Crate(
                        <Crate<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "visibility_modifier" => Ok(unsafe {
                    Self::VisibilityModifier(<VisibilityModifier<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Crate(x) => type_sitter::Node::raw(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Crate(x) => type_sitter::Node::raw_mut(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Crate(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_declaration_statement | expression_statement | shebang}`:\n- [`DeclarationStatement`]\n- [`ExpressionStatement`]\n- [`Shebang`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum DeclarationStatement_ExpressionStatement_Shebang<'tree> {
        DeclarationStatement(DeclarationStatement<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
        Shebang(Shebang<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DeclarationStatement_ExpressionStatement_Shebang<'tree> {
        #[doc = "Returns the node if it is of type `_declaration_statement` ([`DeclarationStatement`]), otherwise returns `None`"]
        #[inline]
        pub fn as_declaration_statement(self) -> Option<DeclarationStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DeclarationStatement(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression_statement(self) -> Option<ExpressionStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExpressionStatement(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `shebang` ([`Shebang`]), otherwise returns `None`"]
        #[inline]
        pub fn as_shebang(self) -> Option<Shebang<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Shebang(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `associated_type` ([`AssociatedType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_associated_type(self) -> Option<AssociatedType<'tree>> {
            self.as_declaration_statement()?.as_associated_type()
        }
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            self.as_declaration_statement()?.as_attribute_item()
        }
        #[doc = "Returns the node if it is of type `const_item` ([`ConstItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_const_item(self) -> Option<ConstItem<'tree>> {
            self.as_declaration_statement()?.as_const_item()
        }
        #[doc = "Returns the node if it is of type `empty_statement` ([`EmptyStatement`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_empty_statement(self) -> Option<EmptyStatement<'tree>> {
            self.as_declaration_statement()?.as_empty_statement()
        }
        #[doc = "Returns the node if it is of type `enum_item` ([`EnumItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_enum_item(self) -> Option<EnumItem<'tree>> {
            self.as_declaration_statement()?.as_enum_item()
        }
        #[doc = "Returns the node if it is of type `extern_crate_declaration` ([`ExternCrateDeclaration`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_extern_crate_declaration(self) -> Option<ExternCrateDeclaration<'tree>> {
            self.as_declaration_statement()?
                .as_extern_crate_declaration()
        }
        #[doc = "Returns the node if it is of type `foreign_mod_item` ([`ForeignModItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_foreign_mod_item(self) -> Option<ForeignModItem<'tree>> {
            self.as_declaration_statement()?.as_foreign_mod_item()
        }
        #[doc = "Returns the node if it is of type `function_item` ([`FunctionItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_function_item(self) -> Option<FunctionItem<'tree>> {
            self.as_declaration_statement()?.as_function_item()
        }
        #[doc = "Returns the node if it is of type `function_signature_item` ([`FunctionSignatureItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_function_signature_item(self) -> Option<FunctionSignatureItem<'tree>> {
            self.as_declaration_statement()?
                .as_function_signature_item()
        }
        #[doc = "Returns the node if it is of type `impl_item` ([`ImplItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_impl_item(self) -> Option<ImplItem<'tree>> {
            self.as_declaration_statement()?.as_impl_item()
        }
        #[doc = "Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_inner_attribute_item(self) -> Option<InnerAttributeItem<'tree>> {
            self.as_declaration_statement()?.as_inner_attribute_item()
        }
        #[doc = "Returns the node if it is of type `let_declaration` ([`LetDeclaration`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_let_declaration(self) -> Option<LetDeclaration<'tree>> {
            self.as_declaration_statement()?.as_let_declaration()
        }
        #[doc = "Returns the node if it is of type `macro_definition` ([`MacroDefinition`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_macro_definition(self) -> Option<MacroDefinition<'tree>> {
            self.as_declaration_statement()?.as_macro_definition()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_declaration_statement()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `mod_item` ([`ModItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_mod_item(self) -> Option<ModItem<'tree>> {
            self.as_declaration_statement()?.as_mod_item()
        }
        #[doc = "Returns the node if it is of type `static_item` ([`StaticItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_static_item(self) -> Option<StaticItem<'tree>> {
            self.as_declaration_statement()?.as_static_item()
        }
        #[doc = "Returns the node if it is of type `struct_item` ([`StructItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_struct_item(self) -> Option<StructItem<'tree>> {
            self.as_declaration_statement()?.as_struct_item()
        }
        #[doc = "Returns the node if it is of type `trait_item` ([`TraitItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_trait_item(self) -> Option<TraitItem<'tree>> {
            self.as_declaration_statement()?.as_trait_item()
        }
        #[doc = "Returns the node if it is of type `type_item` ([`TypeItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_type_item(self) -> Option<TypeItem<'tree>> {
            self.as_declaration_statement()?.as_type_item()
        }
        #[doc = "Returns the node if it is of type `union_item` ([`UnionItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_union_item(self) -> Option<UnionItem<'tree>> {
            self.as_declaration_statement()?.as_union_item()
        }
        #[doc = "Returns the node if it is of type `use_declaration` ([`UseDeclaration`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_use_declaration(self) -> Option<UseDeclaration<'tree>> {
            self.as_declaration_statement()?.as_use_declaration()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for DeclarationStatement_ExpressionStatement_Shebang<'tree> {
        type WithLifetime<'a> = DeclarationStatement_ExpressionStatement_Shebang<'a>;
        const KIND: &'static str = "{_declaration_statement | expression_statement | shebang}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) =
                <DeclarationStatement<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::DeclarationStatement(this));
            }
            if let Ok(this) =
                <ExpressionStatement<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::ExpressionStatement(this));
            }
            if let Ok(this) = <Shebang<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Shebang(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => type_sitter::Node::raw(x),
                Self::ExpressionStatement(x) => type_sitter::Node::raw(x),
                Self::Shebang(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => type_sitter::Node::raw_mut(x),
                Self::ExpressionStatement(x) => type_sitter::Node::raw_mut(x),
                Self::Shebang(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => x.into_raw(),
                Self::ExpressionStatement(x) => x.into_raw(),
                Self::Shebang(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_declaration_statement | _expression | expression_statement | label}`:\n- [`DeclarationStatement`]\n- [`Expression`]\n- [`ExpressionStatement`]\n- [`Label`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum DeclarationStatement_Expression_ExpressionStatement_Label<'tree> {
        DeclarationStatement(DeclarationStatement<'tree>),
        Expression(Expression<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
        Label(Label<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DeclarationStatement_Expression_ExpressionStatement_Label<'tree> {
        #[doc = "Returns the node if it is of type `_declaration_statement` ([`DeclarationStatement`]), otherwise returns `None`"]
        #[inline]
        pub fn as_declaration_statement(self) -> Option<DeclarationStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DeclarationStatement(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression(self) -> Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression_statement(self) -> Option<ExpressionStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExpressionStatement(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `label` ([`Label`]), otherwise returns `None`"]
        #[inline]
        pub fn as_label(self) -> Option<Label<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Label(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `associated_type` ([`AssociatedType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_associated_type(self) -> Option<AssociatedType<'tree>> {
            self.as_declaration_statement()?.as_associated_type()
        }
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            self.as_declaration_statement()?.as_attribute_item()
        }
        #[doc = "Returns the node if it is of type `const_item` ([`ConstItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_const_item(self) -> Option<ConstItem<'tree>> {
            self.as_declaration_statement()?.as_const_item()
        }
        #[doc = "Returns the node if it is of type `empty_statement` ([`EmptyStatement`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_empty_statement(self) -> Option<EmptyStatement<'tree>> {
            self.as_declaration_statement()?.as_empty_statement()
        }
        #[doc = "Returns the node if it is of type `enum_item` ([`EnumItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_enum_item(self) -> Option<EnumItem<'tree>> {
            self.as_declaration_statement()?.as_enum_item()
        }
        #[doc = "Returns the node if it is of type `extern_crate_declaration` ([`ExternCrateDeclaration`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_extern_crate_declaration(self) -> Option<ExternCrateDeclaration<'tree>> {
            self.as_declaration_statement()?
                .as_extern_crate_declaration()
        }
        #[doc = "Returns the node if it is of type `foreign_mod_item` ([`ForeignModItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_foreign_mod_item(self) -> Option<ForeignModItem<'tree>> {
            self.as_declaration_statement()?.as_foreign_mod_item()
        }
        #[doc = "Returns the node if it is of type `function_item` ([`FunctionItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_function_item(self) -> Option<FunctionItem<'tree>> {
            self.as_declaration_statement()?.as_function_item()
        }
        #[doc = "Returns the node if it is of type `function_signature_item` ([`FunctionSignatureItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_function_signature_item(self) -> Option<FunctionSignatureItem<'tree>> {
            self.as_declaration_statement()?
                .as_function_signature_item()
        }
        #[doc = "Returns the node if it is of type `impl_item` ([`ImplItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_impl_item(self) -> Option<ImplItem<'tree>> {
            self.as_declaration_statement()?.as_impl_item()
        }
        #[doc = "Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_inner_attribute_item(self) -> Option<InnerAttributeItem<'tree>> {
            self.as_declaration_statement()?.as_inner_attribute_item()
        }
        #[doc = "Returns the node if it is of type `let_declaration` ([`LetDeclaration`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_let_declaration(self) -> Option<LetDeclaration<'tree>> {
            self.as_declaration_statement()?.as_let_declaration()
        }
        #[doc = "Returns the node if it is of type `macro_definition` ([`MacroDefinition`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_macro_definition(self) -> Option<MacroDefinition<'tree>> {
            self.as_declaration_statement()?.as_macro_definition()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_declaration_statement()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `mod_item` ([`ModItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_mod_item(self) -> Option<ModItem<'tree>> {
            self.as_declaration_statement()?.as_mod_item()
        }
        #[doc = "Returns the node if it is of type `static_item` ([`StaticItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_static_item(self) -> Option<StaticItem<'tree>> {
            self.as_declaration_statement()?.as_static_item()
        }
        #[doc = "Returns the node if it is of type `struct_item` ([`StructItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_struct_item(self) -> Option<StructItem<'tree>> {
            self.as_declaration_statement()?.as_struct_item()
        }
        #[doc = "Returns the node if it is of type `trait_item` ([`TraitItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_trait_item(self) -> Option<TraitItem<'tree>> {
            self.as_declaration_statement()?.as_trait_item()
        }
        #[doc = "Returns the node if it is of type `type_item` ([`TypeItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_type_item(self) -> Option<TypeItem<'tree>> {
            self.as_declaration_statement()?.as_type_item()
        }
        #[doc = "Returns the node if it is of type `union_item` ([`UnionItem`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_union_item(self) -> Option<UnionItem<'tree>> {
            self.as_declaration_statement()?.as_union_item()
        }
        #[doc = "Returns the node if it is of type `use_declaration` ([`UseDeclaration`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))"]
        #[inline]
        pub fn as_use_declaration(self) -> Option<UseDeclaration<'tree>> {
            self.as_declaration_statement()?.as_use_declaration()
        }
        #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_literal(self) -> Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        #[doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_array_expression(self) -> Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        #[doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        #[doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_async_block(self) -> Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        #[doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_await_expression(self) -> Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        #[doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_binary_expression(self) -> Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        #[doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_break_expression(self) -> Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        #[doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_call_expression(self) -> Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        #[doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_compound_assignment_expr(self) -> Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_continue_expression(self) -> Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        #[doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_for_expression(self) -> Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        #[doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_generic_function(self) -> Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        #[doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_index_expression(self) -> Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        #[doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_loop_expression(self) -> Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_macro_invocation_(self) -> Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_match_expression(self) -> Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        #[doc = "Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_range_expression(self) -> Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        #[doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_reference_expression(self) -> Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        #[doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_return_expression(self) -> Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        #[doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_struct_expression(self) -> Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        #[doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_block(self) -> Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        #[doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_expression(self) -> Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        #[doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_tuple_expression(self) -> Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        #[doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_type_cast_expression(self) -> Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        #[doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unary_expression(self) -> Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        #[doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unit_expression(self) -> Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        #[doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unsafe_block(self) -> Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        #[doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_while_expression(self) -> Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        #[doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_yield_expression(self) -> Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for DeclarationStatement_Expression_ExpressionStatement_Label<'tree>
    {
        type WithLifetime<'a> = DeclarationStatement_Expression_ExpressionStatement_Label<'a>;
        const KIND: &'static str =
            "{_declaration_statement | _expression | expression_statement | label}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) =
                <DeclarationStatement<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::DeclarationStatement(this));
            }
            if let Ok(this) = <Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) =
                <ExpressionStatement<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::ExpressionStatement(this));
            }
            if let Ok(this) = <Label<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Label(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => type_sitter::Node::raw(x),
                Self::Expression(x) => type_sitter::Node::raw(x),
                Self::ExpressionStatement(x) => type_sitter::Node::raw(x),
                Self::Label(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => type_sitter::Node::raw_mut(x),
                Self::Expression(x) => type_sitter::Node::raw_mut(x),
                Self::ExpressionStatement(x) => type_sitter::Node::raw_mut(x),
                Self::Label(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
                Self::ExpressionStatement(x) => x.into_raw(),
                Self::Label(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{escape_sequence | string_content}`:\n- [`EscapeSequence`]\n- [`StringContent`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EscapeSequence_StringContent<'tree> {
        EscapeSequence(EscapeSequence<'tree>),
        StringContent(StringContent<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EscapeSequence_StringContent<'tree> {
        #[doc = "Returns the node if it is of type `escape_sequence` ([`EscapeSequence`]), otherwise returns `None`"]
        #[inline]
        pub fn as_escape_sequence(self) -> Option<EscapeSequence<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EscapeSequence(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `string_content` ([`StringContent`]), otherwise returns `None`"]
        #[inline]
        pub fn as_string_content(self) -> Option<StringContent<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StringContent(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for EscapeSequence_StringContent<'tree> {
        type WithLifetime<'a> = EscapeSequence_StringContent<'a>;
        const KIND: &'static str = "{escape_sequence | string_content}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "escape_sequence" => Ok(unsafe {
                    Self::EscapeSequence(
                        <EscapeSequence<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "string_content" => Ok(unsafe {
                    Self::StringContent(
                        <StringContent<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => type_sitter::Node::raw(x),
                Self::StringContent(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => type_sitter::Node::raw_mut(x),
                Self::StringContent(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.into_raw(),
                Self::StringContent(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_expression | attribute_item}`:\n- [`Expression`]\n- [`AttributeItem`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_AttributeItem<'tree> {
        Expression(Expression<'tree>),
        AttributeItem(AttributeItem<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_AttributeItem<'tree> {
        #[doc = "Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression(self) -> Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_literal(self) -> Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        #[doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_array_expression(self) -> Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        #[doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        #[doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_async_block(self) -> Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        #[doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_await_expression(self) -> Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        #[doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_binary_expression(self) -> Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        #[doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_break_expression(self) -> Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        #[doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_call_expression(self) -> Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        #[doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_compound_assignment_expr(self) -> Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_continue_expression(self) -> Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        #[doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_for_expression(self) -> Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        #[doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_generic_function(self) -> Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        #[doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_index_expression(self) -> Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        #[doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_loop_expression(self) -> Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_match_expression(self) -> Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        #[doc = "Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_range_expression(self) -> Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        #[doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_reference_expression(self) -> Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        #[doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_return_expression(self) -> Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        #[doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_struct_expression(self) -> Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        #[doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_block(self) -> Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        #[doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_expression(self) -> Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        #[doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_tuple_expression(self) -> Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        #[doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_type_cast_expression(self) -> Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        #[doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unary_expression(self) -> Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        #[doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unit_expression(self) -> Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        #[doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unsafe_block(self) -> Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        #[doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_while_expression(self) -> Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        #[doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_yield_expression(self) -> Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Expression_AttributeItem<'tree> {
        type WithLifetime<'a> = Expression_AttributeItem<'a>;
        const KIND: &'static str = "{_expression | attribute_item}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <AttributeItem<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::AttributeItem(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw(x),
                Self::AttributeItem(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw_mut(x),
                Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::AttributeItem(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_expression | label}`:\n- [`Expression`]\n- [`Label`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_Label<'tree> {
        Expression(Expression<'tree>),
        Label(Label<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_Label<'tree> {
        #[doc = "Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression(self) -> Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `label` ([`Label`]), otherwise returns `None`"]
        #[inline]
        pub fn as_label(self) -> Option<Label<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Label(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_literal(self) -> Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        #[doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_array_expression(self) -> Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        #[doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        #[doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_async_block(self) -> Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        #[doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_await_expression(self) -> Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        #[doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_binary_expression(self) -> Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        #[doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_break_expression(self) -> Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        #[doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_call_expression(self) -> Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        #[doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_compound_assignment_expr(self) -> Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_continue_expression(self) -> Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        #[doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_for_expression(self) -> Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        #[doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_generic_function(self) -> Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        #[doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_index_expression(self) -> Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        #[doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_loop_expression(self) -> Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_match_expression(self) -> Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        #[doc = "Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_range_expression(self) -> Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        #[doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_reference_expression(self) -> Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        #[doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_return_expression(self) -> Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        #[doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_struct_expression(self) -> Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        #[doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_block(self) -> Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        #[doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_expression(self) -> Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        #[doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_tuple_expression(self) -> Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        #[doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_type_cast_expression(self) -> Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        #[doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unary_expression(self) -> Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        #[doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unit_expression(self) -> Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        #[doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unsafe_block(self) -> Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        #[doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_while_expression(self) -> Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        #[doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_yield_expression(self) -> Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Expression_Label<'tree> {
        type WithLifetime<'a> = Expression_Label<'a>;
        const KIND: &'static str = "{_expression | label}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <Label<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Label(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw(x),
                Self::Label(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw_mut(x),
                Self::Label(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::Label(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_expression | let_chain | let_condition}`:\n- [`Expression`]\n- [`LetChain`]\n- [`LetCondition`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_LetChain_LetCondition<'tree> {
        Expression(Expression<'tree>),
        LetChain(LetChain<'tree>),
        LetCondition(LetCondition<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_LetChain_LetCondition<'tree> {
        #[doc = "Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression(self) -> Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `let_chain` ([`LetChain`]), otherwise returns `None`"]
        #[inline]
        pub fn as_let_chain(self) -> Option<LetChain<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LetChain(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `let_condition` ([`LetCondition`]), otherwise returns `None`"]
        #[inline]
        pub fn as_let_condition(self) -> Option<LetCondition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LetCondition(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_literal(self) -> Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        #[doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_array_expression(self) -> Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        #[doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        #[doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_async_block(self) -> Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        #[doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_await_expression(self) -> Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        #[doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_binary_expression(self) -> Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        #[doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_break_expression(self) -> Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        #[doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_call_expression(self) -> Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        #[doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_compound_assignment_expr(self) -> Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_continue_expression(self) -> Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        #[doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_for_expression(self) -> Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        #[doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_generic_function(self) -> Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        #[doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_index_expression(self) -> Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        #[doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_loop_expression(self) -> Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_match_expression(self) -> Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        #[doc = "Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_range_expression(self) -> Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        #[doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_reference_expression(self) -> Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        #[doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_return_expression(self) -> Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        #[doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_struct_expression(self) -> Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        #[doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_block(self) -> Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        #[doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_expression(self) -> Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        #[doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_tuple_expression(self) -> Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        #[doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_type_cast_expression(self) -> Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        #[doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unary_expression(self) -> Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        #[doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unit_expression(self) -> Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        #[doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unsafe_block(self) -> Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        #[doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_while_expression(self) -> Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        #[doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_yield_expression(self) -> Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Expression_LetChain_LetCondition<'tree> {
        type WithLifetime<'a> = Expression_LetChain_LetCondition<'a>;
        const KIND: &'static str = "{_expression | let_chain | let_condition}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <LetChain<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LetChain(this));
            }
            if let Ok(this) = <LetCondition<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::LetCondition(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw(x),
                Self::LetChain(x) => type_sitter::Node::raw(x),
                Self::LetCondition(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw_mut(x),
                Self::LetChain(x) => type_sitter::Node::raw_mut(x),
                Self::LetCondition(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::LetChain(x) => x.into_raw(),
                Self::LetCondition(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_expression | let_condition}`:\n- [`Expression`]\n- [`LetCondition`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_LetCondition<'tree> {
        Expression(Expression<'tree>),
        LetCondition(LetCondition<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_LetCondition<'tree> {
        #[doc = "Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression(self) -> Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `let_condition` ([`LetCondition`]), otherwise returns `None`"]
        #[inline]
        pub fn as_let_condition(self) -> Option<LetCondition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LetCondition(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_literal(self) -> Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        #[doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_array_expression(self) -> Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        #[doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        #[doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_async_block(self) -> Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        #[doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_await_expression(self) -> Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        #[doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_binary_expression(self) -> Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        #[doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_break_expression(self) -> Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        #[doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_call_expression(self) -> Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        #[doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_compound_assignment_expr(self) -> Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_continue_expression(self) -> Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        #[doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_for_expression(self) -> Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        #[doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_generic_function(self) -> Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        #[doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_index_expression(self) -> Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        #[doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_loop_expression(self) -> Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_match_expression(self) -> Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        #[doc = "Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_range_expression(self) -> Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        #[doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_reference_expression(self) -> Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        #[doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_return_expression(self) -> Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        #[doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_struct_expression(self) -> Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        #[doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_block(self) -> Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        #[doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_expression(self) -> Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        #[doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_tuple_expression(self) -> Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        #[doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_type_cast_expression(self) -> Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        #[doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unary_expression(self) -> Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        #[doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unit_expression(self) -> Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        #[doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unsafe_block(self) -> Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        #[doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_while_expression(self) -> Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        #[doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_yield_expression(self) -> Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Expression_LetCondition<'tree> {
        type WithLifetime<'a> = Expression_LetCondition<'a>;
        const KIND: &'static str = "{_expression | let_condition}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <LetCondition<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::LetCondition(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw(x),
                Self::LetCondition(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => type_sitter::Node::raw_mut(x),
                Self::LetCondition(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::LetCondition(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{extern_modifier | visibility_modifier}`:\n- [`ExternModifier`]\n- [`VisibilityModifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ExternModifier_VisibilityModifier<'tree> {
        ExternModifier(ExternModifier<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ExternModifier_VisibilityModifier<'tree> {
        #[doc = "Returns the node if it is of type `extern_modifier` ([`ExternModifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_extern_modifier(self) -> Option<ExternModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExternModifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_visibility_modifier(self) -> Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ExternModifier_VisibilityModifier<'tree> {
        type WithLifetime<'a> = ExternModifier_VisibilityModifier<'a>;
        const KIND: &'static str = "{extern_modifier | visibility_modifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "extern_modifier" => Ok(unsafe {
                    Self::ExternModifier(
                        <ExternModifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "visibility_modifier" => Ok(unsafe {
                    Self::VisibilityModifier(<VisibilityModifier<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::ExternModifier(x) => type_sitter::Node::raw(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::ExternModifier(x) => type_sitter::Node::raw_mut(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::ExternModifier(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{field_declaration_list | ordered_field_declaration_list}`:\n- [`FieldDeclarationList`]\n- [`OrderedFieldDeclarationList`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldDeclarationList_OrderedFieldDeclarationList<'tree> {
        FieldDeclarationList(FieldDeclarationList<'tree>),
        OrderedFieldDeclarationList(OrderedFieldDeclarationList<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldDeclarationList_OrderedFieldDeclarationList<'tree> {
        #[doc = "Returns the node if it is of type `field_declaration_list` ([`FieldDeclarationList`]), otherwise returns `None`"]
        #[inline]
        pub fn as_field_declaration_list(self) -> Option<FieldDeclarationList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclarationList(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `ordered_field_declaration_list` ([`OrderedFieldDeclarationList`]), otherwise returns `None`"]
        #[inline]
        pub fn as_ordered_field_declaration_list(
            self,
        ) -> Option<OrderedFieldDeclarationList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrderedFieldDeclarationList(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for FieldDeclarationList_OrderedFieldDeclarationList<'tree> {
        type WithLifetime<'a> = FieldDeclarationList_OrderedFieldDeclarationList<'a>;
        const KIND: &'static str = "{field_declaration_list | ordered_field_declaration_list}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "field_declaration_list" => {
                    Ok(unsafe {
                        Self :: FieldDeclarationList (< FieldDeclarationList < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "ordered_field_declaration_list" => Ok(unsafe {
                    Self :: OrderedFieldDeclarationList (< OrderedFieldDeclarationList < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldDeclarationList(x) => type_sitter::Node::raw(x),
                Self::OrderedFieldDeclarationList(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldDeclarationList(x) => type_sitter::Node::raw_mut(x),
                Self::OrderedFieldDeclarationList(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldDeclarationList(x) => x.into_raw(),
                Self::OrderedFieldDeclarationList(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{field_expression | identifier | scoped_identifier}`:\n- [`FieldExpression`]\n- [`Identifier`]\n- [`ScopedIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldExpression_Identifier_ScopedIdentifier<'tree> {
        FieldExpression(FieldExpression<'tree>),
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldExpression_Identifier_ScopedIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldExpression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for FieldExpression_Identifier_ScopedIdentifier<'tree> {
        type WithLifetime<'a> = FieldExpression_Identifier_ScopedIdentifier<'a>;
        const KIND: &'static str = "{field_expression | identifier | scoped_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "field_expression" => {
                    Ok(unsafe {
                        Self::FieldExpression(<FieldExpression<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "scoped_identifier" => {
                    Ok(unsafe {
                        Self::ScopedIdentifier(<ScopedIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldExpression(x) => type_sitter::Node::raw(x),
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldExpression(x) => type_sitter::Node::raw_mut(x),
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldExpression(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{field_identifier | integer_literal}`:\n- [`FieldIdentifier`]\n- [`IntegerLiteral`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldIdentifier_IntegerLiteral<'tree> {
        FieldIdentifier(FieldIdentifier<'tree>),
        IntegerLiteral(IntegerLiteral<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldIdentifier_IntegerLiteral<'tree> {
        #[doc = "Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_field_identifier(self) -> Option<FieldIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IntegerLiteral(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for FieldIdentifier_IntegerLiteral<'tree> {
        type WithLifetime<'a> = FieldIdentifier_IntegerLiteral<'a>;
        const KIND: &'static str = "{field_identifier | integer_literal}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "field_identifier" => {
                    Ok(unsafe {
                        Self::FieldIdentifier(<FieldIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "integer_literal" => Ok(unsafe {
                    Self::IntegerLiteral(
                        <IntegerLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => type_sitter::Node::raw(x),
                Self::IntegerLiteral(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::IntegerLiteral(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => x.into_raw(),
                Self::IntegerLiteral(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{field_identifier | shorthand_field_identifier}`:\n- [`FieldIdentifier`]\n- [`ShorthandFieldIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldIdentifier_ShorthandFieldIdentifier<'tree> {
        FieldIdentifier(FieldIdentifier<'tree>),
        ShorthandFieldIdentifier(ShorthandFieldIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldIdentifier_ShorthandFieldIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_field_identifier(self) -> Option<FieldIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `shorthand_field_identifier` ([`ShorthandFieldIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_shorthand_field_identifier(self) -> Option<ShorthandFieldIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ShorthandFieldIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for FieldIdentifier_ShorthandFieldIdentifier<'tree> {
        type WithLifetime<'a> = FieldIdentifier_ShorthandFieldIdentifier<'a>;
        const KIND: &'static str = "{field_identifier | shorthand_field_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "field_identifier" => {
                    Ok(unsafe {
                        Self::FieldIdentifier(<FieldIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "shorthand_field_identifier" => Ok(unsafe {
                    Self :: ShorthandFieldIdentifier (< ShorthandFieldIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => type_sitter::Node::raw(x),
                Self::ShorthandFieldIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::ShorthandFieldIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => x.into_raw(),
                Self::ShorthandFieldIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{field_pattern | remaining_field_pattern}`:\n- [`FieldPattern`]\n- [`RemainingFieldPattern`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldPattern_RemainingFieldPattern<'tree> {
        FieldPattern(FieldPattern<'tree>),
        RemainingFieldPattern(RemainingFieldPattern<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldPattern_RemainingFieldPattern<'tree> {
        #[doc = "Returns the node if it is of type `field_pattern` ([`FieldPattern`]), otherwise returns `None`"]
        #[inline]
        pub fn as_field_pattern(self) -> Option<FieldPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldPattern(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`"]
        #[inline]
        pub fn as_remaining_field_pattern(self) -> Option<RemainingFieldPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::RemainingFieldPattern(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for FieldPattern_RemainingFieldPattern<'tree> {
        type WithLifetime<'a> = FieldPattern_RemainingFieldPattern<'a>;
        const KIND: &'static str = "{field_pattern | remaining_field_pattern}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "field_pattern" => Ok(unsafe {
                    Self::FieldPattern(
                        <FieldPattern<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "remaining_field_pattern" => Ok(unsafe {
                    Self :: RemainingFieldPattern (< RemainingFieldPattern < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldPattern(x) => type_sitter::Node::raw(x),
                Self::RemainingFieldPattern(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldPattern(x) => type_sitter::Node::raw_mut(x),
                Self::RemainingFieldPattern(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FieldPattern(x) => x.into_raw(),
                Self::RemainingFieldPattern(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{float_literal | integer_literal}`:\n- [`FloatLiteral`]\n- [`IntegerLiteral`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FloatLiteral_IntegerLiteral<'tree> {
        FloatLiteral(FloatLiteral<'tree>),
        IntegerLiteral(IntegerLiteral<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FloatLiteral_IntegerLiteral<'tree> {
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FloatLiteral(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IntegerLiteral(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for FloatLiteral_IntegerLiteral<'tree> {
        type WithLifetime<'a> = FloatLiteral_IntegerLiteral<'a>;
        const KIND: &'static str = "{float_literal | integer_literal}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "float_literal" => Ok(unsafe {
                    Self::FloatLiteral(
                        <FloatLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "integer_literal" => Ok(unsafe {
                    Self::IntegerLiteral(
                        <IntegerLiteral<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FloatLiteral(x) => type_sitter::Node::raw(x),
                Self::IntegerLiteral(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FloatLiteral(x) => type_sitter::Node::raw_mut(x),
                Self::IntegerLiteral(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FloatLiteral(x) => x.into_raw(),
                Self::IntegerLiteral(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{for_lifetimes | function_modifiers}`:\n- [`ForLifetimes`]\n- [`FunctionModifiers`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ForLifetimes_FunctionModifiers<'tree> {
        ForLifetimes(ForLifetimes<'tree>),
        FunctionModifiers(FunctionModifiers<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ForLifetimes_FunctionModifiers<'tree> {
        #[doc = "Returns the node if it is of type `for_lifetimes` ([`ForLifetimes`]), otherwise returns `None`"]
        #[inline]
        pub fn as_for_lifetimes(self) -> Option<ForLifetimes<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ForLifetimes(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `function_modifiers` ([`FunctionModifiers`]), otherwise returns `None`"]
        #[inline]
        pub fn as_function_modifiers(self) -> Option<FunctionModifiers<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionModifiers(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ForLifetimes_FunctionModifiers<'tree> {
        type WithLifetime<'a> = ForLifetimes_FunctionModifiers<'a>;
        const KIND: &'static str = "{for_lifetimes | function_modifiers}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "for_lifetimes" => Ok(unsafe {
                    Self::ForLifetimes(
                        <ForLifetimes<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "function_modifiers" => Ok(unsafe {
                    Self::FunctionModifiers(<FunctionModifiers<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::ForLifetimes(x) => type_sitter::Node::raw(x),
                Self::FunctionModifiers(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::ForLifetimes(x) => type_sitter::Node::raw_mut(x),
                Self::FunctionModifiers(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::ForLifetimes(x) => x.into_raw(),
                Self::FunctionModifiers(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{function_modifiers | visibility_modifier | where_clause}`:\n- [`FunctionModifiers`]\n- [`VisibilityModifier`]\n- [`WhereClause`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FunctionModifiers_VisibilityModifier_WhereClause<'tree> {
        FunctionModifiers(FunctionModifiers<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
        WhereClause(WhereClause<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FunctionModifiers_VisibilityModifier_WhereClause<'tree> {
        #[doc = "Returns the node if it is of type `function_modifiers` ([`FunctionModifiers`]), otherwise returns `None`"]
        #[inline]
        pub fn as_function_modifiers(self) -> Option<FunctionModifiers<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionModifiers(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_visibility_modifier(self) -> Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `where_clause` ([`WhereClause`]), otherwise returns `None`"]
        #[inline]
        pub fn as_where_clause(self) -> Option<WhereClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::WhereClause(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for FunctionModifiers_VisibilityModifier_WhereClause<'tree> {
        type WithLifetime<'a> = FunctionModifiers_VisibilityModifier_WhereClause<'a>;
        const KIND: &'static str = "{function_modifiers | visibility_modifier | where_clause}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "function_modifiers" => Ok(unsafe {
                    Self::FunctionModifiers(<FunctionModifiers<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                "visibility_modifier" => Ok(unsafe {
                    Self::VisibilityModifier(<VisibilityModifier<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                "where_clause" => Ok(unsafe {
                    Self::WhereClause(
                        <WhereClause<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionModifiers(x) => type_sitter::Node::raw(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw(x),
                Self::WhereClause(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionModifiers(x) => type_sitter::Node::raw_mut(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw_mut(x),
                Self::WhereClause(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionModifiers(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
                Self::WhereClause(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}`:\n- [`FunctionType`]\n- [`GenericType`]\n- [`HigherRankedTraitBound`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
        'tree,
    > {
        FunctionType(FunctionType<'tree>),
        GenericType(GenericType<'tree>),
        HigherRankedTraitBound(HigherRankedTraitBound<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree>
        FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<'tree>
    {
        #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `higher_ranked_trait_bound` ([`HigherRankedTraitBound`]), otherwise returns `None`"]
        #[inline]
        pub fn as_higher_ranked_trait_bound(self) -> Option<HigherRankedTraitBound<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::HigherRankedTraitBound(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
            'tree,
        >
    {
        type WithLifetime<'a> =
            FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<'a>;
        const KIND : & 'static str = "{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}" ;
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "function_type" => Ok(unsafe {
                    Self::FunctionType(
                        <FunctionType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "generic_type" => Ok(unsafe {
                    Self::GenericType(
                        <GenericType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "higher_ranked_trait_bound" => Ok(unsafe {
                    Self :: HigherRankedTraitBound (< HigherRankedTraitBound < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                }),
                "scoped_type_identifier" => {
                    Ok(unsafe {
                        Self :: ScopedTypeIdentifier (< ScopedTypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionType(x) => type_sitter::Node::raw(x),
                Self::GenericType(x) => type_sitter::Node::raw(x),
                Self::HigherRankedTraitBound(x) => type_sitter::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionType(x) => type_sitter::Node::raw_mut(x),
                Self::GenericType(x) => type_sitter::Node::raw_mut(x),
                Self::HigherRankedTraitBound(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionType(x) => x.into_raw(),
                Self::GenericType(x) => x.into_raw(),
                Self::HigherRankedTraitBound(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}`:\n- [`FunctionType`]\n- [`GenericType`]\n- [`RemovedTraitBound`]\n- [`ScopedTypeIdentifier`]\n- [`TupleType`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        FunctionType(FunctionType<'tree>),
        GenericType(GenericType<'tree>),
        RemovedTraitBound(RemovedTraitBound<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TupleType(TupleType<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree>
        FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
            'tree,
        >
    {
        #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`"]
        #[inline]
        pub fn as_removed_trait_bound(self) -> Option<RemovedTraitBound<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::RemovedTraitBound(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_tuple_type(self) -> Option<TupleType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TupleType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
            'tree,
        >
    {
        type WithLifetime < 'a > = FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier < 'a > ;
        const KIND : & 'static str = "{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}" ;
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "function_type" => Ok(unsafe {
                    Self::FunctionType(
                        <FunctionType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "generic_type" => Ok(unsafe {
                    Self::GenericType(
                        <GenericType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "removed_trait_bound" => Ok(unsafe {
                    Self::RemovedTraitBound(<RemovedTraitBound<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                "scoped_type_identifier" => {
                    Ok(unsafe {
                        Self :: ScopedTypeIdentifier (< ScopedTypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "tuple_type" => Ok(unsafe {
                    Self::TupleType(
                        <TupleType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionType(x) => type_sitter::Node::raw(x),
                Self::GenericType(x) => type_sitter::Node::raw(x),
                Self::RemovedTraitBound(x) => type_sitter::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw(x),
                Self::TupleType(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionType(x) => type_sitter::Node::raw_mut(x),
                Self::GenericType(x) => type_sitter::Node::raw_mut(x),
                Self::RemovedTraitBound(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::TupleType(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::FunctionType(x) => x.into_raw(),
                Self::GenericType(x) => x.into_raw(),
                Self::RemovedTraitBound(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TupleType(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{generic_type_with_turbofish | scoped_type_identifier | type_identifier}`:\n- [`GenericTypeWithTurbofish`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        GenericTypeWithTurbofish(GenericTypeWithTurbofish<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `generic_type_with_turbofish` ([`GenericTypeWithTurbofish`]), otherwise returns `None`"]
        #[inline]
        pub fn as_generic_type_with_turbofish(self) -> Option<GenericTypeWithTurbofish<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericTypeWithTurbofish(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree>
    {
        type WithLifetime<'a> = GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str =
            "{generic_type_with_turbofish | scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "generic_type_with_turbofish" => Ok(unsafe {
                    Self :: GenericTypeWithTurbofish (< GenericTypeWithTurbofish < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                }),
                "scoped_type_identifier" => {
                    Ok(unsafe {
                        Self :: ScopedTypeIdentifier (< ScopedTypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericTypeWithTurbofish(x) => type_sitter::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericTypeWithTurbofish(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericTypeWithTurbofish(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{generic_type | identifier | scoped_identifier}`:\n- [`GenericType`]\n- [`Identifier`]\n- [`ScopedIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum GenericType_Identifier_ScopedIdentifier<'tree> {
        GenericType(GenericType<'tree>),
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GenericType_Identifier_ScopedIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for GenericType_Identifier_ScopedIdentifier<'tree> {
        type WithLifetime<'a> = GenericType_Identifier_ScopedIdentifier<'a>;
        const KIND: &'static str = "{generic_type | identifier | scoped_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "generic_type" => Ok(unsafe {
                    Self::GenericType(
                        <GenericType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "scoped_identifier" => {
                    Ok(unsafe {
                        Self::ScopedIdentifier(<ScopedIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericType(x) => type_sitter::Node::raw(x),
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericType(x) => type_sitter::Node::raw_mut(x),
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericType(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{generic_type | scoped_type_identifier | type_identifier}`:\n- [`GenericType`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        GenericType(GenericType<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = GenericType_ScopedTypeIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str = "{generic_type | scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "generic_type" => Ok(unsafe {
                    Self::GenericType(
                        <GenericType<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "scoped_type_identifier" => {
                    Ok(unsafe {
                        Self :: ScopedTypeIdentifier (< ScopedTypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericType(x) => type_sitter::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericType(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::GenericType(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{identifier | metavariable}`:\n- [`Identifier`]\n- [`Metavariable`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_Metavariable<'tree> {
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_Metavariable<'tree> {
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Identifier_Metavariable<'tree> {
        type WithLifetime<'a> = Identifier_Metavariable<'a>;
        const KIND: &'static str = "{identifier | metavariable}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "metavariable" => Ok(unsafe {
                    Self::Metavariable(
                        <Metavariable<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::Metavariable(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::Metavariable(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{identifier | scoped_identifier}`:\n- [`Identifier`]\n- [`ScopedIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_ScopedIdentifier<'tree> {
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_ScopedIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Identifier_ScopedIdentifier<'tree> {
        type WithLifetime<'a> = Identifier_ScopedIdentifier<'a>;
        const KIND: &'static str = "{identifier | scoped_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "scoped_identifier" => {
                    Ok(unsafe {
                        Self::ScopedIdentifier(<ScopedIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{identifier | scoped_identifier | scoped_type_identifier | type_identifier}`:\n- [`Identifier`]\n- [`ScopedIdentifier`]\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'tree>
    {
        type WithLifetime<'a> = Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str =
            "{identifier | scoped_identifier | scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "scoped_identifier" => {
                    Ok(unsafe {
                        Self::ScopedIdentifier(<ScopedIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "scoped_type_identifier" => {
                    Ok(unsafe {
                        Self :: ScopedTypeIdentifier (< ScopedTypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{identifier | super}`:\n- [`Identifier`]\n- [`Super`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_Super<'tree> {
        Identifier(Identifier<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_Super<'tree> {
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`"]
        #[inline]
        pub fn as_super(self) -> Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Identifier_Super<'tree> {
        type WithLifetime<'a> = Identifier_Super<'a>;
        const KIND: &'static str = "{identifier | super}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "identifier" => Ok(unsafe {
                    Self::Identifier(
                        <Identifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "super" => Ok(unsafe {
                    Self::Super(
                        <Super<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::Super(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::Super(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{lifetime | mutable_specifier}`:\n- [`Lifetime`]\n- [`MutableSpecifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Lifetime_MutableSpecifier<'tree> {
        Lifetime(Lifetime<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime_MutableSpecifier<'tree> {
        #[doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lifetime(self) -> Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mutable_specifier(self) -> Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Lifetime_MutableSpecifier<'tree> {
        type WithLifetime<'a> = Lifetime_MutableSpecifier<'a>;
        const KIND: &'static str = "{lifetime | mutable_specifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "lifetime" => Ok(unsafe {
                    Self::Lifetime(
                        <Lifetime<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "mutable_specifier" => {
                    Ok(unsafe {
                        Self::MutableSpecifier(<MutableSpecifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => type_sitter::Node::raw(x),
                Self::MutableSpecifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => type_sitter::Node::raw_mut(x),
                Self::MutableSpecifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{lifetime | mutable_specifier | self}`:\n- [`Lifetime`]\n- [`MutableSpecifier`]\n- [`Self_`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Lifetime_MutableSpecifier_Self_<'tree> {
        Lifetime(Lifetime<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
        Self_(Self_<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime_MutableSpecifier_Self_<'tree> {
        #[doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lifetime(self) -> Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mutable_specifier(self) -> Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Lifetime_MutableSpecifier_Self_<'tree> {
        type WithLifetime<'a> = Lifetime_MutableSpecifier_Self_<'a>;
        const KIND: &'static str = "{lifetime | mutable_specifier | self}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "lifetime" => Ok(unsafe {
                    Self::Lifetime(
                        <Lifetime<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "mutable_specifier" => {
                    Ok(unsafe {
                        Self::MutableSpecifier(<MutableSpecifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "self" => Ok(unsafe {
                    Self::Self_(
                        <Self_<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => type_sitter::Node::raw(x),
                Self::MutableSpecifier(x) => type_sitter::Node::raw(x),
                Self::Self_(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => type_sitter::Node::raw_mut(x),
                Self::MutableSpecifier(x) => type_sitter::Node::raw_mut(x),
                Self::Self_(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{lifetime | type_identifier}`:\n- [`Lifetime`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Lifetime_TypeIdentifier<'tree> {
        Lifetime(Lifetime<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lifetime(self) -> Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Lifetime_TypeIdentifier<'tree> {
        type WithLifetime<'a> = Lifetime_TypeIdentifier<'a>;
        const KIND: &'static str = "{lifetime | type_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "lifetime" => Ok(unsafe {
                    Self::Lifetime(
                        <Lifetime<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Lifetime(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_literal_pattern | crate | identifier | metavariable | scoped_identifier | self | super}`:\n- [`LiteralPattern`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`Super`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        LiteralPattern(LiteralPattern<'tree>),
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        #[doc = "Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`"]
        #[inline]
        pub fn as_literal_pattern(self) -> Option<LiteralPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LiteralPattern(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`"]
        #[inline]
        pub fn as_crate(self) -> Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`"]
        #[inline]
        pub fn as_super(self) -> Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_literal_pattern()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_literal_pattern()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_literal_pattern()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_literal_pattern()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
        #[inline]
        pub fn as_negative_literal(self) -> Option<NegativeLiteral<'tree>> {
            self.as_literal_pattern()?.as_negative_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_literal_pattern()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>
    {
        type WithLifetime<'a> =
            LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'a>;
        const KIND : & 'static str = "{_literal_pattern | crate | identifier | metavariable | scoped_identifier | self | super}" ;
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) =
                <LiteralPattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::LiteralPattern(this));
            }
            if let Ok(this) = <Crate<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <Identifier<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) =
                <ScopedIdentifier<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <Self_<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <Super<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::LiteralPattern(x) => type_sitter::Node::raw(x),
                Self::Crate(x) => type_sitter::Node::raw(x),
                Self::Identifier(x) => type_sitter::Node::raw(x),
                Self::Metavariable(x) => type_sitter::Node::raw(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
                Self::Self_(x) => type_sitter::Node::raw(x),
                Self::Super(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::LiteralPattern(x) => type_sitter::Node::raw_mut(x),
                Self::Crate(x) => type_sitter::Node::raw_mut(x),
                Self::Identifier(x) => type_sitter::Node::raw_mut(x),
                Self::Metavariable(x) => type_sitter::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::Self_(x) => type_sitter::Node::raw_mut(x),
                Self::Super(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::LiteralPattern(x) => x.into_raw(),
                Self::Crate(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}`:\n- [`Literal`]\n- [`ArrayExpression`]\n- [`AssignmentExpression`]\n- [`AsyncBlock`]\n- [`AwaitExpression`]\n- [`BinaryExpression`]\n- [`Block`]\n- [`BreakExpression`]\n- [`CallExpression`]\n- [`ClosureExpression`]\n- [`CompoundAssignmentExpr`]\n- [`ConstBlock`]\n- [`ContinueExpression`]\n- [`FieldExpression`]\n- [`ForExpression`]\n- [`GenericFunction`]\n- [`Identifier`]\n- [`IfExpression`]\n- [`IndexExpression`]\n- [`LoopExpression`]\n- [`MacroInvocation`]\n- [`MatchExpression`]\n- [`Metavariable`]\n- [`ParenthesizedExpression`]\n- [`ReferenceExpression`]\n- [`ReturnExpression`]\n- [`ScopedIdentifier`]\n- [`Self_`]\n- [`StructExpression`]\n- [`TryBlock`]\n- [`TryExpression`]\n- [`TupleExpression`]\n- [`TypeCastExpression`]\n- [`UnaryExpression`]\n- [`UnitExpression`]\n- [`UnsafeBlock`]\n- [`WhileExpression`]\n- [`YieldExpression`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression<
        'tree,
    > {
        Literal(Literal<'tree>),
        ArrayExpression(ArrayExpression<'tree>),
        AssignmentExpression(AssignmentExpression<'tree>),
        AsyncBlock(AsyncBlock<'tree>),
        AwaitExpression(AwaitExpression<'tree>),
        BinaryExpression(BinaryExpression<'tree>),
        Block(Block<'tree>),
        BreakExpression(BreakExpression<'tree>),
        CallExpression(CallExpression<'tree>),
        ClosureExpression(ClosureExpression<'tree>),
        CompoundAssignmentExpr(CompoundAssignmentExpr<'tree>),
        ConstBlock(ConstBlock<'tree>),
        ContinueExpression(ContinueExpression<'tree>),
        FieldExpression(FieldExpression<'tree>),
        ForExpression(ForExpression<'tree>),
        GenericFunction(GenericFunction<'tree>),
        Identifier(Identifier<'tree>),
        IfExpression(IfExpression<'tree>),
        IndexExpression(IndexExpression<'tree>),
        LoopExpression(LoopExpression<'tree>),
        MacroInvocation(MacroInvocation<'tree>),
        MatchExpression(MatchExpression<'tree>),
        Metavariable(Metavariable<'tree>),
        ParenthesizedExpression(ParenthesizedExpression<'tree>),
        ReferenceExpression(ReferenceExpression<'tree>),
        ReturnExpression(ReturnExpression<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        StructExpression(StructExpression<'tree>),
        TryBlock(TryBlock<'tree>),
        TryExpression(TryExpression<'tree>),
        TupleExpression(TupleExpression<'tree>),
        TypeCastExpression(TypeCastExpression<'tree>),
        UnaryExpression(UnaryExpression<'tree>),
        UnitExpression(UnitExpression<'tree>),
        UnsafeBlock(UnsafeBlock<'tree>),
        WhileExpression(WhileExpression<'tree>),
        YieldExpression(YieldExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl < 'tree > Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression < 'tree > { # [doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`"] # [inline] pub fn as_literal (self) -> Option < Literal < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Literal (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`"] # [inline] pub fn as_array_expression (self) -> Option < ArrayExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ArrayExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`"] # [inline] pub fn as_assignment_expression (self) -> Option < AssignmentExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: AssignmentExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`"] # [inline] pub fn as_async_block (self) -> Option < AsyncBlock < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: AsyncBlock (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`"] # [inline] pub fn as_await_expression (self) -> Option < AwaitExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: AwaitExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`"] # [inline] pub fn as_binary_expression (self) -> Option < BinaryExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: BinaryExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`"] # [inline] pub fn as_block (self) -> Option < Block < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Block (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`"] # [inline] pub fn as_break_expression (self) -> Option < BreakExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: BreakExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`"] # [inline] pub fn as_call_expression (self) -> Option < CallExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: CallExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`"] # [inline] pub fn as_closure_expression (self) -> Option < ClosureExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ClosureExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`"] # [inline] pub fn as_compound_assignment_expr (self) -> Option < CompoundAssignmentExpr < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: CompoundAssignmentExpr (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`"] # [inline] pub fn as_const_block (self) -> Option < ConstBlock < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ConstBlock (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`"] # [inline] pub fn as_continue_expression (self) -> Option < ContinueExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ContinueExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`"] # [inline] pub fn as_field_expression (self) -> Option < FieldExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: FieldExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`"] # [inline] pub fn as_for_expression (self) -> Option < ForExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ForExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`"] # [inline] pub fn as_generic_function (self) -> Option < GenericFunction < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: GenericFunction (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"] # [inline] pub fn as_identifier (self) -> Option < Identifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Identifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`"] # [inline] pub fn as_if_expression (self) -> Option < IfExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: IfExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`"] # [inline] pub fn as_index_expression (self) -> Option < IndexExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: IndexExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`"] # [inline] pub fn as_loop_expression (self) -> Option < LoopExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: LoopExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`"] # [inline] pub fn as_macro_invocation (self) -> Option < MacroInvocation < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: MacroInvocation (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`"] # [inline] pub fn as_match_expression (self) -> Option < MatchExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: MatchExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"] # [inline] pub fn as_metavariable (self) -> Option < Metavariable < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Metavariable (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`"] # [inline] pub fn as_parenthesized_expression (self) -> Option < ParenthesizedExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ParenthesizedExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`"] # [inline] pub fn as_reference_expression (self) -> Option < ReferenceExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ReferenceExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`"] # [inline] pub fn as_return_expression (self) -> Option < ReturnExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ReturnExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"] # [inline] pub fn as_scoped_identifier (self) -> Option < ScopedIdentifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: ScopedIdentifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"] # [inline] pub fn as_self (self) -> Option < Self_ < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Self_ (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`"] # [inline] pub fn as_struct_expression (self) -> Option < StructExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: StructExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`"] # [inline] pub fn as_try_block (self) -> Option < TryBlock < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TryBlock (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`"] # [inline] pub fn as_try_expression (self) -> Option < TryExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TryExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`"] # [inline] pub fn as_tuple_expression (self) -> Option < TupleExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TupleExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`"] # [inline] pub fn as_type_cast_expression (self) -> Option < TypeCastExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TypeCastExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`"] # [inline] pub fn as_unary_expression (self) -> Option < UnaryExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: UnaryExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`"] # [inline] pub fn as_unit_expression (self) -> Option < UnitExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: UnitExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`"] # [inline] pub fn as_unsafe_block (self) -> Option < UnsafeBlock < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: UnsafeBlock (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`"] # [inline] pub fn as_while_expression (self) -> Option < WhileExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: WhileExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`"] # [inline] pub fn as_yield_expression (self) -> Option < YieldExpression < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: YieldExpression (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_boolean_literal (self) -> Option < BooleanLiteral < 'tree > > { self . as_literal () ? . as_boolean_literal () } # [doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_char_literal (self) -> Option < CharLiteral < 'tree > > { self . as_literal () ? . as_char_literal () } # [doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_float_literal (self) -> Option < FloatLiteral < 'tree > > { self . as_literal () ? . as_float_literal () } # [doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_integer_literal (self) -> Option < IntegerLiteral < 'tree > > { self . as_literal () ? . as_integer_literal () } # [doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_raw_string_literal (self) -> Option < RawStringLiteral < 'tree > > { self . as_literal () ? . as_raw_string_literal () } # [doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_string_literal (self) -> Option < StringLiteral < 'tree > > { self . as_literal () ? . as_string_literal () } }
    #[automatically_derived]
    impl < 'tree > type_sitter :: Node < 'tree > for Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression < 'tree > { type WithLifetime < 'a > = Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression < 'a > ; const KIND : & 'static str = "{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}" ; # [inline] fn try_from_raw (node : type_sitter :: raw :: Node < 'tree >) -> type_sitter :: NodeResult < Self > { if let Ok (this) = < Literal < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Literal (this)) ; } if let Ok (this) = < ArrayExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ArrayExpression (this)) ; } if let Ok (this) = < AssignmentExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: AssignmentExpression (this)) ; } if let Ok (this) = < AsyncBlock < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: AsyncBlock (this)) ; } if let Ok (this) = < AwaitExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: AwaitExpression (this)) ; } if let Ok (this) = < BinaryExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: BinaryExpression (this)) ; } if let Ok (this) = < Block < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Block (this)) ; } if let Ok (this) = < BreakExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: BreakExpression (this)) ; } if let Ok (this) = < CallExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: CallExpression (this)) ; } if let Ok (this) = < ClosureExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ClosureExpression (this)) ; } if let Ok (this) = < CompoundAssignmentExpr < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: CompoundAssignmentExpr (this)) ; } if let Ok (this) = < ConstBlock < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ConstBlock (this)) ; } if let Ok (this) = < ContinueExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ContinueExpression (this)) ; } if let Ok (this) = < FieldExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: FieldExpression (this)) ; } if let Ok (this) = < ForExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ForExpression (this)) ; } if let Ok (this) = < GenericFunction < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: GenericFunction (this)) ; } if let Ok (this) = < Identifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Identifier (this)) ; } if let Ok (this) = < IfExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: IfExpression (this)) ; } if let Ok (this) = < IndexExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: IndexExpression (this)) ; } if let Ok (this) = < LoopExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: LoopExpression (this)) ; } if let Ok (this) = < MacroInvocation < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: MacroInvocation (this)) ; } if let Ok (this) = < MatchExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: MatchExpression (this)) ; } if let Ok (this) = < Metavariable < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Metavariable (this)) ; } if let Ok (this) = < ParenthesizedExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ParenthesizedExpression (this)) ; } if let Ok (this) = < ReferenceExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ReferenceExpression (this)) ; } if let Ok (this) = < ReturnExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ReturnExpression (this)) ; } if let Ok (this) = < ScopedIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: ScopedIdentifier (this)) ; } if let Ok (this) = < Self_ < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Self_ (this)) ; } if let Ok (this) = < StructExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: StructExpression (this)) ; } if let Ok (this) = < TryBlock < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TryBlock (this)) ; } if let Ok (this) = < TryExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TryExpression (this)) ; } if let Ok (this) = < TupleExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TupleExpression (this)) ; } if let Ok (this) = < TypeCastExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TypeCastExpression (this)) ; } if let Ok (this) = < UnaryExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: UnaryExpression (this)) ; } if let Ok (this) = < UnitExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: UnitExpression (this)) ; } if let Ok (this) = < UnsafeBlock < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: UnsafeBlock (this)) ; } if let Ok (this) = < WhileExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: WhileExpression (this)) ; } if let Ok (this) = < YieldExpression < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: YieldExpression (this)) ; } Err (type_sitter :: IncorrectKind :: new :: < Self > (node)) } # [inline] fn raw (& self) -> & type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => type_sitter :: Node :: raw (x) , Self :: ArrayExpression (x) => type_sitter :: Node :: raw (x) , Self :: AssignmentExpression (x) => type_sitter :: Node :: raw (x) , Self :: AsyncBlock (x) => type_sitter :: Node :: raw (x) , Self :: AwaitExpression (x) => type_sitter :: Node :: raw (x) , Self :: BinaryExpression (x) => type_sitter :: Node :: raw (x) , Self :: Block (x) => type_sitter :: Node :: raw (x) , Self :: BreakExpression (x) => type_sitter :: Node :: raw (x) , Self :: CallExpression (x) => type_sitter :: Node :: raw (x) , Self :: ClosureExpression (x) => type_sitter :: Node :: raw (x) , Self :: CompoundAssignmentExpr (x) => type_sitter :: Node :: raw (x) , Self :: ConstBlock (x) => type_sitter :: Node :: raw (x) , Self :: ContinueExpression (x) => type_sitter :: Node :: raw (x) , Self :: FieldExpression (x) => type_sitter :: Node :: raw (x) , Self :: ForExpression (x) => type_sitter :: Node :: raw (x) , Self :: GenericFunction (x) => type_sitter :: Node :: raw (x) , Self :: Identifier (x) => type_sitter :: Node :: raw (x) , Self :: IfExpression (x) => type_sitter :: Node :: raw (x) , Self :: IndexExpression (x) => type_sitter :: Node :: raw (x) , Self :: LoopExpression (x) => type_sitter :: Node :: raw (x) , Self :: MacroInvocation (x) => type_sitter :: Node :: raw (x) , Self :: MatchExpression (x) => type_sitter :: Node :: raw (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw (x) , Self :: ParenthesizedExpression (x) => type_sitter :: Node :: raw (x) , Self :: ReferenceExpression (x) => type_sitter :: Node :: raw (x) , Self :: ReturnExpression (x) => type_sitter :: Node :: raw (x) , Self :: ScopedIdentifier (x) => type_sitter :: Node :: raw (x) , Self :: Self_ (x) => type_sitter :: Node :: raw (x) , Self :: StructExpression (x) => type_sitter :: Node :: raw (x) , Self :: TryBlock (x) => type_sitter :: Node :: raw (x) , Self :: TryExpression (x) => type_sitter :: Node :: raw (x) , Self :: TupleExpression (x) => type_sitter :: Node :: raw (x) , Self :: TypeCastExpression (x) => type_sitter :: Node :: raw (x) , Self :: UnaryExpression (x) => type_sitter :: Node :: raw (x) , Self :: UnitExpression (x) => type_sitter :: Node :: raw (x) , Self :: UnsafeBlock (x) => type_sitter :: Node :: raw (x) , Self :: WhileExpression (x) => type_sitter :: Node :: raw (x) , Self :: YieldExpression (x) => type_sitter :: Node :: raw (x) , } } # [inline] fn raw_mut (& mut self) -> & mut type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => type_sitter :: Node :: raw_mut (x) , Self :: ArrayExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: AssignmentExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: AsyncBlock (x) => type_sitter :: Node :: raw_mut (x) , Self :: AwaitExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: BinaryExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: Block (x) => type_sitter :: Node :: raw_mut (x) , Self :: BreakExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: CallExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: ClosureExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: CompoundAssignmentExpr (x) => type_sitter :: Node :: raw_mut (x) , Self :: ConstBlock (x) => type_sitter :: Node :: raw_mut (x) , Self :: ContinueExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: FieldExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: ForExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: GenericFunction (x) => type_sitter :: Node :: raw_mut (x) , Self :: Identifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: IfExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: IndexExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: LoopExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: MacroInvocation (x) => type_sitter :: Node :: raw_mut (x) , Self :: MatchExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw_mut (x) , Self :: ParenthesizedExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: ReferenceExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: ReturnExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: ScopedIdentifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: Self_ (x) => type_sitter :: Node :: raw_mut (x) , Self :: StructExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: TryBlock (x) => type_sitter :: Node :: raw_mut (x) , Self :: TryExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: TupleExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: TypeCastExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: UnaryExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: UnitExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: UnsafeBlock (x) => type_sitter :: Node :: raw_mut (x) , Self :: WhileExpression (x) => type_sitter :: Node :: raw_mut (x) , Self :: YieldExpression (x) => type_sitter :: Node :: raw_mut (x) , } } # [inline] fn into_raw (self) -> type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => x . into_raw () , Self :: ArrayExpression (x) => x . into_raw () , Self :: AssignmentExpression (x) => x . into_raw () , Self :: AsyncBlock (x) => x . into_raw () , Self :: AwaitExpression (x) => x . into_raw () , Self :: BinaryExpression (x) => x . into_raw () , Self :: Block (x) => x . into_raw () , Self :: BreakExpression (x) => x . into_raw () , Self :: CallExpression (x) => x . into_raw () , Self :: ClosureExpression (x) => x . into_raw () , Self :: CompoundAssignmentExpr (x) => x . into_raw () , Self :: ConstBlock (x) => x . into_raw () , Self :: ContinueExpression (x) => x . into_raw () , Self :: FieldExpression (x) => x . into_raw () , Self :: ForExpression (x) => x . into_raw () , Self :: GenericFunction (x) => x . into_raw () , Self :: Identifier (x) => x . into_raw () , Self :: IfExpression (x) => x . into_raw () , Self :: IndexExpression (x) => x . into_raw () , Self :: LoopExpression (x) => x . into_raw () , Self :: MacroInvocation (x) => x . into_raw () , Self :: MatchExpression (x) => x . into_raw () , Self :: Metavariable (x) => x . into_raw () , Self :: ParenthesizedExpression (x) => x . into_raw () , Self :: ReferenceExpression (x) => x . into_raw () , Self :: ReturnExpression (x) => x . into_raw () , Self :: ScopedIdentifier (x) => x . into_raw () , Self :: Self_ (x) => x . into_raw () , Self :: StructExpression (x) => x . into_raw () , Self :: TryBlock (x) => x . into_raw () , Self :: TryExpression (x) => x . into_raw () , Self :: TupleExpression (x) => x . into_raw () , Self :: TypeCastExpression (x) => x . into_raw () , Self :: UnaryExpression (x) => x . into_raw () , Self :: UnitExpression (x) => x . into_raw () , Self :: UnsafeBlock (x) => x . into_raw () , Self :: WhileExpression (x) => x . into_raw () , Self :: YieldExpression (x) => x . into_raw () , } } }
    #[doc = "One of `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}`:\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenBindingPattern`]\n- [`TokenRepetitionPattern`]\n- [`TokenTreePattern`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern<
        'tree,
    > {
        Literal(Literal<'tree>),
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
        PrimitiveType(PrimitiveType<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
        TokenBindingPattern(TokenBindingPattern<'tree>),
        TokenRepetitionPattern(TokenRepetitionPattern<'tree>),
        TokenTreePattern(TokenTreePattern<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl < 'tree > Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern < 'tree > { # [doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`"] # [inline] pub fn as_literal (self) -> Option < Literal < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Literal (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`"] # [inline] pub fn as_crate (self) -> Option < Crate < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Crate (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"] # [inline] pub fn as_identifier (self) -> Option < Identifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Identifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"] # [inline] pub fn as_metavariable (self) -> Option < Metavariable < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Metavariable (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`"] # [inline] pub fn as_mutable_specifier (self) -> Option < MutableSpecifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: MutableSpecifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`"] # [inline] pub fn as_primitive_type (self) -> Option < PrimitiveType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: PrimitiveType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"] # [inline] pub fn as_self (self) -> Option < Self_ < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Self_ (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`"] # [inline] pub fn as_super (self) -> Option < Super < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Super (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `token_binding_pattern` ([`TokenBindingPattern`]), otherwise returns `None`"] # [inline] pub fn as_token_binding_pattern (self) -> Option < TokenBindingPattern < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TokenBindingPattern (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `token_repetition_pattern` ([`TokenRepetitionPattern`]), otherwise returns `None`"] # [inline] pub fn as_token_repetition_pattern (self) -> Option < TokenRepetitionPattern < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TokenRepetitionPattern (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `token_tree_pattern` ([`TokenTreePattern`]), otherwise returns `None`"] # [inline] pub fn as_token_tree_pattern (self) -> Option < TokenTreePattern < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TokenTreePattern (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_boolean_literal (self) -> Option < BooleanLiteral < 'tree > > { self . as_literal () ? . as_boolean_literal () } # [doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_char_literal (self) -> Option < CharLiteral < 'tree > > { self . as_literal () ? . as_char_literal () } # [doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_float_literal (self) -> Option < FloatLiteral < 'tree > > { self . as_literal () ? . as_float_literal () } # [doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_integer_literal (self) -> Option < IntegerLiteral < 'tree > > { self . as_literal () ? . as_integer_literal () } # [doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_raw_string_literal (self) -> Option < RawStringLiteral < 'tree > > { self . as_literal () ? . as_raw_string_literal () } # [doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_string_literal (self) -> Option < StringLiteral < 'tree > > { self . as_literal () ? . as_string_literal () } }
    #[automatically_derived]
    impl < 'tree > type_sitter :: Node < 'tree > for Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern < 'tree > { type WithLifetime < 'a > = Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern < 'a > ; const KIND : & 'static str = "{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}" ; # [inline] fn try_from_raw (node : type_sitter :: raw :: Node < 'tree >) -> type_sitter :: NodeResult < Self > { if let Ok (this) = < Literal < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Literal (this)) ; } if let Ok (this) = < Crate < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Crate (this)) ; } if let Ok (this) = < Identifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Identifier (this)) ; } if let Ok (this) = < Metavariable < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Metavariable (this)) ; } if let Ok (this) = < MutableSpecifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: MutableSpecifier (this)) ; } if let Ok (this) = < PrimitiveType < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: PrimitiveType (this)) ; } if let Ok (this) = < Self_ < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Self_ (this)) ; } if let Ok (this) = < Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Super (this)) ; } if let Ok (this) = < TokenBindingPattern < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TokenBindingPattern (this)) ; } if let Ok (this) = < TokenRepetitionPattern < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TokenRepetitionPattern (this)) ; } if let Ok (this) = < TokenTreePattern < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TokenTreePattern (this)) ; } Err (type_sitter :: IncorrectKind :: new :: < Self > (node)) } # [inline] fn raw (& self) -> & type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => type_sitter :: Node :: raw (x) , Self :: Crate (x) => type_sitter :: Node :: raw (x) , Self :: Identifier (x) => type_sitter :: Node :: raw (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw (x) , Self :: MutableSpecifier (x) => type_sitter :: Node :: raw (x) , Self :: PrimitiveType (x) => type_sitter :: Node :: raw (x) , Self :: Self_ (x) => type_sitter :: Node :: raw (x) , Self :: Super (x) => type_sitter :: Node :: raw (x) , Self :: TokenBindingPattern (x) => type_sitter :: Node :: raw (x) , Self :: TokenRepetitionPattern (x) => type_sitter :: Node :: raw (x) , Self :: TokenTreePattern (x) => type_sitter :: Node :: raw (x) , } } # [inline] fn raw_mut (& mut self) -> & mut type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => type_sitter :: Node :: raw_mut (x) , Self :: Crate (x) => type_sitter :: Node :: raw_mut (x) , Self :: Identifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw_mut (x) , Self :: MutableSpecifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: PrimitiveType (x) => type_sitter :: Node :: raw_mut (x) , Self :: Self_ (x) => type_sitter :: Node :: raw_mut (x) , Self :: Super (x) => type_sitter :: Node :: raw_mut (x) , Self :: TokenBindingPattern (x) => type_sitter :: Node :: raw_mut (x) , Self :: TokenRepetitionPattern (x) => type_sitter :: Node :: raw_mut (x) , Self :: TokenTreePattern (x) => type_sitter :: Node :: raw_mut (x) , } } # [inline] fn into_raw (self) -> type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => x . into_raw () , Self :: Crate (x) => x . into_raw () , Self :: Identifier (x) => x . into_raw () , Self :: Metavariable (x) => x . into_raw () , Self :: MutableSpecifier (x) => x . into_raw () , Self :: PrimitiveType (x) => x . into_raw () , Self :: Self_ (x) => x . into_raw () , Self :: Super (x) => x . into_raw () , Self :: TokenBindingPattern (x) => x . into_raw () , Self :: TokenRepetitionPattern (x) => x . into_raw () , Self :: TokenTreePattern (x) => x . into_raw () , } } }
    #[doc = "One of `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}`:\n- [`Literal`]\n- [`Crate`]\n- [`Identifier`]\n- [`Metavariable`]\n- [`MutableSpecifier`]\n- [`PrimitiveType`]\n- [`Self_`]\n- [`Super`]\n- [`TokenRepetition`]\n- [`TokenTree`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree<
        'tree,
    > {
        Literal(Literal<'tree>),
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
        PrimitiveType(PrimitiveType<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
        TokenRepetition(TokenRepetition<'tree>),
        TokenTree(TokenTree<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl < 'tree > Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree < 'tree > { # [doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`"] # [inline] pub fn as_literal (self) -> Option < Literal < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Literal (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`"] # [inline] pub fn as_crate (self) -> Option < Crate < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Crate (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`"] # [inline] pub fn as_identifier (self) -> Option < Identifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Identifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`"] # [inline] pub fn as_metavariable (self) -> Option < Metavariable < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Metavariable (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`"] # [inline] pub fn as_mutable_specifier (self) -> Option < MutableSpecifier < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: MutableSpecifier (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`"] # [inline] pub fn as_primitive_type (self) -> Option < PrimitiveType < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: PrimitiveType (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"] # [inline] pub fn as_self (self) -> Option < Self_ < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Self_ (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`"] # [inline] pub fn as_super (self) -> Option < Super < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: Super (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `token_repetition` ([`TokenRepetition`]), otherwise returns `None`"] # [inline] pub fn as_token_repetition (self) -> Option < TokenRepetition < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TokenRepetition (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `token_tree` ([`TokenTree`]), otherwise returns `None`"] # [inline] pub fn as_token_tree (self) -> Option < TokenTree < 'tree > > { # [allow (irrefutable_let_patterns)] if let Self :: TokenTree (x) = self { Some (x) } else { None } } # [doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_boolean_literal (self) -> Option < BooleanLiteral < 'tree > > { self . as_literal () ? . as_boolean_literal () } # [doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_char_literal (self) -> Option < CharLiteral < 'tree > > { self . as_literal () ? . as_char_literal () } # [doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_float_literal (self) -> Option < FloatLiteral < 'tree > > { self . as_literal () ? . as_float_literal () } # [doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_integer_literal (self) -> Option < IntegerLiteral < 'tree > > { self . as_literal () ? . as_integer_literal () } # [doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_raw_string_literal (self) -> Option < RawStringLiteral < 'tree > > { self . as_literal () ? . as_raw_string_literal () } # [doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"] # [inline] pub fn as_string_literal (self) -> Option < StringLiteral < 'tree > > { self . as_literal () ? . as_string_literal () } }
    #[automatically_derived]
    impl < 'tree > type_sitter :: Node < 'tree > for Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree < 'tree > { type WithLifetime < 'a > = Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree < 'a > ; const KIND : & 'static str = "{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}" ; # [inline] fn try_from_raw (node : type_sitter :: raw :: Node < 'tree >) -> type_sitter :: NodeResult < Self > { if let Ok (this) = < Literal < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Literal (this)) ; } if let Ok (this) = < Crate < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Crate (this)) ; } if let Ok (this) = < Identifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Identifier (this)) ; } if let Ok (this) = < Metavariable < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Metavariable (this)) ; } if let Ok (this) = < MutableSpecifier < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: MutableSpecifier (this)) ; } if let Ok (this) = < PrimitiveType < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: PrimitiveType (this)) ; } if let Ok (this) = < Self_ < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Self_ (this)) ; } if let Ok (this) = < Super < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: Super (this)) ; } if let Ok (this) = < TokenRepetition < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TokenRepetition (this)) ; } if let Ok (this) = < TokenTree < 'tree > as type_sitter :: Node < 'tree >> :: try_from_raw (node) { return Ok (Self :: TokenTree (this)) ; } Err (type_sitter :: IncorrectKind :: new :: < Self > (node)) } # [inline] fn raw (& self) -> & type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => type_sitter :: Node :: raw (x) , Self :: Crate (x) => type_sitter :: Node :: raw (x) , Self :: Identifier (x) => type_sitter :: Node :: raw (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw (x) , Self :: MutableSpecifier (x) => type_sitter :: Node :: raw (x) , Self :: PrimitiveType (x) => type_sitter :: Node :: raw (x) , Self :: Self_ (x) => type_sitter :: Node :: raw (x) , Self :: Super (x) => type_sitter :: Node :: raw (x) , Self :: TokenRepetition (x) => type_sitter :: Node :: raw (x) , Self :: TokenTree (x) => type_sitter :: Node :: raw (x) , } } # [inline] fn raw_mut (& mut self) -> & mut type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => type_sitter :: Node :: raw_mut (x) , Self :: Crate (x) => type_sitter :: Node :: raw_mut (x) , Self :: Identifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: Metavariable (x) => type_sitter :: Node :: raw_mut (x) , Self :: MutableSpecifier (x) => type_sitter :: Node :: raw_mut (x) , Self :: PrimitiveType (x) => type_sitter :: Node :: raw_mut (x) , Self :: Self_ (x) => type_sitter :: Node :: raw_mut (x) , Self :: Super (x) => type_sitter :: Node :: raw_mut (x) , Self :: TokenRepetition (x) => type_sitter :: Node :: raw_mut (x) , Self :: TokenTree (x) => type_sitter :: Node :: raw_mut (x) , } } # [inline] fn into_raw (self) -> type_sitter :: raw :: Node < 'tree > { match self { Self :: Literal (x) => x . into_raw () , Self :: Crate (x) => x . into_raw () , Self :: Identifier (x) => x . into_raw () , Self :: Metavariable (x) => x . into_raw () , Self :: MutableSpecifier (x) => x . into_raw () , Self :: PrimitiveType (x) => x . into_raw () , Self :: Self_ (x) => x . into_raw () , Self :: Super (x) => x . into_raw () , Self :: TokenRepetition (x) => x . into_raw () , Self :: TokenTree (x) => x . into_raw () , } } }
    #[doc = "One of `{_literal | _type | block | lifetime | trait_bounds | type_binding}`:\n- [`Literal`]\n- [`Type`]\n- [`Block`]\n- [`Lifetime`]\n- [`TraitBounds`]\n- [`TypeBinding`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree> {
        Literal(Literal<'tree>),
        Type(Type<'tree>),
        Block(Block<'tree>),
        Lifetime(Lifetime<'tree>),
        TraitBounds(TraitBounds<'tree>),
        TypeBinding(TypeBinding<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree> {
        #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`"]
        #[inline]
        pub fn as_literal(self) -> Option<Literal<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Literal(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type(self) -> Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Block(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lifetime(self) -> Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `trait_bounds` ([`TraitBounds`]), otherwise returns `None`"]
        #[inline]
        pub fn as_trait_bounds(self) -> Option<TraitBounds<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TraitBounds(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_binding` ([`TypeBinding`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_binding(self) -> Option<TypeBinding<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeBinding(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_literal()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_literal()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_literal()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_literal()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_literal()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_literal()?.as_string_literal()
        }
        #[doc = "Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_abstract_type(self) -> Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        #[doc = "Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_array_type(self) -> Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        #[doc = "Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_bounded_type(self) -> Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        #[doc = "Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_dynamic_type(self) -> Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_never_type(self) -> Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        #[doc = "Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_pointer_type(self) -> Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        #[doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_primitive_type(self) -> Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        #[doc = "Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_reference_type(self) -> Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        #[doc = "Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_removed_trait_bound(self) -> Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        #[doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_tuple_type(self) -> Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        #[doc = "Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_unit_type(self) -> Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree>
    {
        type WithLifetime<'a> = Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'a>;
        const KIND: &'static str =
            "{_literal | _type | block | lifetime | trait_bounds | type_binding}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Literal<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Literal(this));
            }
            if let Ok(this) = <Type<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <Block<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Block(this));
            }
            if let Ok(this) = <Lifetime<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            if let Ok(this) = <TraitBounds<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TraitBounds(this));
            }
            if let Ok(this) = <TypeBinding<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeBinding(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Literal(x) => type_sitter::Node::raw(x),
                Self::Type(x) => type_sitter::Node::raw(x),
                Self::Block(x) => type_sitter::Node::raw(x),
                Self::Lifetime(x) => type_sitter::Node::raw(x),
                Self::TraitBounds(x) => type_sitter::Node::raw(x),
                Self::TypeBinding(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Literal(x) => type_sitter::Node::raw_mut(x),
                Self::Type(x) => type_sitter::Node::raw_mut(x),
                Self::Block(x) => type_sitter::Node::raw_mut(x),
                Self::Lifetime(x) => type_sitter::Node::raw_mut(x),
                Self::TraitBounds(x) => type_sitter::Node::raw_mut(x),
                Self::TypeBinding(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Literal(x) => x.into_raw(),
                Self::Type(x) => x.into_raw(),
                Self::Block(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
                Self::TraitBounds(x) => x.into_raw(),
                Self::TypeBinding(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}`:\n- [`symbols::ModEq`]\n- [`symbols::AndEq`]\n- [`symbols::MulEq`]\n- [`symbols::AddEq`]\n- [`symbols::SubEq`]\n- [`symbols::DivEq`]\n- [`symbols::LtLtEq`]\n- [`symbols::GtGtEq`]\n- [`symbols::BitXorEq`]\n- [`symbols::OrEq`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'tree> {
        ModEq(symbols::ModEq<'tree>),
        AndEq(symbols::AndEq<'tree>),
        MulEq(symbols::MulEq<'tree>),
        AddEq(symbols::AddEq<'tree>),
        SubEq(symbols::SubEq<'tree>),
        DivEq(symbols::DivEq<'tree>),
        LtLtEq(symbols::LtLtEq<'tree>),
        GtGtEq(symbols::GtGtEq<'tree>),
        BitXorEq(symbols::BitXorEq<'tree>),
        OrEq(symbols::OrEq<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'tree> {
        #[doc = "Returns the node if it is of type `%=` ([`symbols::ModEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mod_eq(self) -> Option<symbols::ModEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ModEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `&=` ([`symbols::AndEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_and_eq(self) -> Option<symbols::AndEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AndEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `*=` ([`symbols::MulEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mul_eq(self) -> Option<symbols::MulEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MulEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `+=` ([`symbols::AddEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_add_eq(self) -> Option<symbols::AddEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AddEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `-=` ([`symbols::SubEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_sub_eq(self) -> Option<symbols::SubEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `/=` ([`symbols::DivEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_div_eq(self) -> Option<symbols::DivEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DivEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `<<=` ([`symbols::LtLtEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lt_lt_eq(self) -> Option<symbols::LtLtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtLtEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `>>=` ([`symbols::GtGtEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_gt_gt_eq(self) -> Option<symbols::GtGtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtGtEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `^=` ([`symbols::BitXorEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_bit_xor_eq(self) -> Option<symbols::BitXorEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitXorEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `|=` ([`symbols::OrEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_or_eq(self) -> Option<symbols::OrEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'tree>
    {
        type WithLifetime<'a> = ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'a>;
        const KIND: &'static str = "{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "%=" => Ok(unsafe {
                    Self::ModEq(
                        <symbols::ModEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "&=" => Ok(unsafe {
                    Self::AndEq(
                        <symbols::AndEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "*=" => Ok(unsafe {
                    Self::MulEq(
                        <symbols::MulEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "+=" => Ok(unsafe {
                    Self::AddEq(
                        <symbols::AddEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "-=" => Ok(unsafe {
                    Self::SubEq(
                        <symbols::SubEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "/=" => Ok(unsafe {
                    Self::DivEq(
                        <symbols::DivEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "<<=" => {
                    Ok(unsafe {
                        Self :: LtLtEq (< symbols :: LtLtEq < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                ">>=" => {
                    Ok(unsafe {
                        Self :: GtGtEq (< symbols :: GtGtEq < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "^=" => {
                    Ok(unsafe {
                        Self :: BitXorEq (< symbols :: BitXorEq < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "|=" => Ok(unsafe {
                    Self::OrEq(
                        <symbols::OrEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::ModEq(x) => type_sitter::Node::raw(x),
                Self::AndEq(x) => type_sitter::Node::raw(x),
                Self::MulEq(x) => type_sitter::Node::raw(x),
                Self::AddEq(x) => type_sitter::Node::raw(x),
                Self::SubEq(x) => type_sitter::Node::raw(x),
                Self::DivEq(x) => type_sitter::Node::raw(x),
                Self::LtLtEq(x) => type_sitter::Node::raw(x),
                Self::GtGtEq(x) => type_sitter::Node::raw(x),
                Self::BitXorEq(x) => type_sitter::Node::raw(x),
                Self::OrEq(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::ModEq(x) => type_sitter::Node::raw_mut(x),
                Self::AndEq(x) => type_sitter::Node::raw_mut(x),
                Self::MulEq(x) => type_sitter::Node::raw_mut(x),
                Self::AddEq(x) => type_sitter::Node::raw_mut(x),
                Self::SubEq(x) => type_sitter::Node::raw_mut(x),
                Self::DivEq(x) => type_sitter::Node::raw_mut(x),
                Self::LtLtEq(x) => type_sitter::Node::raw_mut(x),
                Self::GtGtEq(x) => type_sitter::Node::raw_mut(x),
                Self::BitXorEq(x) => type_sitter::Node::raw_mut(x),
                Self::OrEq(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::ModEq(x) => x.into_raw(),
                Self::AndEq(x) => x.into_raw(),
                Self::MulEq(x) => x.into_raw(),
                Self::AddEq(x) => x.into_raw(),
                Self::SubEq(x) => x.into_raw(),
                Self::DivEq(x) => x.into_raw(),
                Self::LtLtEq(x) => x.into_raw(),
                Self::GtGtEq(x) => x.into_raw(),
                Self::BitXorEq(x) => x.into_raw(),
                Self::OrEq(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{mutable_specifier | visibility_modifier}`:\n- [`MutableSpecifier`]\n- [`VisibilityModifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum MutableSpecifier_VisibilityModifier<'tree> {
        MutableSpecifier(MutableSpecifier<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MutableSpecifier_VisibilityModifier<'tree> {
        #[doc = "Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mutable_specifier(self) -> Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_visibility_modifier(self) -> Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for MutableSpecifier_VisibilityModifier<'tree> {
        type WithLifetime<'a> = MutableSpecifier_VisibilityModifier<'a>;
        const KIND: &'static str = "{mutable_specifier | visibility_modifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "mutable_specifier" => {
                    Ok(unsafe {
                        Self::MutableSpecifier(<MutableSpecifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "visibility_modifier" => Ok(unsafe {
                    Self::VisibilityModifier(<VisibilityModifier<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::MutableSpecifier(x) => type_sitter::Node::raw(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::MutableSpecifier(x) => type_sitter::Node::raw_mut(x),
                Self::VisibilityModifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::MutableSpecifier(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}`:\n- [`symbols::NotEq`]\n- [`symbols::Mod`]\n- [`symbols::And`]\n- [`symbols::AndAnd`]\n- [`symbols::Mul`]\n- [`symbols::Add`]\n- [`symbols::Sub`]\n- [`symbols::Div`]\n- [`symbols::Lt`]\n- [`symbols::LtLt`]\n- [`symbols::LtEq`]\n- [`symbols::EqEq`]\n- [`symbols::Gt`]\n- [`symbols::GtEq`]\n- [`symbols::GtGt`]\n- [`symbols::BitXor`]\n- [`symbols::Or`]\n- [`symbols::OrOr`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
        'tree,
    > {
        NotEq(symbols::NotEq<'tree>),
        Mod(symbols::Mod<'tree>),
        And(symbols::And<'tree>),
        AndAnd(symbols::AndAnd<'tree>),
        Mul(symbols::Mul<'tree>),
        Add(symbols::Add<'tree>),
        Sub(symbols::Sub<'tree>),
        Div(symbols::Div<'tree>),
        Lt(symbols::Lt<'tree>),
        LtLt(symbols::LtLt<'tree>),
        LtEq(symbols::LtEq<'tree>),
        EqEq(symbols::EqEq<'tree>),
        Gt(symbols::Gt<'tree>),
        GtEq(symbols::GtEq<'tree>),
        GtGt(symbols::GtGt<'tree>),
        BitXor(symbols::BitXor<'tree>),
        Or(symbols::Or<'tree>),
        OrOr(symbols::OrOr<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree>
        NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<'tree>
    {
        #[doc = "Returns the node if it is of type `!=` ([`symbols::NotEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_not_eq(self) -> Option<symbols::NotEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::NotEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `%` ([`symbols::Mod`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mod(self) -> Option<symbols::Mod<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mod(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `&` ([`symbols::And`]), otherwise returns `None`"]
        #[inline]
        pub fn as_and(self) -> Option<symbols::And<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::And(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `&&` ([`symbols::AndAnd`]), otherwise returns `None`"]
        #[inline]
        pub fn as_and_and(self) -> Option<symbols::AndAnd<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AndAnd(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `*` ([`symbols::Mul`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mul(self) -> Option<symbols::Mul<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mul(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `+` ([`symbols::Add`]), otherwise returns `None`"]
        #[inline]
        pub fn as_add(self) -> Option<symbols::Add<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Add(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `-` ([`symbols::Sub`]), otherwise returns `None`"]
        #[inline]
        pub fn as_sub(self) -> Option<symbols::Sub<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Sub(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `/` ([`symbols::Div`]), otherwise returns `None`"]
        #[inline]
        pub fn as_div(self) -> Option<symbols::Div<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Div(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `<` ([`symbols::Lt`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lt(self) -> Option<symbols::Lt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lt(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `<<` ([`symbols::LtLt`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lt_lt(self) -> Option<symbols::LtLt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtLt(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `<=` ([`symbols::LtEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lt_eq(self) -> Option<symbols::LtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `==` ([`symbols::EqEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_eq_eq(self) -> Option<symbols::EqEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EqEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `>` ([`symbols::Gt`]), otherwise returns `None`"]
        #[inline]
        pub fn as_gt(self) -> Option<symbols::Gt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Gt(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `>=` ([`symbols::GtEq`]), otherwise returns `None`"]
        #[inline]
        pub fn as_gt_eq(self) -> Option<symbols::GtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtEq(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `>>` ([`symbols::GtGt`]), otherwise returns `None`"]
        #[inline]
        pub fn as_gt_gt(self) -> Option<symbols::GtGt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtGt(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `^` ([`symbols::BitXor`]), otherwise returns `None`"]
        #[inline]
        pub fn as_bit_xor(self) -> Option<symbols::BitXor<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitXor(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `|` ([`symbols::Or`]), otherwise returns `None`"]
        #[inline]
        pub fn as_or(self) -> Option<symbols::Or<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Or(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `||` ([`symbols::OrOr`]), otherwise returns `None`"]
        #[inline]
        pub fn as_or_or(self) -> Option<symbols::OrOr<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrOr(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
            'tree,
        >
    {
        type WithLifetime<'a> =
            NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<'a>;
        const KIND: &'static str =
            "{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "!=" => Ok(unsafe {
                    Self::NotEq(
                        <symbols::NotEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "%" => Ok(unsafe {
                    Self::Mod(
                        <symbols::Mod<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "&" => Ok(unsafe {
                    Self::And(
                        <symbols::And<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "&&" => {
                    Ok(unsafe {
                        Self :: AndAnd (< symbols :: AndAnd < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "*" => Ok(unsafe {
                    Self::Mul(
                        <symbols::Mul<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "+" => Ok(unsafe {
                    Self::Add(
                        <symbols::Add<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "-" => Ok(unsafe {
                    Self::Sub(
                        <symbols::Sub<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "/" => Ok(unsafe {
                    Self::Div(
                        <symbols::Div<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "<" => Ok(unsafe {
                    Self::Lt(
                        <symbols::Lt<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "<<" => Ok(unsafe {
                    Self::LtLt(
                        <symbols::LtLt<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "<=" => Ok(unsafe {
                    Self::LtEq(
                        <symbols::LtEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "==" => Ok(unsafe {
                    Self::EqEq(
                        <symbols::EqEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                ">" => Ok(unsafe {
                    Self::Gt(
                        <symbols::Gt<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                ">=" => Ok(unsafe {
                    Self::GtEq(
                        <symbols::GtEq<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                ">>" => Ok(unsafe {
                    Self::GtGt(
                        <symbols::GtGt<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                "^" => {
                    Ok(unsafe {
                        Self :: BitXor (< symbols :: BitXor < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "|" => Ok(unsafe {
                    Self::Or(
                        <symbols::Or<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                "||" => Ok(unsafe {
                    Self::OrOr(
                        <symbols::OrOr<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::NotEq(x) => type_sitter::Node::raw(x),
                Self::Mod(x) => type_sitter::Node::raw(x),
                Self::And(x) => type_sitter::Node::raw(x),
                Self::AndAnd(x) => type_sitter::Node::raw(x),
                Self::Mul(x) => type_sitter::Node::raw(x),
                Self::Add(x) => type_sitter::Node::raw(x),
                Self::Sub(x) => type_sitter::Node::raw(x),
                Self::Div(x) => type_sitter::Node::raw(x),
                Self::Lt(x) => type_sitter::Node::raw(x),
                Self::LtLt(x) => type_sitter::Node::raw(x),
                Self::LtEq(x) => type_sitter::Node::raw(x),
                Self::EqEq(x) => type_sitter::Node::raw(x),
                Self::Gt(x) => type_sitter::Node::raw(x),
                Self::GtEq(x) => type_sitter::Node::raw(x),
                Self::GtGt(x) => type_sitter::Node::raw(x),
                Self::BitXor(x) => type_sitter::Node::raw(x),
                Self::Or(x) => type_sitter::Node::raw(x),
                Self::OrOr(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::NotEq(x) => type_sitter::Node::raw_mut(x),
                Self::Mod(x) => type_sitter::Node::raw_mut(x),
                Self::And(x) => type_sitter::Node::raw_mut(x),
                Self::AndAnd(x) => type_sitter::Node::raw_mut(x),
                Self::Mul(x) => type_sitter::Node::raw_mut(x),
                Self::Add(x) => type_sitter::Node::raw_mut(x),
                Self::Sub(x) => type_sitter::Node::raw_mut(x),
                Self::Div(x) => type_sitter::Node::raw_mut(x),
                Self::Lt(x) => type_sitter::Node::raw_mut(x),
                Self::LtLt(x) => type_sitter::Node::raw_mut(x),
                Self::LtEq(x) => type_sitter::Node::raw_mut(x),
                Self::EqEq(x) => type_sitter::Node::raw_mut(x),
                Self::Gt(x) => type_sitter::Node::raw_mut(x),
                Self::GtEq(x) => type_sitter::Node::raw_mut(x),
                Self::GtGt(x) => type_sitter::Node::raw_mut(x),
                Self::BitXor(x) => type_sitter::Node::raw_mut(x),
                Self::Or(x) => type_sitter::Node::raw_mut(x),
                Self::OrOr(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::NotEq(x) => x.into_raw(),
                Self::Mod(x) => x.into_raw(),
                Self::And(x) => x.into_raw(),
                Self::AndAnd(x) => x.into_raw(),
                Self::Mul(x) => x.into_raw(),
                Self::Add(x) => x.into_raw(),
                Self::Sub(x) => x.into_raw(),
                Self::Div(x) => x.into_raw(),
                Self::Lt(x) => x.into_raw(),
                Self::LtLt(x) => x.into_raw(),
                Self::LtEq(x) => x.into_raw(),
                Self::EqEq(x) => x.into_raw(),
                Self::Gt(x) => x.into_raw(),
                Self::GtEq(x) => x.into_raw(),
                Self::GtGt(x) => x.into_raw(),
                Self::BitXor(x) => x.into_raw(),
                Self::Or(x) => x.into_raw(),
                Self::OrOr(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_pattern | closure_expression}`:\n- [`Pattern`]\n- [`ClosureExpression`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_ClosureExpression<'tree> {
        Pattern(Pattern<'tree>),
        ClosureExpression(ClosureExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_ClosureExpression<'tree> {
        #[doc = "Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`"]
        #[inline]
        pub fn as_pattern(self) -> Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ClosureExpression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as___(self) -> Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        #[doc = "Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_literal_pattern(self) -> Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        #[doc = "Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_captured_pattern(self) -> Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_mut_pattern(self) -> Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        #[doc = "Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_or_pattern(self) -> Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        #[doc = "Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_range_pattern(self) -> Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        #[doc = "Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_ref_pattern(self) -> Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        #[doc = "Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_reference_pattern(self) -> Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        #[doc = "Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_remaining_field_pattern(self) -> Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_slice_pattern(self) -> Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        #[doc = "Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_struct_pattern(self) -> Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_pattern(self) -> Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_struct_pattern(self) -> Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_negative_literal(self) -> Option<NegativeLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_negative_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Pattern_ClosureExpression<'tree> {
        type WithLifetime<'a> = Pattern_ClosureExpression<'a>;
        const KIND: &'static str = "{_pattern | closure_expression}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) =
                <ClosureExpression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::ClosureExpression(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw(x),
                Self::ClosureExpression(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw_mut(x),
                Self::ClosureExpression(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::ClosureExpression(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_pattern | mutable_specifier}`:\n- [`Pattern`]\n- [`MutableSpecifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_MutableSpecifier<'tree> {
        Pattern(Pattern<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_MutableSpecifier<'tree> {
        #[doc = "Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`"]
        #[inline]
        pub fn as_pattern(self) -> Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_mutable_specifier(self) -> Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as___(self) -> Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        #[doc = "Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_literal_pattern(self) -> Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        #[doc = "Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_captured_pattern(self) -> Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_mut_pattern(self) -> Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        #[doc = "Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_or_pattern(self) -> Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        #[doc = "Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_range_pattern(self) -> Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        #[doc = "Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_ref_pattern(self) -> Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        #[doc = "Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_reference_pattern(self) -> Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        #[doc = "Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_remaining_field_pattern(self) -> Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_slice_pattern(self) -> Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        #[doc = "Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_struct_pattern(self) -> Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_pattern(self) -> Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_struct_pattern(self) -> Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_negative_literal(self) -> Option<NegativeLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_negative_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Pattern_MutableSpecifier<'tree> {
        type WithLifetime<'a> = Pattern_MutableSpecifier<'a>;
        const KIND: &'static str = "{_pattern | mutable_specifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) =
                <MutableSpecifier<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::MutableSpecifier(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw(x),
                Self::MutableSpecifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw_mut(x),
                Self::MutableSpecifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_pattern | parameter}`:\n- [`Pattern`]\n- [`Parameter`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_Parameter<'tree> {
        Pattern(Pattern<'tree>),
        Parameter(Parameter<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_Parameter<'tree> {
        #[doc = "Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`"]
        #[inline]
        pub fn as_pattern(self) -> Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `parameter` ([`Parameter`]), otherwise returns `None`"]
        #[inline]
        pub fn as_parameter(self) -> Option<Parameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Parameter(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as___(self) -> Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        #[doc = "Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_literal_pattern(self) -> Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        #[doc = "Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_captured_pattern(self) -> Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_mut_pattern(self) -> Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        #[doc = "Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_or_pattern(self) -> Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        #[doc = "Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_range_pattern(self) -> Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        #[doc = "Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_ref_pattern(self) -> Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        #[doc = "Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_reference_pattern(self) -> Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        #[doc = "Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_remaining_field_pattern(self) -> Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_slice_pattern(self) -> Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        #[doc = "Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_struct_pattern(self) -> Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_pattern(self) -> Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_struct_pattern(self) -> Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_negative_literal(self) -> Option<NegativeLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_negative_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Pattern_Parameter<'tree> {
        type WithLifetime<'a> = Pattern_Parameter<'a>;
        const KIND: &'static str = "{_pattern | parameter}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) = <Parameter<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Parameter(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw(x),
                Self::Parameter(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw_mut(x),
                Self::Parameter(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::Parameter(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_pattern | self}`:\n- [`Pattern`]\n- [`Self_`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_Self_<'tree> {
        Pattern(Pattern<'tree>),
        Self_(Self_<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_Self_<'tree> {
        #[doc = "Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`"]
        #[inline]
        pub fn as_pattern(self) -> Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as___(self) -> Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        #[doc = "Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_literal_pattern(self) -> Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        #[doc = "Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_captured_pattern(self) -> Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_mut_pattern(self) -> Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        #[doc = "Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_or_pattern(self) -> Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        #[doc = "Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_range_pattern(self) -> Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        #[doc = "Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_ref_pattern(self) -> Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        #[doc = "Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_reference_pattern(self) -> Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        #[doc = "Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_remaining_field_pattern(self) -> Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_slice_pattern(self) -> Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        #[doc = "Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_struct_pattern(self) -> Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_pattern(self) -> Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        #[doc = "Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))"]
        #[inline]
        pub fn as_tuple_struct_pattern(self) -> Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_negative_literal(self) -> Option<NegativeLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_negative_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_pattern()?
                .as_literal_pattern()?
                .as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))\n- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Pattern_Self_<'tree> {
        type WithLifetime<'a> = Pattern_Self_<'a>;
        const KIND: &'static str = "{_pattern | self}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Pattern<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) = <Self_<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw(x),
                Self::Self_(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => type_sitter::Node::raw_mut(x),
                Self::Self_(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{scoped_identifier | type_identifier}`:\n- [`ScopedIdentifier`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ScopedIdentifier_TypeIdentifier<'tree> {
        ScopedIdentifier(ScopedIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ScopedIdentifier_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ScopedIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = ScopedIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str = "{scoped_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "scoped_identifier" => {
                    Ok(unsafe {
                        Self::ScopedIdentifier(<ScopedIdentifier<'tree> as type_sitter::Node<
                            'tree,
                        >>::from_raw_unchecked(node))
                    })
                }
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::ScopedIdentifier(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::ScopedIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{scoped_type_identifier | type_identifier}`:\n- [`ScopedTypeIdentifier`]\n- [`TypeIdentifier`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ScopedTypeIdentifier_TypeIdentifier<'tree> {
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ScopedTypeIdentifier_TypeIdentifier<'tree> {
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ScopedTypeIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = ScopedTypeIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str = "{scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "scoped_type_identifier" => {
                    Ok(unsafe {
                        Self :: ScopedTypeIdentifier (< ScopedTypeIdentifier < 'tree > as type_sitter :: Node < 'tree >> :: from_raw_unchecked (node))
                    })
                }
                "type_identifier" => Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(
                            node,
                        ),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::ScopedTypeIdentifier(x) => type_sitter::Node::raw_mut(x),
                Self::TypeIdentifier(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_type | attribute_item | parameter | self_parameter | variadic_parameter}`:\n- [`Type`]\n- [`AttributeItem`]\n- [`Parameter`]\n- [`SelfParameter`]\n- [`VariadicParameter`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'tree> {
        Type(Type<'tree>),
        AttributeItem(AttributeItem<'tree>),
        Parameter(Parameter<'tree>),
        SelfParameter(SelfParameter<'tree>),
        VariadicParameter(VariadicParameter<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'tree> {
        #[doc = "Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type(self) -> Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`"]
        #[inline]
        pub fn as_attribute_item(self) -> Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `parameter` ([`Parameter`]), otherwise returns `None`"]
        #[inline]
        pub fn as_parameter(self) -> Option<Parameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Parameter(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `self_parameter` ([`SelfParameter`]), otherwise returns `None`"]
        #[inline]
        pub fn as_self_parameter(self) -> Option<SelfParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SelfParameter(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `variadic_parameter` ([`VariadicParameter`]), otherwise returns `None`"]
        #[inline]
        pub fn as_variadic_parameter(self) -> Option<VariadicParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VariadicParameter(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_abstract_type(self) -> Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        #[doc = "Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_array_type(self) -> Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        #[doc = "Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_bounded_type(self) -> Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        #[doc = "Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_dynamic_type(self) -> Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_never_type(self) -> Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        #[doc = "Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_pointer_type(self) -> Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        #[doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_primitive_type(self) -> Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        #[doc = "Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_reference_type(self) -> Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        #[doc = "Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_removed_trait_bound(self) -> Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        #[doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_tuple_type(self) -> Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        #[doc = "Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_unit_type(self) -> Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree>
        for Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'tree>
    {
        type WithLifetime<'a> = Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'a>;
        const KIND: &'static str =
            "{_type | attribute_item | parameter | self_parameter | variadic_parameter}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Type<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <AttributeItem<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <Parameter<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Parameter(this));
            }
            if let Ok(this) = <SelfParameter<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::SelfParameter(this));
            }
            if let Ok(this) =
                <VariadicParameter<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::VariadicParameter(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw(x),
                Self::AttributeItem(x) => type_sitter::Node::raw(x),
                Self::Parameter(x) => type_sitter::Node::raw(x),
                Self::SelfParameter(x) => type_sitter::Node::raw(x),
                Self::VariadicParameter(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw_mut(x),
                Self::AttributeItem(x) => type_sitter::Node::raw_mut(x),
                Self::Parameter(x) => type_sitter::Node::raw_mut(x),
                Self::SelfParameter(x) => type_sitter::Node::raw_mut(x),
                Self::VariadicParameter(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::AttributeItem(x) => x.into_raw(),
                Self::Parameter(x) => x.into_raw(),
                Self::SelfParameter(x) => x.into_raw(),
                Self::VariadicParameter(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_type | higher_ranked_trait_bound | lifetime}`:\n- [`Type`]\n- [`HigherRankedTraitBound`]\n- [`Lifetime`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_HigherRankedTraitBound_Lifetime<'tree> {
        Type(Type<'tree>),
        HigherRankedTraitBound(HigherRankedTraitBound<'tree>),
        Lifetime(Lifetime<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_HigherRankedTraitBound_Lifetime<'tree> {
        #[doc = "Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type(self) -> Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `higher_ranked_trait_bound` ([`HigherRankedTraitBound`]), otherwise returns `None`"]
        #[inline]
        pub fn as_higher_ranked_trait_bound(self) -> Option<HigherRankedTraitBound<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::HigherRankedTraitBound(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lifetime(self) -> Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_abstract_type(self) -> Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        #[doc = "Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_array_type(self) -> Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        #[doc = "Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_bounded_type(self) -> Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        #[doc = "Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_dynamic_type(self) -> Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_never_type(self) -> Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        #[doc = "Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_pointer_type(self) -> Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        #[doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_primitive_type(self) -> Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        #[doc = "Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_reference_type(self) -> Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        #[doc = "Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_removed_trait_bound(self) -> Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        #[doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_tuple_type(self) -> Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        #[doc = "Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_unit_type(self) -> Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Type_HigherRankedTraitBound_Lifetime<'tree> {
        type WithLifetime<'a> = Type_HigherRankedTraitBound_Lifetime<'a>;
        const KIND: &'static str = "{_type | higher_ranked_trait_bound | lifetime}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Type<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) =
                <HigherRankedTraitBound<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::HigherRankedTraitBound(this));
            }
            if let Ok(this) = <Lifetime<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw(x),
                Self::HigherRankedTraitBound(x) => type_sitter::Node::raw(x),
                Self::Lifetime(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw_mut(x),
                Self::HigherRankedTraitBound(x) => type_sitter::Node::raw_mut(x),
                Self::Lifetime(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::HigherRankedTraitBound(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_type | lifetime}`:\n- [`Type`]\n- [`Lifetime`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_Lifetime<'tree> {
        Type(Type<'tree>),
        Lifetime(Lifetime<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_Lifetime<'tree> {
        #[doc = "Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type(self) -> Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`"]
        #[inline]
        pub fn as_lifetime(self) -> Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_abstract_type(self) -> Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        #[doc = "Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_array_type(self) -> Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        #[doc = "Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_bounded_type(self) -> Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        #[doc = "Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_dynamic_type(self) -> Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_never_type(self) -> Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        #[doc = "Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_pointer_type(self) -> Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        #[doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_primitive_type(self) -> Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        #[doc = "Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_reference_type(self) -> Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        #[doc = "Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_removed_trait_bound(self) -> Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        #[doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_tuple_type(self) -> Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        #[doc = "Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_unit_type(self) -> Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Type_Lifetime<'tree> {
        type WithLifetime<'a> = Type_Lifetime<'a>;
        const KIND: &'static str = "{_type | lifetime}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Type<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <Lifetime<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw(x),
                Self::Lifetime(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw_mut(x),
                Self::Lifetime(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_type | qualified_type}`:\n- [`Type`]\n- [`QualifiedType`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_QualifiedType<'tree> {
        Type(Type<'tree>),
        QualifiedType(QualifiedType<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_QualifiedType<'tree> {
        #[doc = "Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`"]
        #[inline]
        pub fn as_type(self) -> Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `qualified_type` ([`QualifiedType`]), otherwise returns `None`"]
        #[inline]
        pub fn as_qualified_type(self) -> Option<QualifiedType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::QualifiedType(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_abstract_type(self) -> Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        #[doc = "Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_array_type(self) -> Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        #[doc = "Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_bounded_type(self) -> Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        #[doc = "Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_dynamic_type(self) -> Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        #[doc = "Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_function_type(self) -> Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        #[doc = "Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_generic_type(self) -> Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_never_type(self) -> Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        #[doc = "Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_pointer_type(self) -> Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        #[doc = "Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_primitive_type(self) -> Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        #[doc = "Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_reference_type(self) -> Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        #[doc = "Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_removed_trait_bound(self) -> Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        #[doc = "Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_scoped_type_identifier(self) -> Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        #[doc = "Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_tuple_type(self) -> Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        #[doc = "Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_type_identifier(self) -> Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        #[doc = "Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))"]
        #[inline]
        pub fn as_unit_type(self) -> Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for Type_QualifiedType<'tree> {
        type WithLifetime<'a> = Type_QualifiedType<'a>;
        const KIND: &'static str = "{_type | qualified_type}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <Type<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <QualifiedType<'tree> as type_sitter::Node<'tree>>::try_from_raw(node)
            {
                return Ok(Self::QualifiedType(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw(x),
                Self::QualifiedType(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => type_sitter::Node::raw_mut(x),
                Self::QualifiedType(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::QualifiedType(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{visibility_modifier | where_clause}`:\n- [`VisibilityModifier`]\n- [`WhereClause`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum VisibilityModifier_WhereClause<'tree> {
        VisibilityModifier(VisibilityModifier<'tree>),
        WhereClause(WhereClause<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> VisibilityModifier_WhereClause<'tree> {
        #[doc = "Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`"]
        #[inline]
        pub fn as_visibility_modifier(self) -> Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `where_clause` ([`WhereClause`]), otherwise returns `None`"]
        #[inline]
        pub fn as_where_clause(self) -> Option<WhereClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::WhereClause(x) = self {
                Some(x)
            } else {
                None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for VisibilityModifier_WhereClause<'tree> {
        type WithLifetime<'a> = VisibilityModifier_WhereClause<'a>;
        const KIND: &'static str = "{visibility_modifier | where_clause}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            match node.kind() {
                "visibility_modifier" => Ok(unsafe {
                    Self::VisibilityModifier(<VisibilityModifier<'tree> as type_sitter::Node<
                        'tree,
                    >>::from_raw_unchecked(node))
                }),
                "where_clause" => Ok(unsafe {
                    Self::WhereClause(
                        <WhereClause<'tree> as type_sitter::Node<'tree>>::from_raw_unchecked(node),
                    )
                }),
                _ => Err(type_sitter::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::VisibilityModifier(x) => type_sitter::Node::raw(x),
                Self::WhereClause(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::VisibilityModifier(x) => type_sitter::Node::raw_mut(x),
                Self::WhereClause(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::VisibilityModifier(x) => x.into_raw(),
                Self::WhereClause(x) => x.into_raw(),
            }
        }
    }
    #[doc = "One of `{_ | _expression}`:\n- [`symbols::__`]\n- [`Expression`]"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ___Expression<'tree> {
        __(symbols::__<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ___Expression<'tree> {
        #[doc = "Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`"]
        #[inline]
        pub fn as___(self) -> Option<symbols::__<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::__(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`"]
        #[inline]
        pub fn as_expression(self) -> Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                Some(x)
            } else {
                None
            }
        }
        #[doc = "Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_literal(self) -> Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        #[doc = "Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_array_expression(self) -> Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        #[doc = "Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_assignment_expression(self) -> Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        #[doc = "Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_async_block(self) -> Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        #[doc = "Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_await_expression(self) -> Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        #[doc = "Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_binary_expression(self) -> Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        #[doc = "Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_block(self) -> Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        #[doc = "Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_break_expression(self) -> Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        #[doc = "Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_call_expression(self) -> Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        #[doc = "Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_closure_expression(self) -> Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        #[doc = "Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_compound_assignment_expr(self) -> Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        #[doc = "Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_const_block(self) -> Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        #[doc = "Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_continue_expression(self) -> Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        #[doc = "Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_field_expression(self) -> Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        #[doc = "Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_for_expression(self) -> Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        #[doc = "Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_generic_function(self) -> Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        #[doc = "Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_identifier(self) -> Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        #[doc = "Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_if_expression(self) -> Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        #[doc = "Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_index_expression(self) -> Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        #[doc = "Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_loop_expression(self) -> Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        #[doc = "Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_macro_invocation(self) -> Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        #[doc = "Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_match_expression(self) -> Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        #[doc = "Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_metavariable(self) -> Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        #[doc = "Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_parenthesized_expression(self) -> Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        #[doc = "Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_range_expression(self) -> Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        #[doc = "Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_reference_expression(self) -> Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        #[doc = "Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_return_expression(self) -> Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        #[doc = "Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_scoped_identifier(self) -> Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        #[doc = "Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_self(self) -> Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        #[doc = "Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_struct_expression(self) -> Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        #[doc = "Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_block(self) -> Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        #[doc = "Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_try_expression(self) -> Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        #[doc = "Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_tuple_expression(self) -> Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        #[doc = "Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_type_cast_expression(self) -> Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        #[doc = "Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unary_expression(self) -> Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        #[doc = "Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unit_expression(self) -> Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        #[doc = "Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_unsafe_block(self) -> Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        #[doc = "Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_while_expression(self) -> Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        #[doc = "Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))"]
        #[inline]
        pub fn as_yield_expression(self) -> Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        #[doc = "Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_boolean_literal(self) -> Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        #[doc = "Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_char_literal(self) -> Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        #[doc = "Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_float_literal(self) -> Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        #[doc = "Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_integer_literal(self) -> Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        #[doc = "Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_raw_string_literal(self) -> Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        #[doc = "Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.\n\nFollows the following chain:\n- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))\n- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))"]
        #[inline]
        pub fn as_string_literal(self) -> Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> type_sitter::Node<'tree> for ___Expression<'tree> {
        type WithLifetime<'a> = ___Expression<'a>;
        const KIND: &'static str = "{_ | _expression}";
        #[inline]
        fn try_from_raw(node: type_sitter::raw::Node<'tree>) -> type_sitter::NodeResult<Self> {
            if let Ok(this) = <symbols::__<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::__(this));
            }
            if let Ok(this) = <Expression<'tree> as type_sitter::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            Err(type_sitter::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &type_sitter::raw::Node<'tree> {
            match self {
                Self::__(x) => type_sitter::Node::raw(x),
                Self::Expression(x) => type_sitter::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut type_sitter::raw::Node<'tree> {
            match self {
                Self::__(x) => type_sitter::Node::raw_mut(x),
                Self::Expression(x) => type_sitter::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> type_sitter::raw::Node<'tree> {
            match self {
                Self::__(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
            }
        }
    }
}
