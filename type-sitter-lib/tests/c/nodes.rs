/**Typed node `_abstract_declarator`

This node type has subtypes:

- `abstract_array_declarator` ([`AbstractArrayDeclarator`])
- `abstract_function_declarator` ([`AbstractFunctionDeclarator`])
- `abstract_parenthesized_declarator` ([`AbstractParenthesizedDeclarator`])
- `abstract_pointer_declarator` ([`AbstractPointerDeclarator`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum AbstractDeclarator<'tree> {
    AbstractArrayDeclarator(AbstractArrayDeclarator<'tree>),
    AbstractFunctionDeclarator(AbstractFunctionDeclarator<'tree>),
    AbstractParenthesizedDeclarator(AbstractParenthesizedDeclarator<'tree>),
    AbstractPointerDeclarator(AbstractPointerDeclarator<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> AbstractDeclarator<'tree> {
    ///Returns the node if it is of type `abstract_array_declarator` ([`AbstractArrayDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_abstract_array_declarator(
        self,
    ) -> ::std::option::Option<AbstractArrayDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AbstractArrayDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `abstract_function_declarator` ([`AbstractFunctionDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_abstract_function_declarator(
        self,
    ) -> ::std::option::Option<AbstractFunctionDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AbstractFunctionDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `abstract_parenthesized_declarator` ([`AbstractParenthesizedDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_abstract_parenthesized_declarator(
        self,
    ) -> ::std::option::Option<AbstractParenthesizedDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AbstractParenthesizedDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `abstract_pointer_declarator` ([`AbstractPointerDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_abstract_pointer_declarator(
        self,
    ) -> ::std::option::Option<AbstractPointerDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AbstractPointerDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AbstractDeclarator<'tree> {
    type WithLifetime<'a> = AbstractDeclarator<'a>;
    const KIND: &'static str = "_abstract_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        match node.kind() {
            "abstract_array_declarator" => {
                Ok(unsafe {
                    Self::AbstractArrayDeclarator(
                        <AbstractArrayDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "abstract_function_declarator" => {
                Ok(unsafe {
                    Self::AbstractFunctionDeclarator(
                        <AbstractFunctionDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "abstract_parenthesized_declarator" => {
                Ok(unsafe {
                    Self::AbstractParenthesizedDeclarator(
                        <AbstractParenthesizedDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "abstract_pointer_declarator" => {
                Ok(unsafe {
                    Self::AbstractPointerDeclarator(
                        <AbstractPointerDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::AbstractArrayDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::AbstractFunctionDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::AbstractParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::AbstractPointerDeclarator(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::AbstractArrayDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AbstractFunctionDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AbstractParenthesizedDeclarator(x) => {
                ::type_sitter_lib::Node::raw_mut(x)
            }
            Self::AbstractPointerDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::AbstractArrayDeclarator(x) => x.into_raw(),
            Self::AbstractFunctionDeclarator(x) => x.into_raw(),
            Self::AbstractParenthesizedDeclarator(x) => x.into_raw(),
            Self::AbstractPointerDeclarator(x) => x.into_raw(),
        }
    }
}
/**Typed node `_declarator`

This node type has subtypes:

- `array_declarator` ([`ArrayDeclarator`])
- `attributed_declarator` ([`AttributedDeclarator`])
- `function_declarator` ([`FunctionDeclarator`])
- `identifier` ([`Identifier`])
- `parenthesized_declarator` ([`ParenthesizedDeclarator`])
- `pointer_declarator` ([`PointerDeclarator`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Declarator<'tree> {
    ArrayDeclarator(ArrayDeclarator<'tree>),
    AttributedDeclarator(AttributedDeclarator<'tree>),
    FunctionDeclarator(FunctionDeclarator<'tree>),
    Identifier(Identifier<'tree>),
    ParenthesizedDeclarator(ParenthesizedDeclarator<'tree>),
    PointerDeclarator(PointerDeclarator<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Declarator<'tree> {
    ///Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_array_declarator(self) -> ::std::option::Option<ArrayDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ArrayDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_attributed_declarator(
        self,
    ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AttributedDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_function_declarator(
        self,
    ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
    #[inline]
    pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Identifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_parenthesized_declarator(
        self,
    ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ParenthesizedDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_pointer_declarator(
        self,
    ) -> ::std::option::Option<PointerDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PointerDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Declarator<'tree> {
    type WithLifetime<'a> = Declarator<'a>;
    const KIND: &'static str = "_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        match node.kind() {
            "array_declarator" => {
                Ok(unsafe {
                    Self::ArrayDeclarator(
                        <ArrayDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "attributed_declarator" => {
                Ok(unsafe {
                    Self::AttributedDeclarator(
                        <AttributedDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "function_declarator" => {
                Ok(unsafe {
                    Self::FunctionDeclarator(
                        <FunctionDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "identifier" => {
                Ok(unsafe {
                    Self::Identifier(
                        <Identifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "parenthesized_declarator" => {
                Ok(unsafe {
                    Self::ParenthesizedDeclarator(
                        <ParenthesizedDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "pointer_declarator" => {
                Ok(unsafe {
                    Self::PointerDeclarator(
                        <PointerDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => x.into_raw(),
            Self::AttributedDeclarator(x) => x.into_raw(),
            Self::FunctionDeclarator(x) => x.into_raw(),
            Self::Identifier(x) => x.into_raw(),
            Self::ParenthesizedDeclarator(x) => x.into_raw(),
            Self::PointerDeclarator(x) => x.into_raw(),
        }
    }
}
/**Typed node `_field_declarator`

This node type has subtypes:

- `array_declarator` ([`ArrayDeclarator`])
- `attributed_declarator` ([`AttributedDeclarator`])
- `field_identifier` ([`FieldIdentifier`])
- `function_declarator` ([`FunctionDeclarator`])
- `parenthesized_declarator` ([`ParenthesizedDeclarator`])
- `pointer_declarator` ([`PointerDeclarator`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum FieldDeclarator<'tree> {
    ArrayDeclarator(ArrayDeclarator<'tree>),
    AttributedDeclarator(AttributedDeclarator<'tree>),
    FieldIdentifier(FieldIdentifier<'tree>),
    FunctionDeclarator(FunctionDeclarator<'tree>),
    ParenthesizedDeclarator(ParenthesizedDeclarator<'tree>),
    PointerDeclarator(PointerDeclarator<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDeclarator<'tree> {
    ///Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_array_declarator(self) -> ::std::option::Option<ArrayDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ArrayDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_attributed_declarator(
        self,
    ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AttributedDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`
    #[inline]
    pub fn as_field_identifier(self) -> ::std::option::Option<FieldIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FieldIdentifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_function_declarator(
        self,
    ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_parenthesized_declarator(
        self,
    ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ParenthesizedDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_pointer_declarator(
        self,
    ) -> ::std::option::Option<PointerDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PointerDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldDeclarator<'tree> {
    type WithLifetime<'a> = FieldDeclarator<'a>;
    const KIND: &'static str = "_field_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        match node.kind() {
            "array_declarator" => {
                Ok(unsafe {
                    Self::ArrayDeclarator(
                        <ArrayDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "attributed_declarator" => {
                Ok(unsafe {
                    Self::AttributedDeclarator(
                        <AttributedDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "field_identifier" => {
                Ok(unsafe {
                    Self::FieldIdentifier(
                        <FieldIdentifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "function_declarator" => {
                Ok(unsafe {
                    Self::FunctionDeclarator(
                        <FunctionDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "parenthesized_declarator" => {
                Ok(unsafe {
                    Self::ParenthesizedDeclarator(
                        <ParenthesizedDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "pointer_declarator" => {
                Ok(unsafe {
                    Self::PointerDeclarator(
                        <PointerDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => x.into_raw(),
            Self::AttributedDeclarator(x) => x.into_raw(),
            Self::FieldIdentifier(x) => x.into_raw(),
            Self::FunctionDeclarator(x) => x.into_raw(),
            Self::ParenthesizedDeclarator(x) => x.into_raw(),
            Self::PointerDeclarator(x) => x.into_raw(),
        }
    }
}
/**Typed node `_type_declarator`

This node type has subtypes:

- `array_declarator` ([`ArrayDeclarator`])
- `attributed_declarator` ([`AttributedDeclarator`])
- `function_declarator` ([`FunctionDeclarator`])
- `parenthesized_declarator` ([`ParenthesizedDeclarator`])
- `pointer_declarator` ([`PointerDeclarator`])
- `primitive_type` ([`PrimitiveType`])
- `type_identifier` ([`TypeIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum TypeDeclarator<'tree> {
    ArrayDeclarator(ArrayDeclarator<'tree>),
    AttributedDeclarator(AttributedDeclarator<'tree>),
    FunctionDeclarator(FunctionDeclarator<'tree>),
    ParenthesizedDeclarator(ParenthesizedDeclarator<'tree>),
    PointerDeclarator(PointerDeclarator<'tree>),
    PrimitiveType(PrimitiveType<'tree>),
    TypeIdentifier(TypeIdentifier<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeDeclarator<'tree> {
    ///Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_array_declarator(self) -> ::std::option::Option<ArrayDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ArrayDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_attributed_declarator(
        self,
    ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AttributedDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_function_declarator(
        self,
    ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_parenthesized_declarator(
        self,
    ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ParenthesizedDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`
    #[inline]
    pub fn as_pointer_declarator(
        self,
    ) -> ::std::option::Option<PointerDeclarator<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PointerDeclarator(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`
    #[inline]
    pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PrimitiveType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
    #[inline]
    pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeIdentifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeDeclarator<'tree> {
    type WithLifetime<'a> = TypeDeclarator<'a>;
    const KIND: &'static str = "_type_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        match node.kind() {
            "array_declarator" => {
                Ok(unsafe {
                    Self::ArrayDeclarator(
                        <ArrayDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "attributed_declarator" => {
                Ok(unsafe {
                    Self::AttributedDeclarator(
                        <AttributedDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "function_declarator" => {
                Ok(unsafe {
                    Self::FunctionDeclarator(
                        <FunctionDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "parenthesized_declarator" => {
                Ok(unsafe {
                    Self::ParenthesizedDeclarator(
                        <ParenthesizedDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "pointer_declarator" => {
                Ok(unsafe {
                    Self::PointerDeclarator(
                        <PointerDeclarator<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "primitive_type" => {
                Ok(unsafe {
                    Self::PrimitiveType(
                        <PrimitiveType<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "type_identifier" => {
                Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw(x),
            Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::ArrayDeclarator(x) => x.into_raw(),
            Self::AttributedDeclarator(x) => x.into_raw(),
            Self::FunctionDeclarator(x) => x.into_raw(),
            Self::ParenthesizedDeclarator(x) => x.into_raw(),
            Self::PointerDeclarator(x) => x.into_raw(),
            Self::PrimitiveType(x) => x.into_raw(),
            Self::TypeIdentifier(x) => x.into_raw(),
        }
    }
}
/**Typed node `abstract_array_declarator`

This node has these fields:

- `declarator`: `_abstract_declarator?` ([`AbstractDeclarator`])
- `size`: `{* | expression}?` ([`symbols::Mul`] | [`Expression`])

And additional named children of type `type_qualifier*` ([`TypeQualifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AbstractArrayDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AbstractArrayDeclarator<'tree> {
    /**Get the optional field `declarator`.

This child has type `_abstract_declarator?` ([`AbstractDeclarator`])*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, AbstractDeclarator<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <AbstractDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `size`.

This child has type `{* | expression}?`:

- [`symbols::Mul`]
- [`Expression`]
*/
    #[inline]
    pub fn size(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, anon_unions::Mul_Expression<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("size")
            .map(
                <anon_unions::Mul_Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `type_qualifier*` ([`TypeQualifier`])*/
    #[inline]
    pub fn type_qualifiers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, TypeQualifier<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(<TypeQualifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AbstractArrayDeclarator<'tree> {
    type WithLifetime<'a> = AbstractArrayDeclarator<'a>;
    const KIND: &'static str = "abstract_array_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "abstract_array_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "abstract_array_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `abstract_function_declarator`

This node has these fields:

- `declarator`: `_abstract_declarator?` ([`AbstractDeclarator`])
- `parameters`: `parameter_list` ([`ParameterList`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AbstractFunctionDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AbstractFunctionDeclarator<'tree> {
    /**Get the optional field `declarator`.

This child has type `_abstract_declarator?` ([`AbstractDeclarator`])*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, AbstractDeclarator<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <AbstractDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `parameters`.

This child has type `parameter_list` ([`ParameterList`])*/
    #[inline]
    pub fn parameters(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ParameterList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<ParameterList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AbstractFunctionDeclarator<'tree> {
    type WithLifetime<'a> = AbstractFunctionDeclarator<'a>;
    const KIND: &'static str = "abstract_function_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "abstract_function_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "abstract_function_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `abstract_parenthesized_declarator`

This node has named children of type `{_abstract_declarator | ms_call_modifier}+`:

- [`AbstractDeclarator`]
- [`MsCallModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AbstractParenthesizedDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AbstractParenthesizedDeclarator<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree>
for AbstractParenthesizedDeclarator<'tree> {
    type Child = anon_unions::AbstractDeclarator_MsCallModifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AbstractParenthesizedDeclarator<'tree> {
    type WithLifetime<'a> = AbstractParenthesizedDeclarator<'a>;
    const KIND: &'static str = "abstract_parenthesized_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "abstract_parenthesized_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "abstract_parenthesized_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `abstract_pointer_declarator`

This node has these fields:

- `declarator`: `_abstract_declarator?` ([`AbstractDeclarator`])

And additional named children of type `{ms_pointer_modifier | type_qualifier}*`:

- [`MsPointerModifier`]
- [`TypeQualifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AbstractPointerDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AbstractPointerDeclarator<'tree> {
    /**Get the optional field `declarator`.

This child has type `_abstract_declarator?` ([`AbstractDeclarator`])*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, AbstractDeclarator<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <AbstractDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{ms_pointer_modifier | type_qualifier}*`:

- [`MsPointerModifier`]
- [`TypeQualifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::MsPointerModifier_TypeQualifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::MsPointerModifier_TypeQualifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AbstractPointerDeclarator<'tree> {
    type WithLifetime<'a> = AbstractPointerDeclarator<'a>;
    const KIND: &'static str = "abstract_pointer_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "abstract_pointer_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "abstract_pointer_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `alignas_qualifier`

This node has a named child of type `{expression | type_descriptor}`:

- [`Expression`]
- [`TypeDescriptor`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AlignasQualifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AlignasQualifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for AlignasQualifier<'tree> {
    type Child = anon_unions::Expression_TypeDescriptor<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AlignasQualifier<'tree> {
    type WithLifetime<'a> = AlignasQualifier<'a>;
    const KIND: &'static str = "alignas_qualifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "alignas_qualifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "alignas_qualifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `alignof_expression`

This node has these fields:

- `type`: `type_descriptor` ([`TypeDescriptor`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AlignofExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AlignofExpression<'tree> {
    /**Get the field `type`.

This child has type `type_descriptor` ([`TypeDescriptor`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeDescriptor<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeDescriptor<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AlignofExpression<'tree> {
    type WithLifetime<'a> = AlignofExpression<'a>;
    const KIND: &'static str = "alignof_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "alignof_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "alignof_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `argument_list`

This node has named children of type `{compound_statement | expression | preproc_defined}*`:

- [`CompoundStatement`]
- [`Expression`]
- [`PreprocDefined`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ArgumentList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ArgumentList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ArgumentList<'tree> {
    type Child = anon_unions::CompoundStatement_Expression_PreprocDefined<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ArgumentList<'tree> {
    type WithLifetime<'a> = ArgumentList<'a>;
    const KIND: &'static str = "argument_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "argument_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "argument_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `array_declarator`

This node has these fields:

- `declarator`: `{_declarator | _field_declarator | _type_declarator}` ([`Declarator`] | [`FieldDeclarator`] | [`TypeDeclarator`])
- `size`: `{* | expression}?` ([`symbols::Mul`] | [`Expression`])

And additional named children of type `type_qualifier*` ([`TypeQualifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ArrayDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ArrayDeclarator<'tree> {
    /**Get the field `declarator`.

This child has type `{_declarator | _field_declarator | _type_declarator}`:

- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]
*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Declarator_FieldDeclarator_TypeDeclarator<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <anon_unions::Declarator_FieldDeclarator_TypeDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `size`.

This child has type `{* | expression}?`:

- [`symbols::Mul`]
- [`Expression`]
*/
    #[inline]
    pub fn size(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, anon_unions::Mul_Expression<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("size")
            .map(
                <anon_unions::Mul_Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `type_qualifier*` ([`TypeQualifier`])*/
    #[inline]
    pub fn type_qualifiers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, TypeQualifier<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(<TypeQualifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ArrayDeclarator<'tree> {
    type WithLifetime<'a> = ArrayDeclarator<'a>;
    const KIND: &'static str = "array_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "array_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "array_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `assignment_expression`

This node has these fields:

- `left`: `{call_expression | field_expression | identifier | parenthesized_expression | pointer_expression | subscript_expression}` ([`CallExpression`] | [`FieldExpression`] | [`Identifier`] | [`ParenthesizedExpression`] | [`PointerExpression`] | [`SubscriptExpression`])
- `operator`: `{%= | &= | *= | += | -= | /= | <<= | = | >>= | ^= | |=}` ([`symbols::ModEq`] | [`symbols::AndEq`] | [`symbols::MulEq`] | [`symbols::AddEq`] | [`symbols::SubEq`] | [`symbols::DivEq`] | [`symbols::LtLtEq`] | [`symbols::Eq`] | [`symbols::GtGtEq`] | [`symbols::BitXorEq`] | [`symbols::OrEq`])
- `right`: `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AssignmentExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AssignmentExpression<'tree> {
    /**Get the field `left`.

This child has type `{call_expression | field_expression | identifier | parenthesized_expression | pointer_expression | subscript_expression}`:

- [`CallExpression`]
- [`FieldExpression`]
- [`Identifier`]
- [`ParenthesizedExpression`]
- [`PointerExpression`]
- [`SubscriptExpression`]
*/
    #[inline]
    pub fn left(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::CallExpression_FieldExpression_Identifier_ParenthesizedExpression_PointerExpression_SubscriptExpression<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(
                <anon_unions::CallExpression_FieldExpression_Identifier_ParenthesizedExpression_PointerExpression_SubscriptExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{%= | &= | *= | += | -= | /= | <<= | = | >>= | ^= | |=}`:

- [`symbols::ModEq`]
- [`symbols::AndEq`]
- [`symbols::MulEq`]
- [`symbols::AddEq`]
- [`symbols::SubEq`]
- [`symbols::DivEq`]
- [`symbols::LtLtEq`]
- [`symbols::Eq`]
- [`symbols::GtGtEq`]
- [`symbols::BitXorEq`]
- [`symbols::OrEq`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_Eq_GtGtEq_BitXorEq_OrEq<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_Eq_GtGtEq_BitXorEq_OrEq<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `right`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn right(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("right")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AssignmentExpression<'tree> {
    type WithLifetime<'a> = AssignmentExpression<'a>;
    const KIND: &'static str = "assignment_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "assignment_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "assignment_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `attribute`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `prefix`: `identifier?` ([`Identifier`])

And an optional additional named child of type `argument_list?` ([`ArgumentList`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Attribute<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Attribute<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `prefix`.

This child has type `identifier?` ([`Identifier`])*/
    #[inline]
    pub fn prefix(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("prefix")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `argument_list?` ([`ArgumentList`])*/
    #[inline]
    pub fn argument_list(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, ArgumentList<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<ArgumentList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Attribute<'tree> {
    type WithLifetime<'a> = Attribute<'a>;
    const KIND: &'static str = "attribute";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "attribute" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attribute");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `attribute_declaration`

This node has named children of type `attribute+` ([`Attribute`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AttributeDeclaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AttributeDeclaration<'tree> {
    /**Get the node's not-extra named children.

These children have type `attribute+` ([`Attribute`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn attributes<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Attribute<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Attribute<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for AttributeDeclaration<'tree> {
    type Child = Attribute<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AttributeDeclaration<'tree> {
    type WithLifetime<'a> = AttributeDeclaration<'a>;
    const KIND: &'static str = "attribute_declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "attribute_declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attribute_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `attribute_specifier`

This node has a named child of type `argument_list` ([`ArgumentList`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AttributeSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AttributeSpecifier<'tree> {
    /**Get the node's only not-extra named child.

This child has type `argument_list` ([`ArgumentList`])*/
    #[inline]
    pub fn argument_list(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ArgumentList<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<ArgumentList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for AttributeSpecifier<'tree> {
    type Child = ArgumentList<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AttributeSpecifier<'tree> {
    type WithLifetime<'a> = AttributeSpecifier<'a>;
    const KIND: &'static str = "attribute_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "attribute_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attribute_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `attributed_declarator`

This node has named children of type `{_declarator | _field_declarator | _type_declarator | attribute_declaration}+`:

- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]
- [`AttributeDeclaration`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AttributedDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AttributedDeclarator<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for AttributedDeclarator<'tree> {
    type Child = anon_unions::Declarator_FieldDeclarator_TypeDeclarator_AttributeDeclaration<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AttributedDeclarator<'tree> {
    type WithLifetime<'a> = AttributedDeclarator<'a>;
    const KIND: &'static str = "attributed_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "attributed_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attributed_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `attributed_statement`

This node has named children of type `{attribute_declaration | statement}+`:

- [`AttributeDeclaration`]
- [`Statement`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AttributedStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AttributedStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for AttributedStatement<'tree> {
    type Child = anon_unions::AttributeDeclaration_Statement<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AttributedStatement<'tree> {
    type WithLifetime<'a> = AttributedStatement<'a>;
    const KIND: &'static str = "attributed_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "attributed_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attributed_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `binary_expression`

This node has these fields:

- `left`: `{expression | preproc_defined}` ([`Expression`] | [`PreprocDefined`])
- `operator`: `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}` ([`symbols::NotEq`] | [`symbols::Mod`] | [`symbols::And`] | [`symbols::AndAnd`] | [`symbols::Mul`] | [`symbols::Add`] | [`symbols::Sub`] | [`symbols::Div`] | [`symbols::Lt`] | [`symbols::LtLt`] | [`symbols::LtEq`] | [`symbols::EqEq`] | [`symbols::Gt`] | [`symbols::GtEq`] | [`symbols::GtGt`] | [`symbols::BitXor`] | [`symbols::Or`] | [`symbols::OrOr`])
- `right`: `{expression | preproc_defined}` ([`Expression`] | [`PreprocDefined`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BinaryExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BinaryExpression<'tree> {
    /**Get the field `left`.

This child has type `{expression | preproc_defined}`:

- [`Expression`]
- [`PreprocDefined`]
*/
    #[inline]
    pub fn left(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_PreprocDefined<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(
                <anon_unions::Expression_PreprocDefined<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}`:

- [`symbols::NotEq`]
- [`symbols::Mod`]
- [`symbols::And`]
- [`symbols::AndAnd`]
- [`symbols::Mul`]
- [`symbols::Add`]
- [`symbols::Sub`]
- [`symbols::Div`]
- [`symbols::Lt`]
- [`symbols::LtLt`]
- [`symbols::LtEq`]
- [`symbols::EqEq`]
- [`symbols::Gt`]
- [`symbols::GtEq`]
- [`symbols::GtGt`]
- [`symbols::BitXor`]
- [`symbols::Or`]
- [`symbols::OrOr`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `right`.

This child has type `{expression | preproc_defined}`:

- [`Expression`]
- [`PreprocDefined`]
*/
    #[inline]
    pub fn right(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_PreprocDefined<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("right")
            .map(
                <anon_unions::Expression_PreprocDefined<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BinaryExpression<'tree> {
    type WithLifetime<'a> = BinaryExpression<'a>;
    const KIND: &'static str = "binary_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "binary_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "binary_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `bitfield_clause`

This node has a named child of type `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BitfieldClause<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BitfieldClause<'tree> {
    /**Get the node's only not-extra named child.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for BitfieldClause<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BitfieldClause<'tree> {
    type WithLifetime<'a> = BitfieldClause<'a>;
    const KIND: &'static str = "bitfield_clause";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "bitfield_clause" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "bitfield_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `break_statement`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BreakStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BreakStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BreakStatement<'tree> {
    type WithLifetime<'a> = BreakStatement<'a>;
    const KIND: &'static str = "break_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "break_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "break_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `call_expression`

This node has these fields:

- `arguments`: `argument_list` ([`ArgumentList`])
- `function`: `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CallExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CallExpression<'tree> {
    /**Get the field `arguments`.

This child has type `argument_list` ([`ArgumentList`])*/
    #[inline]
    pub fn arguments(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ArgumentList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("arguments")
            .map(<ArgumentList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `function`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn function(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("function")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CallExpression<'tree> {
    type WithLifetime<'a> = CallExpression<'a>;
    const KIND: &'static str = "call_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "call_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "call_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `case_statement`

This node has these fields:

- `value`: `expression?` ([`Expression`])

And additional named children of type `{attributed_statement | break_statement | compound_statement | continue_statement | declaration | do_statement | expression_statement | for_statement | goto_statement | if_statement | labeled_statement | return_statement | seh_leave_statement | seh_try_statement | switch_statement | type_definition | while_statement}*`:

- [`AttributedStatement`]
- [`BreakStatement`]
- [`CompoundStatement`]
- [`ContinueStatement`]
- [`Declaration`]
- [`DoStatement`]
- [`ExpressionStatement`]
- [`ForStatement`]
- [`GotoStatement`]
- [`IfStatement`]
- [`LabeledStatement`]
- [`ReturnStatement`]
- [`SehLeaveStatement`]
- [`SehTryStatement`]
- [`SwitchStatement`]
- [`TypeDefinition`]
- [`WhileStatement`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CaseStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CaseStatement<'tree> {
    /**Get the optional field `value`.

This child has type `expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attributed_statement | break_statement | compound_statement | continue_statement | declaration | do_statement | expression_statement | for_statement | goto_statement | if_statement | labeled_statement | return_statement | seh_leave_statement | seh_try_statement | switch_statement | type_definition | while_statement}*`:

- [`AttributedStatement`]
- [`BreakStatement`]
- [`CompoundStatement`]
- [`ContinueStatement`]
- [`Declaration`]
- [`DoStatement`]
- [`ExpressionStatement`]
- [`ForStatement`]
- [`GotoStatement`]
- [`IfStatement`]
- [`LabeledStatement`]
- [`ReturnStatement`]
- [`SehLeaveStatement`]
- [`SehTryStatement`]
- [`SwitchStatement`]
- [`TypeDefinition`]
- [`WhileStatement`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributedStatement_BreakStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_GotoStatement_IfStatement_LabeledStatement_ReturnStatement_SehLeaveStatement_SehTryStatement_SwitchStatement_TypeDefinition_WhileStatement<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributedStatement_BreakStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_GotoStatement_IfStatement_LabeledStatement_ReturnStatement_SehLeaveStatement_SehTryStatement_SwitchStatement_TypeDefinition_WhileStatement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CaseStatement<'tree> {
    type WithLifetime<'a> = CaseStatement<'a>;
    const KIND: &'static str = "case_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "case_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "case_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `cast_expression`

This node has these fields:

- `type`: `type_descriptor` ([`TypeDescriptor`])
- `value`: `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CastExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CastExpression<'tree> {
    /**Get the field `type`.

This child has type `type_descriptor` ([`TypeDescriptor`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeDescriptor<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeDescriptor<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CastExpression<'tree> {
    type WithLifetime<'a> = CastExpression<'a>;
    const KIND: &'static str = "cast_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "cast_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "cast_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `char_literal`

This node has named children of type `{character | escape_sequence}+`:

- [`Character`]
- [`EscapeSequence`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CharLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CharLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for CharLiteral<'tree> {
    type Child = anon_unions::Character_EscapeSequence<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CharLiteral<'tree> {
    type WithLifetime<'a> = CharLiteral<'a>;
    const KIND: &'static str = "char_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "char_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "char_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `character`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Character<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Character<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Character<'tree> {
    type WithLifetime<'a> = Character<'a>;
    const KIND: &'static str = "character";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "character" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "character");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `comma_expression`

This node has these fields:

- `left`: `expression` ([`Expression`])
- `right`: `{comma_expression | expression}` ([`CommaExpression`] | [`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CommaExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CommaExpression<'tree> {
    /**Get the field `left`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn left(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `right`.

This child has type `{comma_expression | expression}`:

- [`CommaExpression`]
- [`Expression`]
*/
    #[inline]
    pub fn right(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::CommaExpression_Expression<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("right")
            .map(
                <anon_unions::CommaExpression_Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CommaExpression<'tree> {
    type WithLifetime<'a> = CommaExpression<'a>;
    const KIND: &'static str = "comma_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "comma_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "comma_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `comment`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Comment<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Comment<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Comment<'tree> {
    type WithLifetime<'a> = Comment<'a>;
    const KIND: &'static str = "comment";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "comment" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "comment");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `compound_literal_expression`

This node has these fields:

- `type`: `type_descriptor` ([`TypeDescriptor`])
- `value`: `initializer_list` ([`InitializerList`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CompoundLiteralExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CompoundLiteralExpression<'tree> {
    /**Get the field `type`.

This child has type `type_descriptor` ([`TypeDescriptor`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeDescriptor<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeDescriptor<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `initializer_list` ([`InitializerList`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, InitializerList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(
                <InitializerList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CompoundLiteralExpression<'tree> {
    type WithLifetime<'a> = CompoundLiteralExpression<'a>;
    const KIND: &'static str = "compound_literal_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "compound_literal_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "compound_literal_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `compound_statement`

This node has named children of type `{declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CompoundStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CompoundStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for CompoundStatement<'tree> {
    type Child = anon_unions::Declaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CompoundStatement<'tree> {
    type WithLifetime<'a> = CompoundStatement<'a>;
    const KIND: &'static str = "compound_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "compound_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "compound_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `concatenated_string`

This node has named children of type `{identifier | string_literal}+`:

- [`Identifier`]
- [`StringLiteral`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConcatenatedString<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConcatenatedString<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ConcatenatedString<'tree> {
    type Child = anon_unions::Identifier_StringLiteral<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ConcatenatedString<'tree> {
    type WithLifetime<'a> = ConcatenatedString<'a>;
    const KIND: &'static str = "concatenated_string";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "concatenated_string" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "concatenated_string");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `conditional_expression`

This node has these fields:

- `alternative`: `expression` ([`Expression`])
- `condition`: `expression` ([`Expression`])
- `consequence`: `{comma_expression | expression}?` ([`CommaExpression`] | [`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConditionalExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConditionalExpression<'tree> {
    /**Get the field `alternative`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `condition`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn condition(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `consequence`.

This child has type `{comma_expression | expression}?`:

- [`CommaExpression`]
- [`Expression`]
*/
    #[inline]
    pub fn consequence(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::CommaExpression_Expression<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("consequence")
            .map(
                <anon_unions::CommaExpression_Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ConditionalExpression<'tree> {
    type WithLifetime<'a> = ConditionalExpression<'a>;
    const KIND: &'static str = "conditional_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "conditional_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "conditional_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `continue_statement`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ContinueStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ContinueStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ContinueStatement<'tree> {
    type WithLifetime<'a> = ContinueStatement<'a>;
    const KIND: &'static str = "continue_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "continue_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "continue_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `declaration`

This node has these fields:

- `declarator`: `{array_declarator | attributed_declarator | function_declarator | gnu_asm_expression | identifier | init_declarator | ms_call_modifier | parenthesized_declarator | pointer_declarator}+` ([`ArrayDeclarator`] | [`AttributedDeclarator`] | [`FunctionDeclarator`] | [`GnuAsmExpression`] | [`Identifier`] | [`InitDeclarator`] | [`MsCallModifier`] | [`ParenthesizedDeclarator`] | [`PointerDeclarator`])
- `type`: `type_specifier` ([`TypeSpecifier`])

And additional named children of type `{attribute_declaration | attribute_specifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Declaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Declaration<'tree> {
    /**Get the children of field `declarator`.

These children have type `{array_declarator | attributed_declarator | function_declarator | gnu_asm_expression | identifier | init_declarator | ms_call_modifier | parenthesized_declarator | pointer_declarator}+`:

- [`ArrayDeclarator`]
- [`AttributedDeclarator`]
- [`FunctionDeclarator`]
- [`GnuAsmExpression`]
- [`Identifier`]
- [`InitDeclarator`]
- [`MsCallModifier`]
- [`ParenthesizedDeclarator`]
- [`PointerDeclarator`]
*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn declarators<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::ArrayDeclarator_AttributedDeclarator_FunctionDeclarator_GnuAsmExpression_Identifier_InitDeclarator_MsCallModifier_ParenthesizedDeclarator_PointerDeclarator<
                'tree,
            >,
        >,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("declarator", &mut c.0)
            .map(
                <anon_unions::ArrayDeclarator_AttributedDeclarator_FunctionDeclarator_GnuAsmExpression_Identifier_InitDeclarator_MsCallModifier_ParenthesizedDeclarator_PointerDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `type`.

This child has type `type_specifier` ([`TypeSpecifier`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeSpecifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_declaration | attribute_specifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Declaration<'tree> {
    type WithLifetime<'a> = Declaration<'a>;
    const KIND: &'static str = "declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `declaration_list`

This node has named children of type `{declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DeclarationList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DeclarationList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for DeclarationList<'tree> {
    type Child = anon_unions::Declaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for DeclarationList<'tree> {
    type WithLifetime<'a> = DeclarationList<'a>;
    const KIND: &'static str = "declaration_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "declaration_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `do_statement`

This node has these fields:

- `body`: `statement` ([`Statement`])
- `condition`: `parenthesized_expression` ([`ParenthesizedExpression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DoStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DoStatement<'tree> {
    /**Get the field `body`.

This child has type `statement` ([`Statement`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Statement<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `condition`.

This child has type `parenthesized_expression` ([`ParenthesizedExpression`])*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <ParenthesizedExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for DoStatement<'tree> {
    type WithLifetime<'a> = DoStatement<'a>;
    const KIND: &'static str = "do_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "do_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "do_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `else_clause`

This node has a named child of type `statement` ([`Statement`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ElseClause<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ElseClause<'tree> {
    /**Get the node's only not-extra named child.

This child has type `statement` ([`Statement`])*/
    #[inline]
    pub fn statement(&self) -> ::type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Statement<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for ElseClause<'tree> {
    type Child = Statement<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ElseClause<'tree> {
    type WithLifetime<'a> = ElseClause<'a>;
    const KIND: &'static str = "else_clause";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "else_clause" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "else_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `enum_specifier`

This node has these fields:

- `body`: `enumerator_list?` ([`EnumeratorList`])
- `name`: `type_identifier?` ([`TypeIdentifier`])
- `underlying_type`: `primitive_type?` ([`PrimitiveType`])

And an optional additional named child of type `attribute_specifier?` ([`AttributeSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumSpecifier<'tree> {
    /**Get the optional field `body`.

This child has type `enumerator_list?` ([`EnumeratorList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, EnumeratorList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<EnumeratorList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `name`.

This child has type `type_identifier?` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `underlying_type`.

This child has type `primitive_type?` ([`PrimitiveType`])*/
    #[inline]
    pub fn underlying_type(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, PrimitiveType<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("underlying_type")
            .map(<PrimitiveType<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `attribute_specifier?` ([`AttributeSpecifier`])*/
    #[inline]
    pub fn attribute_specifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, AttributeSpecifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <AttributeSpecifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EnumSpecifier<'tree> {
    type WithLifetime<'a> = EnumSpecifier<'a>;
    const KIND: &'static str = "enum_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "enum_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enum_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `enumerator`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `value`: `expression?` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Enumerator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Enumerator<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `value`.

This child has type `expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Enumerator<'tree> {
    type WithLifetime<'a> = Enumerator<'a>;
    const KIND: &'static str = "enumerator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "enumerator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enumerator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `enumerator_list`

This node has named children of type `{enumerator | preproc_call | preproc_if | preproc_ifdef}*`:

- [`Enumerator`]
- [`PreprocCall`]
- [`PreprocIf`]
- [`PreprocIfdef`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumeratorList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumeratorList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for EnumeratorList<'tree> {
    type Child = anon_unions::Enumerator_PreprocCall_PreprocIf_PreprocIfdef<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EnumeratorList<'tree> {
    type WithLifetime<'a> = EnumeratorList<'a>;
    const KIND: &'static str = "enumerator_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "enumerator_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enumerator_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `escape_sequence`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EscapeSequence<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EscapeSequence<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EscapeSequence<'tree> {
    type WithLifetime<'a> = EscapeSequence<'a>;
    const KIND: &'static str = "escape_sequence";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "escape_sequence" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "escape_sequence");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `expression`

This node type has subtypes:

- `alignof_expression` ([`AlignofExpression`])
- `assignment_expression` ([`AssignmentExpression`])
- `binary_expression` ([`BinaryExpression`])
- `call_expression` ([`CallExpression`])
- `cast_expression` ([`CastExpression`])
- `char_literal` ([`CharLiteral`])
- `compound_literal_expression` ([`CompoundLiteralExpression`])
- `concatenated_string` ([`ConcatenatedString`])
- `conditional_expression` ([`ConditionalExpression`])
- `extension_expression` ([`ExtensionExpression`])
- `false` ([`False`])
- `field_expression` ([`FieldExpression`])
- `generic_expression` ([`GenericExpression`])
- `gnu_asm_expression` ([`GnuAsmExpression`])
- `identifier` ([`Identifier`])
- `null` ([`Null`])
- `number_literal` ([`NumberLiteral`])
- `offsetof_expression` ([`OffsetofExpression`])
- `parenthesized_expression` ([`ParenthesizedExpression`])
- `pointer_expression` ([`PointerExpression`])
- `sizeof_expression` ([`SizeofExpression`])
- `string_literal` ([`StringLiteral`])
- `subscript_expression` ([`SubscriptExpression`])
- `true` ([`True`])
- `unary_expression` ([`UnaryExpression`])
- `update_expression` ([`UpdateExpression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Expression<'tree> {
    AlignofExpression(AlignofExpression<'tree>),
    AssignmentExpression(AssignmentExpression<'tree>),
    BinaryExpression(BinaryExpression<'tree>),
    CallExpression(CallExpression<'tree>),
    CastExpression(CastExpression<'tree>),
    CharLiteral(CharLiteral<'tree>),
    CompoundLiteralExpression(CompoundLiteralExpression<'tree>),
    ConcatenatedString(ConcatenatedString<'tree>),
    ConditionalExpression(ConditionalExpression<'tree>),
    ExtensionExpression(ExtensionExpression<'tree>),
    False(False<'tree>),
    FieldExpression(FieldExpression<'tree>),
    GenericExpression(GenericExpression<'tree>),
    GnuAsmExpression(GnuAsmExpression<'tree>),
    Identifier(Identifier<'tree>),
    Null(Null<'tree>),
    NumberLiteral(NumberLiteral<'tree>),
    OffsetofExpression(OffsetofExpression<'tree>),
    ParenthesizedExpression(ParenthesizedExpression<'tree>),
    PointerExpression(PointerExpression<'tree>),
    SizeofExpression(SizeofExpression<'tree>),
    StringLiteral(StringLiteral<'tree>),
    SubscriptExpression(SubscriptExpression<'tree>),
    True(True<'tree>),
    UnaryExpression(UnaryExpression<'tree>),
    UpdateExpression(UpdateExpression<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Expression<'tree> {
    ///Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_alignof_expression(
        self,
    ) -> ::std::option::Option<AlignofExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AlignofExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_assignment_expression(
        self,
    ) -> ::std::option::Option<AssignmentExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AssignmentExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_binary_expression(self) -> ::std::option::Option<BinaryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BinaryExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CallExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CastExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CharLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_compound_literal_expression(
        self,
    ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CompoundLiteralExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`
    #[inline]
    pub fn as_concatenated_string(
        self,
    ) -> ::std::option::Option<ConcatenatedString<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConcatenatedString(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_conditional_expression(
        self,
    ) -> ::std::option::Option<ConditionalExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConditionalExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_extension_expression(
        self,
    ) -> ::std::option::Option<ExtensionExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ExtensionExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `false` ([`False`]), otherwise returns `None`
    #[inline]
    pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::False(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_field_expression(self) -> ::std::option::Option<FieldExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FieldExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_generic_expression(
        self,
    ) -> ::std::option::Option<GenericExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GenericExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_gnu_asm_expression(
        self,
    ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GnuAsmExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
    #[inline]
    pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Identifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`
    #[inline]
    pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Null(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::NumberLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_offsetof_expression(
        self,
    ) -> ::std::option::Option<OffsetofExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::OffsetofExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_parenthesized_expression(
        self,
    ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ParenthesizedExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_pointer_expression(
        self,
    ) -> ::std::option::Option<PointerExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PointerExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_sizeof_expression(self) -> ::std::option::Option<SizeofExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SizeofExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StringLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_subscript_expression(
        self,
    ) -> ::std::option::Option<SubscriptExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SubscriptExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `true` ([`True`]), otherwise returns `None`
    #[inline]
    pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::True(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_unary_expression(self) -> ::std::option::Option<UnaryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnaryExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_update_expression(self) -> ::std::option::Option<UpdateExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UpdateExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Expression<'tree> {
    type WithLifetime<'a> = Expression<'a>;
    const KIND: &'static str = "expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        match node.kind() {
            "alignof_expression" => {
                Ok(unsafe {
                    Self::AlignofExpression(
                        <AlignofExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "assignment_expression" => {
                Ok(unsafe {
                    Self::AssignmentExpression(
                        <AssignmentExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "binary_expression" => {
                Ok(unsafe {
                    Self::BinaryExpression(
                        <BinaryExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "call_expression" => {
                Ok(unsafe {
                    Self::CallExpression(
                        <CallExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "cast_expression" => {
                Ok(unsafe {
                    Self::CastExpression(
                        <CastExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "char_literal" => {
                Ok(unsafe {
                    Self::CharLiteral(
                        <CharLiteral<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "compound_literal_expression" => {
                Ok(unsafe {
                    Self::CompoundLiteralExpression(
                        <CompoundLiteralExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "concatenated_string" => {
                Ok(unsafe {
                    Self::ConcatenatedString(
                        <ConcatenatedString<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "conditional_expression" => {
                Ok(unsafe {
                    Self::ConditionalExpression(
                        <ConditionalExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "extension_expression" => {
                Ok(unsafe {
                    Self::ExtensionExpression(
                        <ExtensionExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "false" => {
                Ok(unsafe {
                    Self::False(
                        <False<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "field_expression" => {
                Ok(unsafe {
                    Self::FieldExpression(
                        <FieldExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "generic_expression" => {
                Ok(unsafe {
                    Self::GenericExpression(
                        <GenericExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "gnu_asm_expression" => {
                Ok(unsafe {
                    Self::GnuAsmExpression(
                        <GnuAsmExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "identifier" => {
                Ok(unsafe {
                    Self::Identifier(
                        <Identifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "null" => {
                Ok(unsafe {
                    Self::Null(
                        <Null<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "number_literal" => {
                Ok(unsafe {
                    Self::NumberLiteral(
                        <NumberLiteral<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "offsetof_expression" => {
                Ok(unsafe {
                    Self::OffsetofExpression(
                        <OffsetofExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "parenthesized_expression" => {
                Ok(unsafe {
                    Self::ParenthesizedExpression(
                        <ParenthesizedExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "pointer_expression" => {
                Ok(unsafe {
                    Self::PointerExpression(
                        <PointerExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "sizeof_expression" => {
                Ok(unsafe {
                    Self::SizeofExpression(
                        <SizeofExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "string_literal" => {
                Ok(unsafe {
                    Self::StringLiteral(
                        <StringLiteral<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "subscript_expression" => {
                Ok(unsafe {
                    Self::SubscriptExpression(
                        <SubscriptExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "true" => {
                Ok(unsafe {
                    Self::True(
                        <True<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "unary_expression" => {
                Ok(unsafe {
                    Self::UnaryExpression(
                        <UnaryExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "update_expression" => {
                Ok(unsafe {
                    Self::UpdateExpression(
                        <UpdateExpression<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::AlignofExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::AssignmentExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::CallExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::CastExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::CharLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::CompoundLiteralExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ConcatenatedString(x) => ::type_sitter_lib::Node::raw(x),
            Self::ConditionalExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ExtensionExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::False(x) => ::type_sitter_lib::Node::raw(x),
            Self::FieldExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::GenericExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::GnuAsmExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::Null(x) => ::type_sitter_lib::Node::raw(x),
            Self::NumberLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::OffsetofExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::PointerExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::SizeofExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::StringLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::SubscriptExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::True(x) => ::type_sitter_lib::Node::raw(x),
            Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::UpdateExpression(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::AlignofExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AssignmentExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CallExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CastExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CharLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CompoundLiteralExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ConcatenatedString(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ConditionalExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ExtensionExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::False(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FieldExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::GenericExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::GnuAsmExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Null(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::NumberLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::OffsetofExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PointerExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::SizeofExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::SubscriptExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::True(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UpdateExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::AlignofExpression(x) => x.into_raw(),
            Self::AssignmentExpression(x) => x.into_raw(),
            Self::BinaryExpression(x) => x.into_raw(),
            Self::CallExpression(x) => x.into_raw(),
            Self::CastExpression(x) => x.into_raw(),
            Self::CharLiteral(x) => x.into_raw(),
            Self::CompoundLiteralExpression(x) => x.into_raw(),
            Self::ConcatenatedString(x) => x.into_raw(),
            Self::ConditionalExpression(x) => x.into_raw(),
            Self::ExtensionExpression(x) => x.into_raw(),
            Self::False(x) => x.into_raw(),
            Self::FieldExpression(x) => x.into_raw(),
            Self::GenericExpression(x) => x.into_raw(),
            Self::GnuAsmExpression(x) => x.into_raw(),
            Self::Identifier(x) => x.into_raw(),
            Self::Null(x) => x.into_raw(),
            Self::NumberLiteral(x) => x.into_raw(),
            Self::OffsetofExpression(x) => x.into_raw(),
            Self::ParenthesizedExpression(x) => x.into_raw(),
            Self::PointerExpression(x) => x.into_raw(),
            Self::SizeofExpression(x) => x.into_raw(),
            Self::StringLiteral(x) => x.into_raw(),
            Self::SubscriptExpression(x) => x.into_raw(),
            Self::True(x) => x.into_raw(),
            Self::UnaryExpression(x) => x.into_raw(),
            Self::UpdateExpression(x) => x.into_raw(),
        }
    }
}
/**Typed node `expression_statement`

This node has an optional named child of type `{comma_expression | expression}?`:

- [`CommaExpression`]
- [`Expression`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExpressionStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExpressionStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for ExpressionStatement<'tree> {
    type Child = anon_unions::CommaExpression_Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ExpressionStatement<'tree> {
    type WithLifetime<'a> = ExpressionStatement<'a>;
    const KIND: &'static str = "expression_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "expression_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "expression_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `extension_expression`

This node has a named child of type `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExtensionExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExtensionExpression<'tree> {
    /**Get the node's only not-extra named child.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for ExtensionExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ExtensionExpression<'tree> {
    type WithLifetime<'a> = ExtensionExpression<'a>;
    const KIND: &'static str = "extension_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "extension_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "extension_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `false`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct False<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> False<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for False<'tree> {
    type WithLifetime<'a> = False<'a>;
    const KIND: &'static str = "false";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "false" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "false");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_declaration`

This node has these fields:

- `declarator`: `_field_declarator*` ([`FieldDeclarator`])
- `type`: `type_specifier` ([`TypeSpecifier`])

And additional named children of type `{attribute_declaration | attribute_specifier | bitfield_clause | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`BitfieldClause`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldDeclaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDeclaration<'tree> {
    /**Get the children of field `declarator`.

These children have type `_field_declarator*` ([`FieldDeclarator`])*/
    #[inline]
    pub fn declarators<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, FieldDeclarator<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("declarator", &mut c.0)
            .map(
                <FieldDeclarator<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `type`.

This child has type `type_specifier` ([`TypeSpecifier`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeSpecifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_declaration | attribute_specifier | bitfield_clause | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`BitfieldClause`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeDeclaration_AttributeSpecifier_BitfieldClause_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeDeclaration_AttributeSpecifier_BitfieldClause_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldDeclaration<'tree> {
    type WithLifetime<'a> = FieldDeclaration<'a>;
    const KIND: &'static str = "field_declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_declaration_list`

This node has named children of type `{field_declaration | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef}*`:

- [`FieldDeclaration`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldDeclarationList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDeclarationList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for FieldDeclarationList<'tree> {
    type Child = anon_unions::FieldDeclaration_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldDeclarationList<'tree> {
    type WithLifetime<'a> = FieldDeclarationList<'a>;
    const KIND: &'static str = "field_declaration_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_declaration_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_designator`

This node has a named child of type `field_identifier` ([`FieldIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldDesignator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDesignator<'tree> {
    /**Get the node's only not-extra named child.

This child has type `field_identifier` ([`FieldIdentifier`])*/
    #[inline]
    pub fn field_identifier(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, FieldIdentifier<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <FieldIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for FieldDesignator<'tree> {
    type Child = FieldIdentifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldDesignator<'tree> {
    type WithLifetime<'a> = FieldDesignator<'a>;
    const KIND: &'static str = "field_designator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_designator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_designator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_expression`

This node has these fields:

- `argument`: `expression` ([`Expression`])
- `field`: `field_identifier` ([`FieldIdentifier`])
- `operator`: `{-> | .}` ([`symbols::SubGt`] | [`symbols::Dot`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldExpression<'tree> {
    /**Get the field `argument`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn argument(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("argument")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `field`.

This child has type `field_identifier` ([`FieldIdentifier`])*/
    #[inline]
    pub fn field(&self) -> ::type_sitter_lib::NodeResult<'tree, FieldIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("field")
            .map(
                <FieldIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{-> | .}`:

- [`symbols::SubGt`]
- [`symbols::Dot`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, anon_unions::SubGt_Dot<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::SubGt_Dot<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldExpression<'tree> {
    type WithLifetime<'a> = FieldExpression<'a>;
    const KIND: &'static str = "field_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldIdentifier<'tree> {
    type WithLifetime<'a> = FieldIdentifier<'a>;
    const KIND: &'static str = "field_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `for_statement`

This node has these fields:

- `body`: `statement` ([`Statement`])
- `condition`: `{comma_expression | expression}?` ([`CommaExpression`] | [`Expression`])
- `initializer`: `{comma_expression | declaration | expression}?` ([`CommaExpression`] | [`Declaration`] | [`Expression`])
- `update`: `{comma_expression | expression}?` ([`CommaExpression`] | [`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ForStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ForStatement<'tree> {
    /**Get the field `body`.

This child has type `statement` ([`Statement`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Statement<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `condition`.

This child has type `{comma_expression | expression}?`:

- [`CommaExpression`]
- [`Expression`]
*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::CommaExpression_Expression<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::CommaExpression_Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `initializer`.

This child has type `{comma_expression | declaration | expression}?`:

- [`CommaExpression`]
- [`Declaration`]
- [`Expression`]
*/
    #[inline]
    pub fn initializer(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::CommaExpression_Declaration_Expression<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("initializer")
            .map(
                <anon_unions::CommaExpression_Declaration_Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `update`.

This child has type `{comma_expression | expression}?`:

- [`CommaExpression`]
- [`Expression`]
*/
    #[inline]
    pub fn update(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::CommaExpression_Expression<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("update")
            .map(
                <anon_unions::CommaExpression_Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ForStatement<'tree> {
    type WithLifetime<'a> = ForStatement<'a>;
    const KIND: &'static str = "for_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "for_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "for_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `function_declarator`

This node has these fields:

- `declarator`: `{_declarator | _field_declarator | _type_declarator}` ([`Declarator`] | [`FieldDeclarator`] | [`TypeDeclarator`])
- `parameters`: `parameter_list` ([`ParameterList`])

And additional named children of type `{attribute_specifier | call_expression | gnu_asm_expression | identifier}*`:

- [`AttributeSpecifier`]
- [`CallExpression`]
- [`GnuAsmExpression`]
- [`Identifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionDeclarator<'tree> {
    /**Get the field `declarator`.

This child has type `{_declarator | _field_declarator | _type_declarator}`:

- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]
*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Declarator_FieldDeclarator_TypeDeclarator<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <anon_unions::Declarator_FieldDeclarator_TypeDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `parameters`.

This child has type `parameter_list` ([`ParameterList`])*/
    #[inline]
    pub fn parameters(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ParameterList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<ParameterList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_specifier | call_expression | gnu_asm_expression | identifier}*`:

- [`AttributeSpecifier`]
- [`CallExpression`]
- [`GnuAsmExpression`]
- [`Identifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeSpecifier_CallExpression_GnuAsmExpression_Identifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeSpecifier_CallExpression_GnuAsmExpression_Identifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FunctionDeclarator<'tree> {
    type WithLifetime<'a> = FunctionDeclarator<'a>;
    const KIND: &'static str = "function_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "function_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `function_definition`

This node has these fields:

- `body`: `compound_statement` ([`CompoundStatement`])
- `declarator`: `_declarator` ([`Declarator`])
- `type`: `type_specifier` ([`TypeSpecifier`])

And additional named children of type `{attribute_declaration | attribute_specifier | declaration | ms_call_modifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`Declaration`]
- [`MsCallModifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionDefinition<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionDefinition<'tree> {
    /**Get the field `body`.

This child has type `compound_statement` ([`CompoundStatement`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, CompoundStatement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <CompoundStatement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `declarator`.

This child has type `_declarator` ([`Declarator`])*/
    #[inline]
    pub fn declarator(&self) -> ::type_sitter_lib::NodeResult<'tree, Declarator<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(<Declarator<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `type_specifier` ([`TypeSpecifier`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeSpecifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_declaration | attribute_specifier | declaration | ms_call_modifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`Declaration`]
- [`MsCallModifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeDeclaration_AttributeSpecifier_Declaration_MsCallModifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeDeclaration_AttributeSpecifier_Declaration_MsCallModifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FunctionDefinition<'tree> {
    type WithLifetime<'a> = FunctionDefinition<'a>;
    const KIND: &'static str = "function_definition";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "function_definition" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_definition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `generic_expression`

This node has named children of type `{expression | type_descriptor}+`:

- [`Expression`]
- [`TypeDescriptor`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenericExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenericExpression<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for GenericExpression<'tree> {
    type Child = anon_unions::Expression_TypeDescriptor<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GenericExpression<'tree> {
    type WithLifetime<'a> = GenericExpression<'a>;
    const KIND: &'static str = "generic_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "generic_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "generic_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_clobber_list`

This node has these fields:

- `register`: `{concatenated_string | string_literal}*` ([`ConcatenatedString`] | [`StringLiteral`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmClobberList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmClobberList<'tree> {
    /**Get the children of field `register`.

These children have type `{concatenated_string | string_literal}*`:

- [`ConcatenatedString`]
- [`StringLiteral`]
*/
    #[inline]
    pub fn registers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::ConcatenatedString_StringLiteral<'tree>,
        >,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("register", &mut c.0)
            .map(
                <anon_unions::ConcatenatedString_StringLiteral<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmClobberList<'tree> {
    type WithLifetime<'a> = GnuAsmClobberList<'a>;
    const KIND: &'static str = "gnu_asm_clobber_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_clobber_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_clobber_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_expression`

This node has these fields:

- `assembly_code`: `{concatenated_string | string_literal}` ([`ConcatenatedString`] | [`StringLiteral`])
- `clobbers`: `gnu_asm_clobber_list?` ([`GnuAsmClobberList`])
- `goto_labels`: `gnu_asm_goto_list?` ([`GnuAsmGotoList`])
- `input_operands`: `gnu_asm_input_operand_list?` ([`GnuAsmInputOperandList`])
- `output_operands`: `gnu_asm_output_operand_list?` ([`GnuAsmOutputOperandList`])

And additional named children of type `gnu_asm_qualifier*` ([`GnuAsmQualifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmExpression<'tree> {
    /**Get the field `assembly_code`.

This child has type `{concatenated_string | string_literal}`:

- [`ConcatenatedString`]
- [`StringLiteral`]
*/
    #[inline]
    pub fn assembly_code(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ConcatenatedString_StringLiteral<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("assembly_code")
            .map(
                <anon_unions::ConcatenatedString_StringLiteral<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `clobbers`.

This child has type `gnu_asm_clobber_list?` ([`GnuAsmClobberList`])*/
    #[inline]
    pub fn clobbers(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, GnuAsmClobberList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("clobbers")
            .map(
                <GnuAsmClobberList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `goto_labels`.

This child has type `gnu_asm_goto_list?` ([`GnuAsmGotoList`])*/
    #[inline]
    pub fn goto_labels(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, GnuAsmGotoList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("goto_labels")
            .map(<GnuAsmGotoList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `input_operands`.

This child has type `gnu_asm_input_operand_list?` ([`GnuAsmInputOperandList`])*/
    #[inline]
    pub fn input_operands(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, GnuAsmInputOperandList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("input_operands")
            .map(
                <GnuAsmInputOperandList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `output_operands`.

This child has type `gnu_asm_output_operand_list?` ([`GnuAsmOutputOperandList`])*/
    #[inline]
    pub fn output_operands(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, GnuAsmOutputOperandList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("output_operands")
            .map(
                <GnuAsmOutputOperandList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `gnu_asm_qualifier*` ([`GnuAsmQualifier`])*/
    #[inline]
    pub fn gnu_asm_qualifiers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, GnuAsmQualifier<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <GnuAsmQualifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmExpression<'tree> {
    type WithLifetime<'a> = GnuAsmExpression<'a>;
    const KIND: &'static str = "gnu_asm_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_goto_list`

This node has these fields:

- `label`: `identifier*` ([`Identifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmGotoList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmGotoList<'tree> {
    /**Get the children of field `label`.

These children have type `identifier*` ([`Identifier`])*/
    #[inline]
    pub fn labels<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("label", &mut c.0)
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmGotoList<'tree> {
    type WithLifetime<'a> = GnuAsmGotoList<'a>;
    const KIND: &'static str = "gnu_asm_goto_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_goto_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_goto_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_input_operand`

This node has these fields:

- `constraint`: `string_literal` ([`StringLiteral`])
- `symbol`: `identifier?` ([`Identifier`])
- `value`: `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmInputOperand<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmInputOperand<'tree> {
    /**Get the field `constraint`.

This child has type `string_literal` ([`StringLiteral`])*/
    #[inline]
    pub fn constraint(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, StringLiteral<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("constraint")
            .map(<StringLiteral<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `symbol`.

This child has type `identifier?` ([`Identifier`])*/
    #[inline]
    pub fn symbol(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("symbol")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `value`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmInputOperand<'tree> {
    type WithLifetime<'a> = GnuAsmInputOperand<'a>;
    const KIND: &'static str = "gnu_asm_input_operand";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_input_operand" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_input_operand");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_input_operand_list`

This node has these fields:

- `operand`: `gnu_asm_input_operand*` ([`GnuAsmInputOperand`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmInputOperandList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmInputOperandList<'tree> {
    /**Get the children of field `operand`.

These children have type `gnu_asm_input_operand*` ([`GnuAsmInputOperand`])*/
    #[inline]
    pub fn operands<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, GnuAsmInputOperand<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("operand", &mut c.0)
            .map(
                <GnuAsmInputOperand<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmInputOperandList<'tree> {
    type WithLifetime<'a> = GnuAsmInputOperandList<'a>;
    const KIND: &'static str = "gnu_asm_input_operand_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_input_operand_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_input_operand_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_output_operand`

This node has these fields:

- `constraint`: `string_literal` ([`StringLiteral`])
- `symbol`: `identifier?` ([`Identifier`])
- `value`: `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmOutputOperand<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmOutputOperand<'tree> {
    /**Get the field `constraint`.

This child has type `string_literal` ([`StringLiteral`])*/
    #[inline]
    pub fn constraint(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, StringLiteral<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("constraint")
            .map(<StringLiteral<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `symbol`.

This child has type `identifier?` ([`Identifier`])*/
    #[inline]
    pub fn symbol(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("symbol")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `value`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmOutputOperand<'tree> {
    type WithLifetime<'a> = GnuAsmOutputOperand<'a>;
    const KIND: &'static str = "gnu_asm_output_operand";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_output_operand" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_output_operand");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_output_operand_list`

This node has these fields:

- `operand`: `gnu_asm_output_operand*` ([`GnuAsmOutputOperand`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmOutputOperandList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmOutputOperandList<'tree> {
    /**Get the children of field `operand`.

These children have type `gnu_asm_output_operand*` ([`GnuAsmOutputOperand`])*/
    #[inline]
    pub fn operands<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, GnuAsmOutputOperand<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("operand", &mut c.0)
            .map(
                <GnuAsmOutputOperand<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmOutputOperandList<'tree> {
    type WithLifetime<'a> = GnuAsmOutputOperandList<'a>;
    const KIND: &'static str = "gnu_asm_output_operand_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_output_operand_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_output_operand_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gnu_asm_qualifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GnuAsmQualifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GnuAsmQualifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GnuAsmQualifier<'tree> {
    type WithLifetime<'a> = GnuAsmQualifier<'a>;
    const KIND: &'static str = "gnu_asm_qualifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gnu_asm_qualifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gnu_asm_qualifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `goto_statement`

This node has these fields:

- `label`: `statement_identifier` ([`StatementIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GotoStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GotoStatement<'tree> {
    /**Get the field `label`.

This child has type `statement_identifier` ([`StatementIdentifier`])*/
    #[inline]
    pub fn label(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, StatementIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("label")
            .map(
                <StatementIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GotoStatement<'tree> {
    type WithLifetime<'a> = GotoStatement<'a>;
    const KIND: &'static str = "goto_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "goto_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "goto_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Identifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Identifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Identifier<'tree> {
    type WithLifetime<'a> = Identifier<'a>;
    const KIND: &'static str = "identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `if_statement`

This node has these fields:

- `alternative`: `else_clause?` ([`ElseClause`])
- `condition`: `parenthesized_expression` ([`ParenthesizedExpression`])
- `consequence`: `statement` ([`Statement`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct IfStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> IfStatement<'tree> {
    /**Get the optional field `alternative`.

This child has type `else_clause?` ([`ElseClause`])*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, ElseClause<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(<ElseClause<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `condition`.

This child has type `parenthesized_expression` ([`ParenthesizedExpression`])*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <ParenthesizedExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `consequence`.

This child has type `statement` ([`Statement`])*/
    #[inline]
    pub fn consequence(&self) -> ::type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("consequence")
            .map(<Statement<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for IfStatement<'tree> {
    type WithLifetime<'a> = IfStatement<'a>;
    const KIND: &'static str = "if_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "if_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "if_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `init_declarator`

This node has these fields:

- `declarator`: `_declarator` ([`Declarator`])
- `value`: `{expression | initializer_list}` ([`Expression`] | [`InitializerList`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct InitDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> InitDeclarator<'tree> {
    /**Get the field `declarator`.

This child has type `_declarator` ([`Declarator`])*/
    #[inline]
    pub fn declarator(&self) -> ::type_sitter_lib::NodeResult<'tree, Declarator<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(<Declarator<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `{expression | initializer_list}`:

- [`Expression`]
- [`InitializerList`]
*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_InitializerList<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(
                <anon_unions::Expression_InitializerList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for InitDeclarator<'tree> {
    type WithLifetime<'a> = InitDeclarator<'a>;
    const KIND: &'static str = "init_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "init_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "init_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `initializer_list`

This node has named children of type `{expression | initializer_list | initializer_pair}*`:

- [`Expression`]
- [`InitializerList`]
- [`InitializerPair`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct InitializerList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> InitializerList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for InitializerList<'tree> {
    type Child = anon_unions::Expression_InitializerList_InitializerPair<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for InitializerList<'tree> {
    type WithLifetime<'a> = InitializerList<'a>;
    const KIND: &'static str = "initializer_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "initializer_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "initializer_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `initializer_pair`

This node has these fields:

- `designator`: `{field_designator | field_identifier | subscript_designator | subscript_range_designator}+` ([`FieldDesignator`] | [`FieldIdentifier`] | [`SubscriptDesignator`] | [`SubscriptRangeDesignator`])
- `value`: `{expression | initializer_list}` ([`Expression`] | [`InitializerList`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct InitializerPair<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> InitializerPair<'tree> {
    /**Get the children of field `designator`.

These children have type `{field_designator | field_identifier | subscript_designator | subscript_range_designator}+`:

- [`FieldDesignator`]
- [`FieldIdentifier`]
- [`SubscriptDesignator`]
- [`SubscriptRangeDesignator`]
*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn designators<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::FieldDesignator_FieldIdentifier_SubscriptDesignator_SubscriptRangeDesignator<
                'tree,
            >,
        >,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("designator", &mut c.0)
            .map(
                <anon_unions::FieldDesignator_FieldIdentifier_SubscriptDesignator_SubscriptRangeDesignator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `value`.

This child has type `{expression | initializer_list}`:

- [`Expression`]
- [`InitializerList`]
*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_InitializerList<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(
                <anon_unions::Expression_InitializerList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for InitializerPair<'tree> {
    type WithLifetime<'a> = InitializerPair<'a>;
    const KIND: &'static str = "initializer_pair";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "initializer_pair" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "initializer_pair");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `labeled_statement`

This node has these fields:

- `label`: `statement_identifier` ([`StatementIdentifier`])

And an additional named child of type `{declaration | statement}`:

- [`Declaration`]
- [`Statement`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LabeledStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LabeledStatement<'tree> {
    /**Get the field `label`.

This child has type `statement_identifier` ([`StatementIdentifier`])*/
    #[inline]
    pub fn label(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, StatementIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("label")
            .map(
                <StatementIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child.

This child has type `{declaration | statement}`:

- [`Declaration`]
- [`Statement`]
*/
    #[inline]
    pub fn other(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Declaration_Statement<'tree>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <anon_unions::Declaration_Statement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LabeledStatement<'tree> {
    type WithLifetime<'a> = LabeledStatement<'a>;
    const KIND: &'static str = "labeled_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "labeled_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "labeled_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `linkage_specification`

This node has these fields:

- `body`: `{declaration | declaration_list | function_definition}` ([`Declaration`] | [`DeclarationList`] | [`FunctionDefinition`])
- `value`: `string_literal` ([`StringLiteral`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LinkageSpecification<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LinkageSpecification<'tree> {
    /**Get the field `body`.

This child has type `{declaration | declaration_list | function_definition}`:

- [`Declaration`]
- [`DeclarationList`]
- [`FunctionDefinition`]
*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Declaration_DeclarationList_FunctionDefinition<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <anon_unions::Declaration_DeclarationList_FunctionDefinition<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `string_literal` ([`StringLiteral`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, StringLiteral<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<StringLiteral<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LinkageSpecification<'tree> {
    type WithLifetime<'a> = LinkageSpecification<'a>;
    const KIND: &'static str = "linkage_specification";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "linkage_specification" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "linkage_specification");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `macro_type_specifier`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `type`: `type_descriptor` ([`TypeDescriptor`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MacroTypeSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MacroTypeSpecifier<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `type_descriptor` ([`TypeDescriptor`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeDescriptor<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeDescriptor<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MacroTypeSpecifier<'tree> {
    type WithLifetime<'a> = MacroTypeSpecifier<'a>;
    const KIND: &'static str = "macro_type_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "macro_type_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "macro_type_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_based_modifier`

This node has a named child of type `argument_list` ([`ArgumentList`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsBasedModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsBasedModifier<'tree> {
    /**Get the node's only not-extra named child.

This child has type `argument_list` ([`ArgumentList`])*/
    #[inline]
    pub fn argument_list(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ArgumentList<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<ArgumentList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for MsBasedModifier<'tree> {
    type Child = ArgumentList<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsBasedModifier<'tree> {
    type WithLifetime<'a> = MsBasedModifier<'a>;
    const KIND: &'static str = "ms_based_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_based_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_based_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_call_modifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsCallModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsCallModifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsCallModifier<'tree> {
    type WithLifetime<'a> = MsCallModifier<'a>;
    const KIND: &'static str = "ms_call_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_call_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_call_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_declspec_modifier`

This node has a named child of type `identifier` ([`Identifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsDeclspecModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsDeclspecModifier<'tree> {
    /**Get the node's only not-extra named child.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn identifier(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for MsDeclspecModifier<'tree> {
    type Child = Identifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsDeclspecModifier<'tree> {
    type WithLifetime<'a> = MsDeclspecModifier<'a>;
    const KIND: &'static str = "ms_declspec_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_declspec_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_declspec_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_pointer_modifier`

This node has a named child of type `{ms_restrict_modifier | ms_signed_ptr_modifier | ms_unaligned_ptr_modifier | ms_unsigned_ptr_modifier}`:

- [`MsRestrictModifier`]
- [`MsSignedPtrModifier`]
- [`MsUnalignedPtrModifier`]
- [`MsUnsignedPtrModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsPointerModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsPointerModifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for MsPointerModifier<'tree> {
    type Child = anon_unions::MsRestrictModifier_MsSignedPtrModifier_MsUnalignedPtrModifier_MsUnsignedPtrModifier<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsPointerModifier<'tree> {
    type WithLifetime<'a> = MsPointerModifier<'a>;
    const KIND: &'static str = "ms_pointer_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_pointer_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_pointer_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_restrict_modifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsRestrictModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsRestrictModifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsRestrictModifier<'tree> {
    type WithLifetime<'a> = MsRestrictModifier<'a>;
    const KIND: &'static str = "ms_restrict_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_restrict_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_restrict_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_signed_ptr_modifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsSignedPtrModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsSignedPtrModifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsSignedPtrModifier<'tree> {
    type WithLifetime<'a> = MsSignedPtrModifier<'a>;
    const KIND: &'static str = "ms_signed_ptr_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_signed_ptr_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_signed_ptr_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_unaligned_ptr_modifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsUnalignedPtrModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsUnalignedPtrModifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsUnalignedPtrModifier<'tree> {
    type WithLifetime<'a> = MsUnalignedPtrModifier<'a>;
    const KIND: &'static str = "ms_unaligned_ptr_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_unaligned_ptr_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_unaligned_ptr_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ms_unsigned_ptr_modifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MsUnsignedPtrModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MsUnsignedPtrModifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MsUnsignedPtrModifier<'tree> {
    type WithLifetime<'a> = MsUnsignedPtrModifier<'a>;
    const KIND: &'static str = "ms_unsigned_ptr_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ms_unsigned_ptr_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ms_unsigned_ptr_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `null`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Null<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Null<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Null<'tree> {
    type WithLifetime<'a> = Null<'a>;
    const KIND: &'static str = "null";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "null" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "null");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `number_literal`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct NumberLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> NumberLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for NumberLiteral<'tree> {
    type WithLifetime<'a> = NumberLiteral<'a>;
    const KIND: &'static str = "number_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "number_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "number_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `offsetof_expression`

This node has these fields:

- `member`: `field_identifier` ([`FieldIdentifier`])
- `type`: `type_descriptor` ([`TypeDescriptor`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OffsetofExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OffsetofExpression<'tree> {
    /**Get the field `member`.

This child has type `field_identifier` ([`FieldIdentifier`])*/
    #[inline]
    pub fn member(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, FieldIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("member")
            .map(
                <FieldIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `type_descriptor` ([`TypeDescriptor`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeDescriptor<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeDescriptor<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for OffsetofExpression<'tree> {
    type WithLifetime<'a> = OffsetofExpression<'a>;
    const KIND: &'static str = "offsetof_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "offsetof_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "offsetof_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `parameter_declaration`

This node has these fields:

- `declarator`: `{_abstract_declarator | _declarator}?` ([`AbstractDeclarator`] | [`Declarator`])
- `type`: `type_specifier` ([`TypeSpecifier`])

And additional named children of type `{attribute_declaration | attribute_specifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ParameterDeclaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ParameterDeclaration<'tree> {
    /**Get the optional field `declarator`.

This child has type `{_abstract_declarator | _declarator}?`:

- [`AbstractDeclarator`]
- [`Declarator`]
*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AbstractDeclarator_Declarator<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <anon_unions::AbstractDeclarator_Declarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `type`.

This child has type `type_specifier` ([`TypeSpecifier`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeSpecifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_declaration | attribute_specifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}*`:

- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ParameterDeclaration<'tree> {
    type WithLifetime<'a> = ParameterDeclaration<'a>;
    const KIND: &'static str = "parameter_declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "parameter_declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parameter_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `parameter_list`

This node has named children of type `{compound_statement | identifier | parameter_declaration | variadic_parameter}*`:

- [`CompoundStatement`]
- [`Identifier`]
- [`ParameterDeclaration`]
- [`VariadicParameter`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ParameterList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ParameterList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ParameterList<'tree> {
    type Child = anon_unions::CompoundStatement_Identifier_ParameterDeclaration_VariadicParameter<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ParameterList<'tree> {
    type WithLifetime<'a> = ParameterList<'a>;
    const KIND: &'static str = "parameter_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "parameter_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parameter_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `parenthesized_declarator`

This node has named children of type `{_declarator | _field_declarator | _type_declarator | ms_call_modifier}+`:

- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]
- [`MsCallModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ParenthesizedDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ParenthesizedDeclarator<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ParenthesizedDeclarator<'tree> {
    type Child = anon_unions::Declarator_FieldDeclarator_TypeDeclarator_MsCallModifier<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ParenthesizedDeclarator<'tree> {
    type WithLifetime<'a> = ParenthesizedDeclarator<'a>;
    const KIND: &'static str = "parenthesized_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "parenthesized_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parenthesized_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `parenthesized_expression`

This node has a named child of type `{comma_expression | compound_statement | expression | preproc_defined}`:

- [`CommaExpression`]
- [`CompoundStatement`]
- [`Expression`]
- [`PreprocDefined`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ParenthesizedExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ParenthesizedExpression<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for ParenthesizedExpression<'tree> {
    type Child = anon_unions::CommaExpression_CompoundStatement_Expression_PreprocDefined<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ParenthesizedExpression<'tree> {
    type WithLifetime<'a> = ParenthesizedExpression<'a>;
    const KIND: &'static str = "parenthesized_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "parenthesized_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parenthesized_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `pointer_declarator`

This node has these fields:

- `declarator`: `{_declarator | _field_declarator | _type_declarator}` ([`Declarator`] | [`FieldDeclarator`] | [`TypeDeclarator`])

And additional named children of type `{ms_based_modifier | ms_pointer_modifier | type_qualifier}*`:

- [`MsBasedModifier`]
- [`MsPointerModifier`]
- [`TypeQualifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PointerDeclarator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PointerDeclarator<'tree> {
    /**Get the field `declarator`.

This child has type `{_declarator | _field_declarator | _type_declarator}`:

- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]
*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Declarator_FieldDeclarator_TypeDeclarator<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <anon_unions::Declarator_FieldDeclarator_TypeDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{ms_based_modifier | ms_pointer_modifier | type_qualifier}*`:

- [`MsBasedModifier`]
- [`MsPointerModifier`]
- [`TypeQualifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::MsBasedModifier_MsPointerModifier_TypeQualifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::MsBasedModifier_MsPointerModifier_TypeQualifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PointerDeclarator<'tree> {
    type WithLifetime<'a> = PointerDeclarator<'a>;
    const KIND: &'static str = "pointer_declarator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "pointer_declarator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "pointer_declarator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `pointer_expression`

This node has these fields:

- `argument`: `expression` ([`Expression`])
- `operator`: `{& | *}` ([`symbols::And`] | [`symbols::Mul`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PointerExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PointerExpression<'tree> {
    /**Get the field `argument`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn argument(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("argument")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{& | *}`:

- [`symbols::And`]
- [`symbols::Mul`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, anon_unions::And_Mul<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::And_Mul<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PointerExpression<'tree> {
    type WithLifetime<'a> = PointerExpression<'a>;
    const KIND: &'static str = "pointer_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "pointer_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "pointer_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_arg`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocArg<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocArg<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocArg<'tree> {
    type WithLifetime<'a> = PreprocArg<'a>;
    const KIND: &'static str = "preproc_arg";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_arg" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_arg");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_call`

This node has these fields:

- `argument`: `preproc_arg?` ([`PreprocArg`])
- `directive`: `preproc_directive` ([`PreprocDirective`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocCall<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocCall<'tree> {
    /**Get the optional field `argument`.

This child has type `preproc_arg?` ([`PreprocArg`])*/
    #[inline]
    pub fn argument(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, PreprocArg<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("argument")
            .map(<PreprocArg<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `directive`.

This child has type `preproc_directive` ([`PreprocDirective`])*/
    #[inline]
    pub fn directive(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, PreprocDirective<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("directive")
            .map(
                <PreprocDirective<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocCall<'tree> {
    type WithLifetime<'a> = PreprocCall<'a>;
    const KIND: &'static str = "preproc_call";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_call" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_call");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_def`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `value`: `preproc_arg?` ([`PreprocArg`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocDef<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocDef<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `value`.

This child has type `preproc_arg?` ([`PreprocArg`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, PreprocArg<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<PreprocArg<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocDef<'tree> {
    type WithLifetime<'a> = PreprocDef<'a>;
    const KIND: &'static str = "preproc_def";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_def" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_def");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_defined`

This node has a named child of type `identifier` ([`Identifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocDefined<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocDefined<'tree> {
    /**Get the node's only not-extra named child.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn identifier(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for PreprocDefined<'tree> {
    type Child = Identifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocDefined<'tree> {
    type WithLifetime<'a> = PreprocDefined<'a>;
    const KIND: &'static str = "preproc_defined";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_defined" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_defined");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_directive`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocDirective<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocDirective<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocDirective<'tree> {
    type WithLifetime<'a> = PreprocDirective<'a>;
    const KIND: &'static str = "preproc_directive";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_directive" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_directive");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_elif`

This node has these fields:

- `alternative`: `{preproc_elif | preproc_elifdef | preproc_else}?` ([`PreprocElif`] | [`PreprocElifdef`] | [`PreprocElse`])
- `condition`: `{binary_expression | call_expression | char_literal | identifier | number_literal | parenthesized_expression | preproc_defined | unary_expression}` ([`BinaryExpression`] | [`CallExpression`] | [`CharLiteral`] | [`Identifier`] | [`NumberLiteral`] | [`ParenthesizedExpression`] | [`PreprocDefined`] | [`UnaryExpression`])

And additional named children of type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocElif<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocElif<'tree> {
    /**Get the optional field `alternative`.

This child has type `{preproc_elif | preproc_elifdef | preproc_else}?`:

- [`PreprocElif`]
- [`PreprocElifdef`]
- [`PreprocElse`]
*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PreprocElif_PreprocElifdef_PreprocElse<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(
                <anon_unions::PreprocElif_PreprocElifdef_PreprocElse<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `condition`.

This child has type `{binary_expression | call_expression | char_literal | identifier | number_literal | parenthesized_expression | preproc_defined | unary_expression}`:

- [`BinaryExpression`]
- [`CallExpression`]
- [`CharLiteral`]
- [`Identifier`]
- [`NumberLiteral`]
- [`ParenthesizedExpression`]
- [`PreprocDefined`]
- [`UnaryExpression`]
*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocElif<'tree> {
    type WithLifetime<'a> = PreprocElif<'a>;
    const KIND: &'static str = "preproc_elif";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_elif" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_elif");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_elifdef`

This node has these fields:

- `alternative`: `{preproc_elif | preproc_elifdef | preproc_else}?` ([`PreprocElif`] | [`PreprocElifdef`] | [`PreprocElse`])
- `name`: `identifier` ([`Identifier`])

And additional named children of type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocElifdef<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocElifdef<'tree> {
    /**Get the optional field `alternative`.

This child has type `{preproc_elif | preproc_elifdef | preproc_else}?`:

- [`PreprocElif`]
- [`PreprocElifdef`]
- [`PreprocElse`]
*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PreprocElif_PreprocElifdef_PreprocElse<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(
                <anon_unions::PreprocElif_PreprocElifdef_PreprocElse<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocElifdef<'tree> {
    type WithLifetime<'a> = PreprocElifdef<'a>;
    const KIND: &'static str = "preproc_elifdef";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_elifdef" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_elifdef");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_else`

This node has named children of type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocElse<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocElse<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for PreprocElse<'tree> {
    type Child = anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocElse<'tree> {
    type WithLifetime<'a> = PreprocElse<'a>;
    const KIND: &'static str = "preproc_else";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_else" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_else");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_function_def`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `parameters`: `preproc_params` ([`PreprocParams`])
- `value`: `preproc_arg?` ([`PreprocArg`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocFunctionDef<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocFunctionDef<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `parameters`.

This child has type `preproc_params` ([`PreprocParams`])*/
    #[inline]
    pub fn parameters(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, PreprocParams<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<PreprocParams<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `value`.

This child has type `preproc_arg?` ([`PreprocArg`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, PreprocArg<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<PreprocArg<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocFunctionDef<'tree> {
    type WithLifetime<'a> = PreprocFunctionDef<'a>;
    const KIND: &'static str = "preproc_function_def";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_function_def" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_function_def");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_if`

This node has these fields:

- `alternative`: `{preproc_elif | preproc_elifdef | preproc_else}?` ([`PreprocElif`] | [`PreprocElifdef`] | [`PreprocElse`])
- `condition`: `{binary_expression | call_expression | char_literal | identifier | number_literal | parenthesized_expression | preproc_defined | unary_expression}` ([`BinaryExpression`] | [`CallExpression`] | [`CharLiteral`] | [`Identifier`] | [`NumberLiteral`] | [`ParenthesizedExpression`] | [`PreprocDefined`] | [`UnaryExpression`])

And additional named children of type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocIf<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocIf<'tree> {
    /**Get the optional field `alternative`.

This child has type `{preproc_elif | preproc_elifdef | preproc_else}?`:

- [`PreprocElif`]
- [`PreprocElifdef`]
- [`PreprocElse`]
*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PreprocElif_PreprocElifdef_PreprocElse<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(
                <anon_unions::PreprocElif_PreprocElifdef_PreprocElse<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `condition`.

This child has type `{binary_expression | call_expression | char_literal | identifier | number_literal | parenthesized_expression | preproc_defined | unary_expression}`:

- [`BinaryExpression`]
- [`CallExpression`]
- [`CharLiteral`]
- [`Identifier`]
- [`NumberLiteral`]
- [`ParenthesizedExpression`]
- [`PreprocDefined`]
- [`UnaryExpression`]
*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocIf<'tree> {
    type WithLifetime<'a> = PreprocIf<'a>;
    const KIND: &'static str = "preproc_if";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_if" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_if");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_ifdef`

This node has these fields:

- `alternative`: `{preproc_elif | preproc_elifdef | preproc_else}?` ([`PreprocElif`] | [`PreprocElifdef`] | [`PreprocElse`])
- `name`: `identifier` ([`Identifier`])

And additional named children of type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocIfdef<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocIfdef<'tree> {
    /**Get the optional field `alternative`.

This child has type `{preproc_elif | preproc_elifdef | preproc_else}?`:

- [`PreprocElif`]
- [`PreprocElifdef`]
- [`PreprocElse`]
*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PreprocElif_PreprocElifdef_PreprocElse<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(
                <anon_unions::PreprocElif_PreprocElifdef_PreprocElse<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}*`:

- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                'tree,
            >,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocIfdef<'tree> {
    type WithLifetime<'a> = PreprocIfdef<'a>;
    const KIND: &'static str = "preproc_ifdef";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_ifdef" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_ifdef");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_include`

This node has these fields:

- `path`: `{call_expression | identifier | string_literal | system_lib_string}` ([`CallExpression`] | [`Identifier`] | [`StringLiteral`] | [`SystemLibString`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocInclude<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocInclude<'tree> {
    /**Get the field `path`.

This child has type `{call_expression | identifier | string_literal | system_lib_string}`:

- [`CallExpression`]
- [`Identifier`]
- [`StringLiteral`]
- [`SystemLibString`]
*/
    #[inline]
    pub fn path(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::CallExpression_Identifier_StringLiteral_SystemLibString<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("path")
            .map(
                <anon_unions::CallExpression_Identifier_StringLiteral_SystemLibString<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocInclude<'tree> {
    type WithLifetime<'a> = PreprocInclude<'a>;
    const KIND: &'static str = "preproc_include";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_include" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_include");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `preproc_params`

This node has named children of type `identifier*` ([`Identifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PreprocParams<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PreprocParams<'tree> {
    /**Get the node's not-extra named children.

These children have type `identifier*` ([`Identifier`])*/
    #[inline]
    pub fn identifiers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for PreprocParams<'tree> {
    type Child = Identifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PreprocParams<'tree> {
    type WithLifetime<'a> = PreprocParams<'a>;
    const KIND: &'static str = "preproc_params";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "preproc_params" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "preproc_params");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `primitive_type`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PrimitiveType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PrimitiveType<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PrimitiveType<'tree> {
    type WithLifetime<'a> = PrimitiveType<'a>;
    const KIND: &'static str = "primitive_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "primitive_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "primitive_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `return_statement`

This node has an optional named child of type `{comma_expression | expression}?`:

- [`CommaExpression`]
- [`Expression`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReturnStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReturnStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for ReturnStatement<'tree> {
    type Child = anon_unions::CommaExpression_Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ReturnStatement<'tree> {
    type WithLifetime<'a> = ReturnStatement<'a>;
    const KIND: &'static str = "return_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "return_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "return_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `seh_except_clause`

This node has these fields:

- `body`: `compound_statement` ([`CompoundStatement`])
- `filter`: `parenthesized_expression` ([`ParenthesizedExpression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SehExceptClause<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SehExceptClause<'tree> {
    /**Get the field `body`.

This child has type `compound_statement` ([`CompoundStatement`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, CompoundStatement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <CompoundStatement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `filter`.

This child has type `parenthesized_expression` ([`ParenthesizedExpression`])*/
    #[inline]
    pub fn filter(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("filter")
            .map(
                <ParenthesizedExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SehExceptClause<'tree> {
    type WithLifetime<'a> = SehExceptClause<'a>;
    const KIND: &'static str = "seh_except_clause";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "seh_except_clause" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "seh_except_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `seh_finally_clause`

This node has these fields:

- `body`: `compound_statement` ([`CompoundStatement`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SehFinallyClause<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SehFinallyClause<'tree> {
    /**Get the field `body`.

This child has type `compound_statement` ([`CompoundStatement`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, CompoundStatement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <CompoundStatement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SehFinallyClause<'tree> {
    type WithLifetime<'a> = SehFinallyClause<'a>;
    const KIND: &'static str = "seh_finally_clause";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "seh_finally_clause" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "seh_finally_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `seh_leave_statement`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SehLeaveStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SehLeaveStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SehLeaveStatement<'tree> {
    type WithLifetime<'a> = SehLeaveStatement<'a>;
    const KIND: &'static str = "seh_leave_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "seh_leave_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "seh_leave_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `seh_try_statement`

This node has these fields:

- `body`: `compound_statement` ([`CompoundStatement`])

And an additional named child of type `{seh_except_clause | seh_finally_clause}`:

- [`SehExceptClause`]
- [`SehFinallyClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SehTryStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SehTryStatement<'tree> {
    /**Get the field `body`.

This child has type `compound_statement` ([`CompoundStatement`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, CompoundStatement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <CompoundStatement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child.

This child has type `{seh_except_clause | seh_finally_clause}`:

- [`SehExceptClause`]
- [`SehFinallyClause`]
*/
    #[inline]
    pub fn other(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::SehExceptClause_SehFinallyClause<'tree>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <anon_unions::SehExceptClause_SehFinallyClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SehTryStatement<'tree> {
    type WithLifetime<'a> = SehTryStatement<'a>;
    const KIND: &'static str = "seh_try_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "seh_try_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "seh_try_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `sized_type_specifier`

This node has these fields:

- `type`: `{primitive_type | type_identifier}?` ([`PrimitiveType`] | [`TypeIdentifier`])

And additional named children of type `type_qualifier*` ([`TypeQualifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SizedTypeSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SizedTypeSpecifier<'tree> {
    /**Get the optional field `type`.

This child has type `{primitive_type | type_identifier}?`:

- [`PrimitiveType`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::PrimitiveType_TypeIdentifier<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(
                <anon_unions::PrimitiveType_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `type_qualifier*` ([`TypeQualifier`])*/
    #[inline]
    pub fn type_qualifiers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, TypeQualifier<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(<TypeQualifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SizedTypeSpecifier<'tree> {
    type WithLifetime<'a> = SizedTypeSpecifier<'a>;
    const KIND: &'static str = "sized_type_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "sized_type_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "sized_type_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `sizeof_expression`

This node has these fields:

- `type`: `type_descriptor?` ([`TypeDescriptor`])
- `value`: `expression?` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SizeofExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SizeofExpression<'tree> {
    /**Get the optional field `type`.

This child has type `type_descriptor?` ([`TypeDescriptor`])*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeDescriptor<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeDescriptor<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `value`.

This child has type `expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SizeofExpression<'tree> {
    type WithLifetime<'a> = SizeofExpression<'a>;
    const KIND: &'static str = "sizeof_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "sizeof_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "sizeof_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `statement`

This node type has subtypes:

- `attributed_statement` ([`AttributedStatement`])
- `break_statement` ([`BreakStatement`])
- `case_statement` ([`CaseStatement`])
- `compound_statement` ([`CompoundStatement`])
- `continue_statement` ([`ContinueStatement`])
- `do_statement` ([`DoStatement`])
- `expression_statement` ([`ExpressionStatement`])
- `for_statement` ([`ForStatement`])
- `goto_statement` ([`GotoStatement`])
- `if_statement` ([`IfStatement`])
- `labeled_statement` ([`LabeledStatement`])
- `return_statement` ([`ReturnStatement`])
- `seh_leave_statement` ([`SehLeaveStatement`])
- `seh_try_statement` ([`SehTryStatement`])
- `switch_statement` ([`SwitchStatement`])
- `while_statement` ([`WhileStatement`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Statement<'tree> {
    AttributedStatement(AttributedStatement<'tree>),
    BreakStatement(BreakStatement<'tree>),
    CaseStatement(CaseStatement<'tree>),
    CompoundStatement(CompoundStatement<'tree>),
    ContinueStatement(ContinueStatement<'tree>),
    DoStatement(DoStatement<'tree>),
    ExpressionStatement(ExpressionStatement<'tree>),
    ForStatement(ForStatement<'tree>),
    GotoStatement(GotoStatement<'tree>),
    IfStatement(IfStatement<'tree>),
    LabeledStatement(LabeledStatement<'tree>),
    ReturnStatement(ReturnStatement<'tree>),
    SehLeaveStatement(SehLeaveStatement<'tree>),
    SehTryStatement(SehTryStatement<'tree>),
    SwitchStatement(SwitchStatement<'tree>),
    WhileStatement(WhileStatement<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Statement<'tree> {
    ///Returns the node if it is of type `attributed_statement` ([`AttributedStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_attributed_statement(
        self,
    ) -> ::std::option::Option<AttributedStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AttributedStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `break_statement` ([`BreakStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_break_statement(self) -> ::std::option::Option<BreakStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BreakStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `case_statement` ([`CaseStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_case_statement(self) -> ::std::option::Option<CaseStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CaseStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_compound_statement(
        self,
    ) -> ::std::option::Option<CompoundStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CompoundStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `continue_statement` ([`ContinueStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_continue_statement(
        self,
    ) -> ::std::option::Option<ContinueStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ContinueStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `do_statement` ([`DoStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_do_statement(self) -> ::std::option::Option<DoStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::DoStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_expression_statement(
        self,
    ) -> ::std::option::Option<ExpressionStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ExpressionStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `for_statement` ([`ForStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_for_statement(self) -> ::std::option::Option<ForStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ForStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `goto_statement` ([`GotoStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_goto_statement(self) -> ::std::option::Option<GotoStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GotoStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `if_statement` ([`IfStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_if_statement(self) -> ::std::option::Option<IfStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IfStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `labeled_statement` ([`LabeledStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_labeled_statement(self) -> ::std::option::Option<LabeledStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::LabeledStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `return_statement` ([`ReturnStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_return_statement(self) -> ::std::option::Option<ReturnStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReturnStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `seh_leave_statement` ([`SehLeaveStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_seh_leave_statement(
        self,
    ) -> ::std::option::Option<SehLeaveStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SehLeaveStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `seh_try_statement` ([`SehTryStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_seh_try_statement(self) -> ::std::option::Option<SehTryStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SehTryStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `switch_statement` ([`SwitchStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_switch_statement(self) -> ::std::option::Option<SwitchStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SwitchStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `while_statement` ([`WhileStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_while_statement(self) -> ::std::option::Option<WhileStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::WhileStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Statement<'tree> {
    type WithLifetime<'a> = Statement<'a>;
    const KIND: &'static str = "statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        match node.kind() {
            "attributed_statement" => {
                Ok(unsafe {
                    Self::AttributedStatement(
                        <AttributedStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "break_statement" => {
                Ok(unsafe {
                    Self::BreakStatement(
                        <BreakStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "case_statement" => {
                Ok(unsafe {
                    Self::CaseStatement(
                        <CaseStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "compound_statement" => {
                Ok(unsafe {
                    Self::CompoundStatement(
                        <CompoundStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "continue_statement" => {
                Ok(unsafe {
                    Self::ContinueStatement(
                        <ContinueStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "do_statement" => {
                Ok(unsafe {
                    Self::DoStatement(
                        <DoStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "expression_statement" => {
                Ok(unsafe {
                    Self::ExpressionStatement(
                        <ExpressionStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "for_statement" => {
                Ok(unsafe {
                    Self::ForStatement(
                        <ForStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "goto_statement" => {
                Ok(unsafe {
                    Self::GotoStatement(
                        <GotoStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "if_statement" => {
                Ok(unsafe {
                    Self::IfStatement(
                        <IfStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "labeled_statement" => {
                Ok(unsafe {
                    Self::LabeledStatement(
                        <LabeledStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "return_statement" => {
                Ok(unsafe {
                    Self::ReturnStatement(
                        <ReturnStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "seh_leave_statement" => {
                Ok(unsafe {
                    Self::SehLeaveStatement(
                        <SehLeaveStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "seh_try_statement" => {
                Ok(unsafe {
                    Self::SehTryStatement(
                        <SehTryStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "switch_statement" => {
                Ok(unsafe {
                    Self::SwitchStatement(
                        <SwitchStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "while_statement" => {
                Ok(unsafe {
                    Self::WhileStatement(
                        <WhileStatement<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::AttributedStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::BreakStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::CaseStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::ContinueStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::DoStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::ForStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::GotoStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::IfStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::LabeledStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::ReturnStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::SehLeaveStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::SehTryStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::SwitchStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::WhileStatement(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::AttributedStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::BreakStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CaseStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ContinueStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::DoStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ForStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::GotoStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::IfStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::LabeledStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ReturnStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::SehLeaveStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::SehTryStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::SwitchStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::WhileStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::AttributedStatement(x) => x.into_raw(),
            Self::BreakStatement(x) => x.into_raw(),
            Self::CaseStatement(x) => x.into_raw(),
            Self::CompoundStatement(x) => x.into_raw(),
            Self::ContinueStatement(x) => x.into_raw(),
            Self::DoStatement(x) => x.into_raw(),
            Self::ExpressionStatement(x) => x.into_raw(),
            Self::ForStatement(x) => x.into_raw(),
            Self::GotoStatement(x) => x.into_raw(),
            Self::IfStatement(x) => x.into_raw(),
            Self::LabeledStatement(x) => x.into_raw(),
            Self::ReturnStatement(x) => x.into_raw(),
            Self::SehLeaveStatement(x) => x.into_raw(),
            Self::SehTryStatement(x) => x.into_raw(),
            Self::SwitchStatement(x) => x.into_raw(),
            Self::WhileStatement(x) => x.into_raw(),
        }
    }
}
/**Typed node `statement_identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StatementIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StatementIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StatementIdentifier<'tree> {
    type WithLifetime<'a> = StatementIdentifier<'a>;
    const KIND: &'static str = "statement_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "statement_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "statement_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `storage_class_specifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StorageClassSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StorageClassSpecifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StorageClassSpecifier<'tree> {
    type WithLifetime<'a> = StorageClassSpecifier<'a>;
    const KIND: &'static str = "storage_class_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "storage_class_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "storage_class_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `string_content`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StringContent<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StringContent<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StringContent<'tree> {
    type WithLifetime<'a> = StringContent<'a>;
    const KIND: &'static str = "string_content";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "string_content" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "string_content");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `string_literal`

This node has named children of type `{escape_sequence | string_content}*`:

- [`EscapeSequence`]
- [`StringContent`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StringLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StringLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for StringLiteral<'tree> {
    type Child = anon_unions::EscapeSequence_StringContent<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StringLiteral<'tree> {
    type WithLifetime<'a> = StringLiteral<'a>;
    const KIND: &'static str = "string_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "string_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "string_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `struct_specifier`

This node has these fields:

- `body`: `field_declaration_list?` ([`FieldDeclarationList`])
- `name`: `type_identifier?` ([`TypeIdentifier`])

And additional named children of type `{attribute_specifier | ms_declspec_modifier}*`:

- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StructSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StructSpecifier<'tree> {
    /**Get the optional field `body`.

This child has type `field_declaration_list?` ([`FieldDeclarationList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, FieldDeclarationList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <FieldDeclarationList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `name`.

This child has type `type_identifier?` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_specifier | ms_declspec_modifier}*`:

- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeSpecifier_MsDeclspecModifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeSpecifier_MsDeclspecModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StructSpecifier<'tree> {
    type WithLifetime<'a> = StructSpecifier<'a>;
    const KIND: &'static str = "struct_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "struct_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "struct_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `subscript_designator`

This node has a named child of type `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SubscriptDesignator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SubscriptDesignator<'tree> {
    /**Get the node's only not-extra named child.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for SubscriptDesignator<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SubscriptDesignator<'tree> {
    type WithLifetime<'a> = SubscriptDesignator<'a>;
    const KIND: &'static str = "subscript_designator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "subscript_designator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "subscript_designator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `subscript_expression`

This node has these fields:

- `argument`: `expression` ([`Expression`])
- `index`: `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SubscriptExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SubscriptExpression<'tree> {
    /**Get the field `argument`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn argument(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("argument")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `index`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn index(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("index")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SubscriptExpression<'tree> {
    type WithLifetime<'a> = SubscriptExpression<'a>;
    const KIND: &'static str = "subscript_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "subscript_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "subscript_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `subscript_range_designator`

This node has these fields:

- `end`: `expression` ([`Expression`])
- `start`: `expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SubscriptRangeDesignator<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SubscriptRangeDesignator<'tree> {
    /**Get the field `end`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn end(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("end")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `start`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn start(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("start")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SubscriptRangeDesignator<'tree> {
    type WithLifetime<'a> = SubscriptRangeDesignator<'a>;
    const KIND: &'static str = "subscript_range_designator";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "subscript_range_designator" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "subscript_range_designator");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `switch_statement`

This node has these fields:

- `body`: `compound_statement` ([`CompoundStatement`])
- `condition`: `parenthesized_expression` ([`ParenthesizedExpression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SwitchStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SwitchStatement<'tree> {
    /**Get the field `body`.

This child has type `compound_statement` ([`CompoundStatement`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, CompoundStatement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <CompoundStatement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `condition`.

This child has type `parenthesized_expression` ([`ParenthesizedExpression`])*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <ParenthesizedExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SwitchStatement<'tree> {
    type WithLifetime<'a> = SwitchStatement<'a>;
    const KIND: &'static str = "switch_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "switch_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "switch_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `system_lib_string`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SystemLibString<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SystemLibString<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SystemLibString<'tree> {
    type WithLifetime<'a> = SystemLibString<'a>;
    const KIND: &'static str = "system_lib_string";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "system_lib_string" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "system_lib_string");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `translation_unit`

This node has named children of type `{attributed_statement | break_statement | case_statement | compound_statement | continue_statement | declaration | do_statement | expression_statement | for_statement | function_definition | goto_statement | if_statement | labeled_statement | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | return_statement | switch_statement | type_definition | type_specifier | while_statement}*`:

- [`AttributedStatement`]
- [`BreakStatement`]
- [`CaseStatement`]
- [`CompoundStatement`]
- [`ContinueStatement`]
- [`Declaration`]
- [`DoStatement`]
- [`ExpressionStatement`]
- [`ForStatement`]
- [`FunctionDefinition`]
- [`GotoStatement`]
- [`IfStatement`]
- [`LabeledStatement`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`ReturnStatement`]
- [`SwitchStatement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]
- [`WhileStatement`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TranslationUnit<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TranslationUnit<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TranslationUnit<'tree> {
    type Child = anon_unions::AttributedStatement_BreakStatement_CaseStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_FunctionDefinition_GotoStatement_IfStatement_LabeledStatement_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_ReturnStatement_SwitchStatement_TypeDefinition_TypeSpecifier_WhileStatement<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TranslationUnit<'tree> {
    type WithLifetime<'a> = TranslationUnit<'a>;
    const KIND: &'static str = "translation_unit";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "translation_unit" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "translation_unit");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `true`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct True<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> True<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for True<'tree> {
    type WithLifetime<'a> = True<'a>;
    const KIND: &'static str = "true";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "true" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "true");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_definition`

This node has these fields:

- `declarator`: `_type_declarator+` ([`TypeDeclarator`])
- `type`: `type_specifier` ([`TypeSpecifier`])

And additional named children of type `{attribute_specifier | type_qualifier}*`:

- [`AttributeSpecifier`]
- [`TypeQualifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeDefinition<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeDefinition<'tree> {
    /**Get the children of field `declarator`.

These children have type `_type_declarator+` ([`TypeDeclarator`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn declarators<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, TypeDeclarator<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("declarator", &mut c.0)
            .map(<TypeDeclarator<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `type`.

This child has type `type_specifier` ([`TypeSpecifier`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeSpecifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_specifier | type_qualifier}*`:

- [`AttributeSpecifier`]
- [`TypeQualifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeSpecifier_TypeQualifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeSpecifier_TypeQualifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeDefinition<'tree> {
    type WithLifetime<'a> = TypeDefinition<'a>;
    const KIND: &'static str = "type_definition";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_definition" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_definition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_descriptor`

This node has these fields:

- `declarator`: `_abstract_declarator?` ([`AbstractDeclarator`])
- `type`: `type_specifier` ([`TypeSpecifier`])

And additional named children of type `type_qualifier*` ([`TypeQualifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeDescriptor<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeDescriptor<'tree> {
    /**Get the optional field `declarator`.

This child has type `_abstract_declarator?` ([`AbstractDeclarator`])*/
    #[inline]
    pub fn declarator(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, AbstractDeclarator<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("declarator")
            .map(
                <AbstractDeclarator<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `type`.

This child has type `type_specifier` ([`TypeSpecifier`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeSpecifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<TypeSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `type_qualifier*` ([`TypeQualifier`])*/
    #[inline]
    pub fn type_qualifiers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, TypeQualifier<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(<TypeQualifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeDescriptor<'tree> {
    type WithLifetime<'a> = TypeDescriptor<'a>;
    const KIND: &'static str = "type_descriptor";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_descriptor" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_descriptor");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeIdentifier<'tree> {
    type WithLifetime<'a> = TypeIdentifier<'a>;
    const KIND: &'static str = "type_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_qualifier`

This node has an optional named child of type `alignas_qualifier?` ([`AlignasQualifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeQualifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeQualifier<'tree> {
    /**Get the node's only not-extra named child, if it has one.

This child has type `alignas_qualifier?` ([`AlignasQualifier`])*/
    #[inline]
    pub fn alignas_qualifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, AlignasQualifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <AlignasQualifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for TypeQualifier<'tree> {
    type Child = AlignasQualifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeQualifier<'tree> {
    type WithLifetime<'a> = TypeQualifier<'a>;
    const KIND: &'static str = "type_qualifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_qualifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_qualifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_specifier`

This node type has subtypes:

- `enum_specifier` ([`EnumSpecifier`])
- `macro_type_specifier` ([`MacroTypeSpecifier`])
- `primitive_type` ([`PrimitiveType`])
- `sized_type_specifier` ([`SizedTypeSpecifier`])
- `struct_specifier` ([`StructSpecifier`])
- `type_identifier` ([`TypeIdentifier`])
- `union_specifier` ([`UnionSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum TypeSpecifier<'tree> {
    EnumSpecifier(EnumSpecifier<'tree>),
    MacroTypeSpecifier(MacroTypeSpecifier<'tree>),
    PrimitiveType(PrimitiveType<'tree>),
    SizedTypeSpecifier(SizedTypeSpecifier<'tree>),
    StructSpecifier(StructSpecifier<'tree>),
    TypeIdentifier(TypeIdentifier<'tree>),
    UnionSpecifier(UnionSpecifier<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeSpecifier<'tree> {
    ///Returns the node if it is of type `enum_specifier` ([`EnumSpecifier`]), otherwise returns `None`
    #[inline]
    pub fn as_enum_specifier(self) -> ::std::option::Option<EnumSpecifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::EnumSpecifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `macro_type_specifier` ([`MacroTypeSpecifier`]), otherwise returns `None`
    #[inline]
    pub fn as_macro_type_specifier(
        self,
    ) -> ::std::option::Option<MacroTypeSpecifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroTypeSpecifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`
    #[inline]
    pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PrimitiveType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `sized_type_specifier` ([`SizedTypeSpecifier`]), otherwise returns `None`
    #[inline]
    pub fn as_sized_type_specifier(
        self,
    ) -> ::std::option::Option<SizedTypeSpecifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SizedTypeSpecifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `struct_specifier` ([`StructSpecifier`]), otherwise returns `None`
    #[inline]
    pub fn as_struct_specifier(self) -> ::std::option::Option<StructSpecifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StructSpecifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
    #[inline]
    pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeIdentifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `union_specifier` ([`UnionSpecifier`]), otherwise returns `None`
    #[inline]
    pub fn as_union_specifier(self) -> ::std::option::Option<UnionSpecifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnionSpecifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeSpecifier<'tree> {
    type WithLifetime<'a> = TypeSpecifier<'a>;
    const KIND: &'static str = "type_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        match node.kind() {
            "enum_specifier" => {
                Ok(unsafe {
                    Self::EnumSpecifier(
                        <EnumSpecifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "macro_type_specifier" => {
                Ok(unsafe {
                    Self::MacroTypeSpecifier(
                        <MacroTypeSpecifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "primitive_type" => {
                Ok(unsafe {
                    Self::PrimitiveType(
                        <PrimitiveType<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "sized_type_specifier" => {
                Ok(unsafe {
                    Self::SizedTypeSpecifier(
                        <SizedTypeSpecifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "struct_specifier" => {
                Ok(unsafe {
                    Self::StructSpecifier(
                        <StructSpecifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "type_identifier" => {
                Ok(unsafe {
                    Self::TypeIdentifier(
                        <TypeIdentifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            "union_specifier" => {
                Ok(unsafe {
                    Self::UnionSpecifier(
                        <UnionSpecifier<
                            'tree,
                        > as ::type_sitter_lib::Node<'tree>>::from_raw_unchecked(node),
                    )
                })
            }
            _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
        }
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::EnumSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::MacroTypeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw(x),
            Self::SizedTypeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::StructSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::UnionSpecifier(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::EnumSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MacroTypeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::SizedTypeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StructSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UnionSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::EnumSpecifier(x) => x.into_raw(),
            Self::MacroTypeSpecifier(x) => x.into_raw(),
            Self::PrimitiveType(x) => x.into_raw(),
            Self::SizedTypeSpecifier(x) => x.into_raw(),
            Self::StructSpecifier(x) => x.into_raw(),
            Self::TypeIdentifier(x) => x.into_raw(),
            Self::UnionSpecifier(x) => x.into_raw(),
        }
    }
}
/**Typed node `unary_expression`

This node has these fields:

- `argument`: `{expression | preproc_defined}` ([`Expression`] | [`PreprocDefined`])
- `operator`: `{! | + | - | ~}` ([`symbols::Not`] | [`symbols::Add`] | [`symbols::Sub`] | [`symbols::BitNot`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnaryExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnaryExpression<'tree> {
    /**Get the field `argument`.

This child has type `{expression | preproc_defined}`:

- [`Expression`]
- [`PreprocDefined`]
*/
    #[inline]
    pub fn argument(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_PreprocDefined<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("argument")
            .map(
                <anon_unions::Expression_PreprocDefined<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{! | + | - | ~}`:

- [`symbols::Not`]
- [`symbols::Add`]
- [`symbols::Sub`]
- [`symbols::BitNot`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, anon_unions::Not_Add_Sub_BitNot<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::Not_Add_Sub_BitNot<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UnaryExpression<'tree> {
    type WithLifetime<'a> = UnaryExpression<'a>;
    const KIND: &'static str = "unary_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "unary_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unary_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `union_specifier`

This node has these fields:

- `body`: `field_declaration_list?` ([`FieldDeclarationList`])
- `name`: `type_identifier?` ([`TypeIdentifier`])

And additional named children of type `{attribute_specifier | ms_declspec_modifier}*`:

- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnionSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnionSpecifier<'tree> {
    /**Get the optional field `body`.

This child has type `field_declaration_list?` ([`FieldDeclarationList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, FieldDeclarationList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <FieldDeclarationList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `name`.

This child has type `type_identifier?` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_specifier | ms_declspec_modifier}*`:

- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeSpecifier_MsDeclspecModifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeSpecifier_MsDeclspecModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UnionSpecifier<'tree> {
    type WithLifetime<'a> = UnionSpecifier<'a>;
    const KIND: &'static str = "union_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "union_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "union_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `update_expression`

This node has these fields:

- `argument`: `expression` ([`Expression`])
- `operator`: `{++ | --}` ([`symbols::AddAdd`] | [`symbols::SubSub`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UpdateExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UpdateExpression<'tree> {
    /**Get the field `argument`.

This child has type `expression` ([`Expression`])*/
    #[inline]
    pub fn argument(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("argument")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{++ | --}`:

- [`symbols::AddAdd`]
- [`symbols::SubSub`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, anon_unions::AddAdd_SubSub<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::AddAdd_SubSub<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UpdateExpression<'tree> {
    type WithLifetime<'a> = UpdateExpression<'a>;
    const KIND: &'static str = "update_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "update_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "update_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `variadic_parameter`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct VariadicParameter<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> VariadicParameter<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for VariadicParameter<'tree> {
    type WithLifetime<'a> = VariadicParameter<'a>;
    const KIND: &'static str = "variadic_parameter";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "variadic_parameter" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "variadic_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `while_statement`

This node has these fields:

- `body`: `statement` ([`Statement`])
- `condition`: `parenthesized_expression` ([`ParenthesizedExpression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct WhileStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> WhileStatement<'tree> {
    /**Get the field `body`.

This child has type `statement` ([`Statement`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Statement<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Statement<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `condition`.

This child has type `parenthesized_expression` ([`ParenthesizedExpression`])*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ParenthesizedExpression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <ParenthesizedExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for WhileStatement<'tree> {
    type WithLifetime<'a> = WhileStatement<'a>;
    const KIND: &'static str = "while_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "while_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "while_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
pub mod unnamed {
    #[allow(unused_imports)]
    use super::*;
    /**Typed node `NULL`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Null<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Null<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Null<'tree> {
        type WithLifetime<'a> = Null<'a>;
        const KIND: &'static str = "NULL";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "NULL" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "NULL");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_Alignas`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Alignas<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Alignas<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Alignas<'tree> {
        type WithLifetime<'a> = Alignas<'a>;
        const KIND: &'static str = "_Alignas";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_Alignas" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_Alignas");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_Alignof`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Alignof<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Alignof<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Alignof<'tree> {
        type WithLifetime<'a> = Alignof<'a>;
        const KIND: &'static str = "_Alignof";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_Alignof" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_Alignof");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_Atomic`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Atomic<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Atomic<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Atomic<'tree> {
        type WithLifetime<'a> = Atomic<'a>;
        const KIND: &'static str = "_Atomic";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_Atomic" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_Atomic");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_Generic`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Generic<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Generic<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Generic<'tree> {
        type WithLifetime<'a> = Generic<'a>;
        const KIND: &'static str = "_Generic";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_Generic" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_Generic");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_Nonnull`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Nonnull<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Nonnull<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Nonnull<'tree> {
        type WithLifetime<'a> = Nonnull<'a>;
        const KIND: &'static str = "_Nonnull";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_Nonnull" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_Nonnull");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_Noreturn`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Noreturn<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Noreturn<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Noreturn<'tree> {
        type WithLifetime<'a> = Noreturn<'a>;
        const KIND: &'static str = "_Noreturn";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_Noreturn" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_Noreturn");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__alignof`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Alignof_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Alignof_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Alignof_<'tree> {
        type WithLifetime<'a> = Alignof_<'a>;
        const KIND: &'static str = "__alignof";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__alignof" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__alignof");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__alignof__`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Alignof__<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Alignof__<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Alignof__<'tree> {
        type WithLifetime<'a> = Alignof__<'a>;
        const KIND: &'static str = "__alignof__";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__alignof__" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__alignof__");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__asm`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Asm<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Asm<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Asm<'tree> {
        type WithLifetime<'a> = Asm<'a>;
        const KIND: &'static str = "__asm";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__asm" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__asm");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__asm__`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Asm_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Asm_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Asm_<'tree> {
        type WithLifetime<'a> = Asm_<'a>;
        const KIND: &'static str = "__asm__";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__asm__" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__asm__");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__attribute`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Attribute<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Attribute<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Attribute<'tree> {
        type WithLifetime<'a> = Attribute<'a>;
        const KIND: &'static str = "__attribute";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__attribute" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__attribute");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__attribute__`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Attribute_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Attribute_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Attribute_<'tree> {
        type WithLifetime<'a> = Attribute_<'a>;
        const KIND: &'static str = "__attribute__";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__attribute__" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__attribute__");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__based`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Based<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Based<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Based<'tree> {
        type WithLifetime<'a> = Based<'a>;
        const KIND: &'static str = "__based";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__based" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__based");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__cdecl`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Cdecl<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Cdecl<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Cdecl<'tree> {
        type WithLifetime<'a> = Cdecl<'a>;
        const KIND: &'static str = "__cdecl";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__cdecl" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__cdecl");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__clrcall`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Clrcall<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Clrcall<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Clrcall<'tree> {
        type WithLifetime<'a> = Clrcall<'a>;
        const KIND: &'static str = "__clrcall";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__clrcall" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__clrcall");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__declspec`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Declspec<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Declspec<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Declspec<'tree> {
        type WithLifetime<'a> = Declspec<'a>;
        const KIND: &'static str = "__declspec";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__declspec" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__declspec");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__except`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Except<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Except<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Except<'tree> {
        type WithLifetime<'a> = Except<'a>;
        const KIND: &'static str = "__except";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__except" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__except");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__extension__`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Extension<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Extension<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Extension<'tree> {
        type WithLifetime<'a> = Extension<'a>;
        const KIND: &'static str = "__extension__";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__extension__" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__extension__");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__fastcall`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Fastcall<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Fastcall<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Fastcall<'tree> {
        type WithLifetime<'a> = Fastcall<'a>;
        const KIND: &'static str = "__fastcall";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__fastcall" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__fastcall");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__finally`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Finally<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Finally<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Finally<'tree> {
        type WithLifetime<'a> = Finally<'a>;
        const KIND: &'static str = "__finally";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__finally" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__finally");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__forceinline`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Forceinline<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Forceinline<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Forceinline<'tree> {
        type WithLifetime<'a> = Forceinline<'a>;
        const KIND: &'static str = "__forceinline";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__forceinline" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__forceinline");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__inline`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Inline<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Inline<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Inline<'tree> {
        type WithLifetime<'a> = Inline<'a>;
        const KIND: &'static str = "__inline";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__inline" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__inline");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__inline__`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Inline_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Inline_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Inline_<'tree> {
        type WithLifetime<'a> = Inline_<'a>;
        const KIND: &'static str = "__inline__";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__inline__" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__inline__");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__leave`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Leave<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Leave<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Leave<'tree> {
        type WithLifetime<'a> = Leave<'a>;
        const KIND: &'static str = "__leave";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__leave" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__leave");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__restrict__`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Restrict<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Restrict<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Restrict<'tree> {
        type WithLifetime<'a> = Restrict<'a>;
        const KIND: &'static str = "__restrict__";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__restrict__" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__restrict__");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__stdcall`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Stdcall<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Stdcall<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Stdcall<'tree> {
        type WithLifetime<'a> = Stdcall<'a>;
        const KIND: &'static str = "__stdcall";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__stdcall" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__stdcall");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__thiscall`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Thiscall<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Thiscall<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Thiscall<'tree> {
        type WithLifetime<'a> = Thiscall<'a>;
        const KIND: &'static str = "__thiscall";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__thiscall" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__thiscall");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__thread`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Thread<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Thread<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Thread<'tree> {
        type WithLifetime<'a> = Thread<'a>;
        const KIND: &'static str = "__thread";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__thread" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__thread");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__try`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Try<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Try<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Try<'tree> {
        type WithLifetime<'a> = Try<'a>;
        const KIND: &'static str = "__try";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__try" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__try");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__unaligned`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Unaligned<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Unaligned<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Unaligned<'tree> {
        type WithLifetime<'a> = Unaligned<'a>;
        const KIND: &'static str = "__unaligned";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__unaligned" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__unaligned");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__vectorcall`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Vectorcall<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Vectorcall<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Vectorcall<'tree> {
        type WithLifetime<'a> = Vectorcall<'a>;
        const KIND: &'static str = "__vectorcall";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__vectorcall" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__vectorcall");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `__volatile__`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Volatile<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Volatile<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Volatile<'tree> {
        type WithLifetime<'a> = Volatile<'a>;
        const KIND: &'static str = "__volatile__";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "__volatile__" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "__volatile__");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_alignof`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Alignof___<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Alignof___<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Alignof___<'tree> {
        type WithLifetime<'a> = Alignof___<'a>;
        const KIND: &'static str = "_alignof";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_alignof" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_alignof");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_unaligned`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Unaligned_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Unaligned_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Unaligned_<'tree> {
        type WithLifetime<'a> = Unaligned_<'a>;
        const KIND: &'static str = "_unaligned";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_unaligned" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_unaligned");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `alignas`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Alignas_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Alignas_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Alignas_<'tree> {
        type WithLifetime<'a> = Alignas_<'a>;
        const KIND: &'static str = "alignas";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "alignas" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "alignas");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `alignof`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Alignof____<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Alignof____<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Alignof____<'tree> {
        type WithLifetime<'a> = Alignof____<'a>;
        const KIND: &'static str = "alignof";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "alignof" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "alignof");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `asm`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Asm__<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Asm__<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Asm__<'tree> {
        type WithLifetime<'a> = Asm__<'a>;
        const KIND: &'static str = "asm";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "asm" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "asm");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `auto`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Auto<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Auto<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Auto<'tree> {
        type WithLifetime<'a> = Auto<'a>;
        const KIND: &'static str = "auto";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "auto" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "auto");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `break`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Break<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Break<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Break<'tree> {
        type WithLifetime<'a> = Break<'a>;
        const KIND: &'static str = "break";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "break" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "break");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `case`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Case<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Case<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Case<'tree> {
        type WithLifetime<'a> = Case<'a>;
        const KIND: &'static str = "case";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "case" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "case");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `const`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Const<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Const<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Const<'tree> {
        type WithLifetime<'a> = Const<'a>;
        const KIND: &'static str = "const";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "const" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "const");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `constexpr`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Constexpr<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Constexpr<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Constexpr<'tree> {
        type WithLifetime<'a> = Constexpr<'a>;
        const KIND: &'static str = "constexpr";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "constexpr" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "constexpr");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `continue`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Continue<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Continue<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Continue<'tree> {
        type WithLifetime<'a> = Continue<'a>;
        const KIND: &'static str = "continue";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "continue" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "continue");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `default`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Default<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Default<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Default<'tree> {
        type WithLifetime<'a> = Default<'a>;
        const KIND: &'static str = "default";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "default" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "default");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `defined`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Defined<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Defined<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Defined<'tree> {
        type WithLifetime<'a> = Defined<'a>;
        const KIND: &'static str = "defined";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "defined" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "defined");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `do`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Do<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Do<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Do<'tree> {
        type WithLifetime<'a> = Do<'a>;
        const KIND: &'static str = "do";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "do" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "do");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `else`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Else<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Else<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Else<'tree> {
        type WithLifetime<'a> = Else<'a>;
        const KIND: &'static str = "else";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "else" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "else");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `enum`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Enum<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Enum<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Enum<'tree> {
        type WithLifetime<'a> = Enum<'a>;
        const KIND: &'static str = "enum";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "enum" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "enum");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `extern`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Extern<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Extern<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Extern<'tree> {
        type WithLifetime<'a> = Extern<'a>;
        const KIND: &'static str = "extern";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "extern" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "extern");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `for`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct For<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> For<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for For<'tree> {
        type WithLifetime<'a> = For<'a>;
        const KIND: &'static str = "for";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "for" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "for");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `goto`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Goto<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Goto<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Goto<'tree> {
        type WithLifetime<'a> = Goto<'a>;
        const KIND: &'static str = "goto";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "goto" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "goto");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `if`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct If<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> If<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for If<'tree> {
        type WithLifetime<'a> = If<'a>;
        const KIND: &'static str = "if";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "if" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "if");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `inline`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Inline__<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Inline__<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Inline__<'tree> {
        type WithLifetime<'a> = Inline__<'a>;
        const KIND: &'static str = "inline";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "inline" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "inline");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `long`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Long<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Long<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Long<'tree> {
        type WithLifetime<'a> = Long<'a>;
        const KIND: &'static str = "long";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "long" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "long");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `noreturn`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Noreturn_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Noreturn_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Noreturn_<'tree> {
        type WithLifetime<'a> = Noreturn_<'a>;
        const KIND: &'static str = "noreturn";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "noreturn" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "noreturn");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `nullptr`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Nullptr<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Nullptr<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Nullptr<'tree> {
        type WithLifetime<'a> = Nullptr<'a>;
        const KIND: &'static str = "nullptr";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "nullptr" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "nullptr");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `offsetof`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Offsetof<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Offsetof<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Offsetof<'tree> {
        type WithLifetime<'a> = Offsetof<'a>;
        const KIND: &'static str = "offsetof";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "offsetof" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "offsetof");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `register`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Register<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Register<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Register<'tree> {
        type WithLifetime<'a> = Register<'a>;
        const KIND: &'static str = "register";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "register" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "register");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `restrict`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Restrict_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Restrict_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Restrict_<'tree> {
        type WithLifetime<'a> = Restrict_<'a>;
        const KIND: &'static str = "restrict";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "restrict" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "restrict");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `return`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Return<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Return<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Return<'tree> {
        type WithLifetime<'a> = Return<'a>;
        const KIND: &'static str = "return";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "return" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "return");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `short`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Short<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Short<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Short<'tree> {
        type WithLifetime<'a> = Short<'a>;
        const KIND: &'static str = "short";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "short" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "short");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `signed`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Signed<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Signed<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Signed<'tree> {
        type WithLifetime<'a> = Signed<'a>;
        const KIND: &'static str = "signed";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "signed" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "signed");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `sizeof`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Sizeof<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Sizeof<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Sizeof<'tree> {
        type WithLifetime<'a> = Sizeof<'a>;
        const KIND: &'static str = "sizeof";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "sizeof" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "sizeof");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `static`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Static<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Static<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Static<'tree> {
        type WithLifetime<'a> = Static<'a>;
        const KIND: &'static str = "static";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "static" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "static");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `struct`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Struct<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Struct<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Struct<'tree> {
        type WithLifetime<'a> = Struct<'a>;
        const KIND: &'static str = "struct";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "struct" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "struct");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `switch`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Switch<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Switch<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Switch<'tree> {
        type WithLifetime<'a> = Switch<'a>;
        const KIND: &'static str = "switch";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "switch" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "switch");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `thread_local`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct ThreadLocal<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ThreadLocal<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for ThreadLocal<'tree> {
        type WithLifetime<'a> = ThreadLocal<'a>;
        const KIND: &'static str = "thread_local";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "thread_local" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "thread_local");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `typedef`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Typedef<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Typedef<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Typedef<'tree> {
        type WithLifetime<'a> = Typedef<'a>;
        const KIND: &'static str = "typedef";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "typedef" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "typedef");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `union`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Union<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Union<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Union<'tree> {
        type WithLifetime<'a> = Union<'a>;
        const KIND: &'static str = "union";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "union" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "union");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `unsigned`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Unsigned<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Unsigned<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Unsigned<'tree> {
        type WithLifetime<'a> = Unsigned<'a>;
        const KIND: &'static str = "unsigned";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "unsigned" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "unsigned");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `volatile`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Volatile_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Volatile_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Volatile_<'tree> {
        type WithLifetime<'a> = Volatile_<'a>;
        const KIND: &'static str = "volatile";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "volatile" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "volatile");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `while`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct While<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> While<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for While<'tree> {
        type WithLifetime<'a> = While<'a>;
        const KIND: &'static str = "while";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "while" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "while");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
}
pub mod symbols {
    #[allow(unused_imports)]
    use super::*;
    /**Typed node `
`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Newline<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Newline<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Newline<'tree> {
        type WithLifetime<'a> = Newline<'a>;
        const KIND: &'static str = "\n";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "\n" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "\n");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `!`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Not<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Not<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Not<'tree> {
        type WithLifetime<'a> = Not<'a>;
        const KIND: &'static str = "!";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "!" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "!");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `!=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct NotEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> NotEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for NotEq<'tree> {
        type WithLifetime<'a> = NotEq<'a>;
        const KIND: &'static str = "!=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "!=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "!=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `"`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DoubleQuote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DoubleQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DoubleQuote<'tree> {
        type WithLifetime<'a> = DoubleQuote<'a>;
        const KIND: &'static str = "\"";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "\"" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "\"");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#define`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashdefine<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashdefine<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashdefine<'tree> {
        type WithLifetime<'a> = Hashdefine<'a>;
        const KIND: &'static str = "#define";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#define" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#define");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#elif`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashelif<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashelif<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashelif<'tree> {
        type WithLifetime<'a> = Hashelif<'a>;
        const KIND: &'static str = "#elif";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#elif" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#elif");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#elifdef`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashelifdef<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashelifdef<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashelifdef<'tree> {
        type WithLifetime<'a> = Hashelifdef<'a>;
        const KIND: &'static str = "#elifdef";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#elifdef" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#elifdef");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#elifndef`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashelifndef<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashelifndef<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashelifndef<'tree> {
        type WithLifetime<'a> = Hashelifndef<'a>;
        const KIND: &'static str = "#elifndef";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#elifndef" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#elifndef");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#else`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashelse<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashelse<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashelse<'tree> {
        type WithLifetime<'a> = Hashelse<'a>;
        const KIND: &'static str = "#else";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#else" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#else");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#endif`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashendif<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashendif<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashendif<'tree> {
        type WithLifetime<'a> = Hashendif<'a>;
        const KIND: &'static str = "#endif";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#endif" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#endif");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#if`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashif<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashif<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashif<'tree> {
        type WithLifetime<'a> = Hashif<'a>;
        const KIND: &'static str = "#if";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#if" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#if");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#ifdef`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashifdef<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashifdef<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashifdef<'tree> {
        type WithLifetime<'a> = Hashifdef<'a>;
        const KIND: &'static str = "#ifdef";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#ifdef" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#ifdef");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#ifndef`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashifndef<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashifndef<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashifndef<'tree> {
        type WithLifetime<'a> = Hashifndef<'a>;
        const KIND: &'static str = "#ifndef";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#ifndef" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#ifndef");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#include`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hashinclude<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hashinclude<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hashinclude<'tree> {
        type WithLifetime<'a> = Hashinclude<'a>;
        const KIND: &'static str = "#include";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#include" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#include");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `%`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mod<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mod<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Mod<'tree> {
        type WithLifetime<'a> = Mod<'a>;
        const KIND: &'static str = "%";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "%" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "%");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `%=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct ModEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ModEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for ModEq<'tree> {
        type WithLifetime<'a> = ModEq<'a>;
        const KIND: &'static str = "%=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "%=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "%=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `&`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct And<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> And<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for And<'tree> {
        type WithLifetime<'a> = And<'a>;
        const KIND: &'static str = "&";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "&" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `&&`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AndAnd<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AndAnd<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AndAnd<'tree> {
        type WithLifetime<'a> = AndAnd<'a>;
        const KIND: &'static str = "&&";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "&&" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&&");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `&=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AndEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AndEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AndEq<'tree> {
        type WithLifetime<'a> = AndEq<'a>;
        const KIND: &'static str = "&=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "&=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `'`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Quote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Quote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Quote<'tree> {
        type WithLifetime<'a> = Quote<'a>;
        const KIND: &'static str = "'";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "'" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "'");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `(`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LParen<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LParen<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LParen<'tree> {
        type WithLifetime<'a> = LParen<'a>;
        const KIND: &'static str = "(";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "(" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "(");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `)`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RParen<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RParen<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for RParen<'tree> {
        type WithLifetime<'a> = RParen<'a>;
        const KIND: &'static str = ")";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ")" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ")");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `*`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mul<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mul<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Mul<'tree> {
        type WithLifetime<'a> = Mul<'a>;
        const KIND: &'static str = "*";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "*" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `*=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct MulEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MulEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for MulEq<'tree> {
        type WithLifetime<'a> = MulEq<'a>;
        const KIND: &'static str = "*=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "*=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `+`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Add<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Add<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Add<'tree> {
        type WithLifetime<'a> = Add<'a>;
        const KIND: &'static str = "+";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "+" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "+");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `++`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AddAdd<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AddAdd<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AddAdd<'tree> {
        type WithLifetime<'a> = AddAdd<'a>;
        const KIND: &'static str = "++";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "++" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "++");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `+=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AddEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AddEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AddEq<'tree> {
        type WithLifetime<'a> = AddEq<'a>;
        const KIND: &'static str = "+=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "+=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "+=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `,`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Comma<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Comma<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Comma<'tree> {
        type WithLifetime<'a> = Comma<'a>;
        const KIND: &'static str = ",";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "," {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ",");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `-`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Sub<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Sub<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Sub<'tree> {
        type WithLifetime<'a> = Sub<'a>;
        const KIND: &'static str = "-";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "-" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "-");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `--`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct SubSub<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubSub<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for SubSub<'tree> {
        type WithLifetime<'a> = SubSub<'a>;
        const KIND: &'static str = "--";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "--" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "--");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `-=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct SubEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for SubEq<'tree> {
        type WithLifetime<'a> = SubEq<'a>;
        const KIND: &'static str = "-=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "-=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "-=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `->`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct SubGt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubGt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for SubGt<'tree> {
        type WithLifetime<'a> = SubGt<'a>;
        const KIND: &'static str = "->";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "->" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "->");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `.`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Dot<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Dot<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Dot<'tree> {
        type WithLifetime<'a> = Dot<'a>;
        const KIND: &'static str = ".";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "." {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ".");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `...`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DotDotDot<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DotDotDot<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DotDotDot<'tree> {
        type WithLifetime<'a> = DotDotDot<'a>;
        const KIND: &'static str = "...";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "..." {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "...");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `/`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Div<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Div<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Div<'tree> {
        type WithLifetime<'a> = Div<'a>;
        const KIND: &'static str = "/";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "/" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `/=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DivEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DivEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DivEq<'tree> {
        type WithLifetime<'a> = DivEq<'a>;
        const KIND: &'static str = "/=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "/=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `:`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Colon<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Colon<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Colon<'tree> {
        type WithLifetime<'a> = Colon<'a>;
        const KIND: &'static str = ":";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ":" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ":");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `::`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct ColonColon<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ColonColon<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for ColonColon<'tree> {
        type WithLifetime<'a> = ColonColon<'a>;
        const KIND: &'static str = "::";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "::" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "::");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `;`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Semicolon<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Semicolon<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Semicolon<'tree> {
        type WithLifetime<'a> = Semicolon<'a>;
        const KIND: &'static str = ";";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ";" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ";");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Lt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Lt<'tree> {
        type WithLifetime<'a> = Lt<'a>;
        const KIND: &'static str = "<";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<<`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtLt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtLt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LtLt<'tree> {
        type WithLifetime<'a> = LtLt<'a>;
        const KIND: &'static str = "<<";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<<" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<<");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<<=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtLtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtLtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LtLtEq<'tree> {
        type WithLifetime<'a> = LtLtEq<'a>;
        const KIND: &'static str = "<<=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<<=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<<=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LtEq<'tree> {
        type WithLifetime<'a> = LtEq<'a>;
        const KIND: &'static str = "<=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Eq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Eq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Eq<'tree> {
        type WithLifetime<'a> = Eq<'a>;
        const KIND: &'static str = "=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `==`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct EqEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EqEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for EqEq<'tree> {
        type WithLifetime<'a> = EqEq<'a>;
        const KIND: &'static str = "==";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "==" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "==");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Gt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Gt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Gt<'tree> {
        type WithLifetime<'a> = Gt<'a>;
        const KIND: &'static str = ">";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for GtEq<'tree> {
        type WithLifetime<'a> = GtEq<'a>;
        const KIND: &'static str = ">=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>>`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtGt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtGt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for GtGt<'tree> {
        type WithLifetime<'a> = GtGt<'a>;
        const KIND: &'static str = ">>";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">>" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">>");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>>=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtGtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtGtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for GtGtEq<'tree> {
        type WithLifetime<'a> = GtGtEq<'a>;
        const KIND: &'static str = ">>=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">>=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">>=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `?`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Question<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Question<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Question<'tree> {
        type WithLifetime<'a> = Question<'a>;
        const KIND: &'static str = "?";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "?" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "?");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `L"`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LDoubleQuote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LDoubleQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LDoubleQuote<'tree> {
        type WithLifetime<'a> = LDoubleQuote<'a>;
        const KIND: &'static str = "L\"";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "L\"" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "L\"");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `L'`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LQuote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LQuote<'tree> {
        type WithLifetime<'a> = LQuote<'a>;
        const KIND: &'static str = "L'";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "L'" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "L'");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `U"`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct UDoubleQuote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> UDoubleQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for UDoubleQuote<'tree> {
        type WithLifetime<'a> = UDoubleQuote<'a>;
        const KIND: &'static str = "U\"";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "U\"" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "U\"");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `U'`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct UQuote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> UQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for UQuote<'tree> {
        type WithLifetime<'a> = UQuote<'a>;
        const KIND: &'static str = "U'";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "U'" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "U'");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `[`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LBracket<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LBracket<'tree> {
        type WithLifetime<'a> = LBracket<'a>;
        const KIND: &'static str = "[";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "[" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "[");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `[[`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LBracketLBracket<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LBracketLBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LBracketLBracket<'tree> {
        type WithLifetime<'a> = LBracketLBracket<'a>;
        const KIND: &'static str = "[[";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "[[" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "[[");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `]`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RBracket<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for RBracket<'tree> {
        type WithLifetime<'a> = RBracket<'a>;
        const KIND: &'static str = "]";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "]" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "]");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `]]`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RBracketRBracket<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RBracketRBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for RBracketRBracket<'tree> {
        type WithLifetime<'a> = RBracketRBracket<'a>;
        const KIND: &'static str = "]]";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "]]" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "]]");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `^`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct BitXor<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BitXor<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for BitXor<'tree> {
        type WithLifetime<'a> = BitXor<'a>;
        const KIND: &'static str = "^";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "^" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "^");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `^=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct BitXorEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BitXorEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for BitXorEq<'tree> {
        type WithLifetime<'a> = BitXorEq<'a>;
        const KIND: &'static str = "^=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "^=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "^=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `u"`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct UDoubleQuote_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> UDoubleQuote_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for UDoubleQuote_<'tree> {
        type WithLifetime<'a> = UDoubleQuote_<'a>;
        const KIND: &'static str = "u\"";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "u\"" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "u\"");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `u'`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct UQuote_<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> UQuote_<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for UQuote_<'tree> {
        type WithLifetime<'a> = UQuote_<'a>;
        const KIND: &'static str = "u'";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "u'" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "u'");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `u8"`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct U8DoubleQuote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> U8DoubleQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for U8DoubleQuote<'tree> {
        type WithLifetime<'a> = U8DoubleQuote<'a>;
        const KIND: &'static str = "u8\"";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "u8\"" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "u8\"");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `u8'`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct U8Quote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> U8Quote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for U8Quote<'tree> {
        type WithLifetime<'a> = U8Quote<'a>;
        const KIND: &'static str = "u8'";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "u8'" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "u8'");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `{`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LBrace<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LBrace<'tree> {
        type WithLifetime<'a> = LBrace<'a>;
        const KIND: &'static str = "{";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "{" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "{");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `|`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Or<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Or<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Or<'tree> {
        type WithLifetime<'a> = Or<'a>;
        const KIND: &'static str = "|";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "|" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "|");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `|=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct OrEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> OrEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for OrEq<'tree> {
        type WithLifetime<'a> = OrEq<'a>;
        const KIND: &'static str = "|=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "|=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "|=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `||`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct OrOr<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> OrOr<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for OrOr<'tree> {
        type WithLifetime<'a> = OrOr<'a>;
        const KIND: &'static str = "||";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "||" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "||");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `}`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RBrace<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for RBrace<'tree> {
        type WithLifetime<'a> = RBrace<'a>;
        const KIND: &'static str = "}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "}" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "}");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `~`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct BitNot<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BitNot<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for BitNot<'tree> {
        type WithLifetime<'a> = BitNot<'a>;
        const KIND: &'static str = "~";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "~" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "~");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
}
pub mod anon_unions {
    #[allow(unused_imports)]
    use super::*;
    /**One of `{_abstract_declarator | _declarator}`:
- [`AbstractDeclarator`]
- [`Declarator`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AbstractDeclarator_Declarator<'tree> {
        AbstractDeclarator(AbstractDeclarator<'tree>),
        Declarator(Declarator<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AbstractDeclarator_Declarator<'tree> {
        ///Returns the node if it is of type `_abstract_declarator` ([`AbstractDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_abstract_declarator(
            self,
        ) -> ::std::option::Option<AbstractDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AbstractDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_declarator` ([`Declarator`]), otherwise returns `None`
        #[inline]
        pub fn as_declarator(self) -> ::std::option::Option<Declarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `abstract_array_declarator` ([`AbstractArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_array_declarator(
            self,
        ) -> ::std::option::Option<AbstractArrayDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_array_declarator()
        }
        /**Returns the node if it is of type `abstract_function_declarator` ([`AbstractFunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_function_declarator(
            self,
        ) -> ::std::option::Option<AbstractFunctionDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_function_declarator()
        }
        /**Returns the node if it is of type `abstract_parenthesized_declarator` ([`AbstractParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_parenthesized_declarator(
            self,
        ) -> ::std::option::Option<AbstractParenthesizedDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_parenthesized_declarator()
        }
        /**Returns the node if it is of type `abstract_pointer_declarator` ([`AbstractPointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_pointer_declarator(
            self,
        ) -> ::std::option::Option<AbstractPointerDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_pointer_declarator()
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_array_declarator(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_attributed_declarator(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_function_declarator(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_declarator()?.as_identifier()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_pointer_declarator(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_declarator()?.as_pointer_declarator()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AbstractDeclarator_Declarator<'tree> {
        type WithLifetime<'a> = AbstractDeclarator_Declarator<'a>;
        const KIND: &'static str = "{_abstract_declarator | _declarator}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AbstractDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AbstractDeclarator(this));
            }
            if let Ok(this) = <Declarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declarator(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AbstractDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::Declarator(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AbstractDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Declarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AbstractDeclarator(x) => x.into_raw(),
                Self::Declarator(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_abstract_declarator | ms_call_modifier}`:
- [`AbstractDeclarator`]
- [`MsCallModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AbstractDeclarator_MsCallModifier<'tree> {
        AbstractDeclarator(AbstractDeclarator<'tree>),
        MsCallModifier(MsCallModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AbstractDeclarator_MsCallModifier<'tree> {
        ///Returns the node if it is of type `_abstract_declarator` ([`AbstractDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_abstract_declarator(
            self,
        ) -> ::std::option::Option<AbstractDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AbstractDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_call_modifier` ([`MsCallModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_call_modifier(
            self,
        ) -> ::std::option::Option<MsCallModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsCallModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `abstract_array_declarator` ([`AbstractArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_array_declarator(
            self,
        ) -> ::std::option::Option<AbstractArrayDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_array_declarator()
        }
        /**Returns the node if it is of type `abstract_function_declarator` ([`AbstractFunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_function_declarator(
            self,
        ) -> ::std::option::Option<AbstractFunctionDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_function_declarator()
        }
        /**Returns the node if it is of type `abstract_parenthesized_declarator` ([`AbstractParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_parenthesized_declarator(
            self,
        ) -> ::std::option::Option<AbstractParenthesizedDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_parenthesized_declarator()
        }
        /**Returns the node if it is of type `abstract_pointer_declarator` ([`AbstractPointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_abstract_declarator` ([`AbstractDeclarator < 'tree >`], from [`as_abstract_declarator`](Self::as_abstract_declarator))*/
        #[inline]
        pub fn as_abstract_pointer_declarator(
            self,
        ) -> ::std::option::Option<AbstractPointerDeclarator<'tree>> {
            self.as_abstract_declarator()?.as_abstract_pointer_declarator()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AbstractDeclarator_MsCallModifier<'tree> {
        type WithLifetime<'a> = AbstractDeclarator_MsCallModifier<'a>;
        const KIND: &'static str = "{_abstract_declarator | ms_call_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AbstractDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AbstractDeclarator(this));
            }
            if let Ok(this) = <MsCallModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MsCallModifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AbstractDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AbstractDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AbstractDeclarator(x) => x.into_raw(),
                Self::MsCallModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{++ | --}`:
- [`symbols::AddAdd`]
- [`symbols::SubSub`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AddAdd_SubSub<'tree> {
        AddAdd(symbols::AddAdd<'tree>),
        SubSub(symbols::SubSub<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AddAdd_SubSub<'tree> {
        ///Returns the node if it is of type `++` ([`symbols::AddAdd`]), otherwise returns `None`
        #[inline]
        pub fn as_add_add(self) -> ::std::option::Option<symbols::AddAdd<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AddAdd(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `--` ([`symbols::SubSub`]), otherwise returns `None`
        #[inline]
        pub fn as_sub_sub(self) -> ::std::option::Option<symbols::SubSub<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubSub(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AddAdd_SubSub<'tree> {
        type WithLifetime<'a> = AddAdd_SubSub<'a>;
        const KIND: &'static str = "{++ | --}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "++" => {
                    Ok(unsafe {
                        Self::AddAdd(
                            <symbols::AddAdd<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "--" => {
                    Ok(unsafe {
                        Self::SubSub(
                            <symbols::SubSub<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AddAdd(x) => ::type_sitter_lib::Node::raw(x),
                Self::SubSub(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AddAdd(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SubSub(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AddAdd(x) => x.into_raw(),
                Self::SubSub(x) => x.into_raw(),
            }
        }
    }
    /**One of `{& | *}`:
- [`symbols::And`]
- [`symbols::Mul`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum And_Mul<'tree> {
        And(symbols::And<'tree>),
        Mul(symbols::Mul<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> And_Mul<'tree> {
        ///Returns the node if it is of type `&` ([`symbols::And`]), otherwise returns `None`
        #[inline]
        pub fn as_and(self) -> ::std::option::Option<symbols::And<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::And(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `*` ([`symbols::Mul`]), otherwise returns `None`
        #[inline]
        pub fn as_mul(self) -> ::std::option::Option<symbols::Mul<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mul(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for And_Mul<'tree> {
        type WithLifetime<'a> = And_Mul<'a>;
        const KIND: &'static str = "{& | *}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "&" => {
                    Ok(unsafe {
                        Self::And(
                            <symbols::And<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "*" => {
                    Ok(unsafe {
                        Self::Mul(
                            <symbols::Mul<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::And(x) => ::type_sitter_lib::Node::raw(x),
                Self::Mul(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::And(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Mul(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::And(x) => x.into_raw(),
                Self::Mul(x) => x.into_raw(),
            }
        }
    }
    /**One of `{array_declarator | attributed_declarator | function_declarator | gnu_asm_expression | identifier | init_declarator | ms_call_modifier | parenthesized_declarator | pointer_declarator}`:
- [`ArrayDeclarator`]
- [`AttributedDeclarator`]
- [`FunctionDeclarator`]
- [`GnuAsmExpression`]
- [`Identifier`]
- [`InitDeclarator`]
- [`MsCallModifier`]
- [`ParenthesizedDeclarator`]
- [`PointerDeclarator`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ArrayDeclarator_AttributedDeclarator_FunctionDeclarator_GnuAsmExpression_Identifier_InitDeclarator_MsCallModifier_ParenthesizedDeclarator_PointerDeclarator<
        'tree,
    > {
        ArrayDeclarator(ArrayDeclarator<'tree>),
        AttributedDeclarator(AttributedDeclarator<'tree>),
        FunctionDeclarator(FunctionDeclarator<'tree>),
        GnuAsmExpression(GnuAsmExpression<'tree>),
        Identifier(Identifier<'tree>),
        InitDeclarator(InitDeclarator<'tree>),
        MsCallModifier(MsCallModifier<'tree>),
        ParenthesizedDeclarator(ParenthesizedDeclarator<'tree>),
        PointerDeclarator(PointerDeclarator<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > ArrayDeclarator_AttributedDeclarator_FunctionDeclarator_GnuAsmExpression_Identifier_InitDeclarator_MsCallModifier_ParenthesizedDeclarator_PointerDeclarator<
        'tree,
    > {
        ///Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_array_declarator(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ArrayDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_attributed_declarator(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributedDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_function_declarator(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GnuAsmExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `init_declarator` ([`InitDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_init_declarator(self) -> ::std::option::Option<InitDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::InitDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_call_modifier` ([`MsCallModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_call_modifier(
            self,
        ) -> ::std::option::Option<MsCallModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsCallModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_parenthesized_declarator(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ParenthesizedDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_pointer_declarator(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PointerDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ArrayDeclarator_AttributedDeclarator_FunctionDeclarator_GnuAsmExpression_Identifier_InitDeclarator_MsCallModifier_ParenthesizedDeclarator_PointerDeclarator<
        'tree,
    > {
        type WithLifetime<'a> = ArrayDeclarator_AttributedDeclarator_FunctionDeclarator_GnuAsmExpression_Identifier_InitDeclarator_MsCallModifier_ParenthesizedDeclarator_PointerDeclarator<
            'a,
        >;
        const KIND: &'static str = "{array_declarator | attributed_declarator | function_declarator | gnu_asm_expression | identifier | init_declarator | ms_call_modifier | parenthesized_declarator | pointer_declarator}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "array_declarator" => {
                    Ok(unsafe {
                        Self::ArrayDeclarator(
                            <ArrayDeclarator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "attributed_declarator" => {
                    Ok(unsafe {
                        Self::AttributedDeclarator(
                            <AttributedDeclarator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "function_declarator" => {
                    Ok(unsafe {
                        Self::FunctionDeclarator(
                            <FunctionDeclarator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "gnu_asm_expression" => {
                    Ok(unsafe {
                        Self::GnuAsmExpression(
                            <GnuAsmExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "identifier" => {
                    Ok(unsafe {
                        Self::Identifier(
                            <Identifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "init_declarator" => {
                    Ok(unsafe {
                        Self::InitDeclarator(
                            <InitDeclarator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_call_modifier" => {
                    Ok(unsafe {
                        Self::MsCallModifier(
                            <MsCallModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "parenthesized_declarator" => {
                    Ok(unsafe {
                        Self::ParenthesizedDeclarator(
                            <ParenthesizedDeclarator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "pointer_declarator" => {
                    Ok(unsafe {
                        Self::PointerDeclarator(
                            <PointerDeclarator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::GnuAsmExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::InitDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ArrayDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AttributedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FunctionDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GnuAsmExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::InitDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ParenthesizedDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PointerDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ArrayDeclarator(x) => x.into_raw(),
                Self::AttributedDeclarator(x) => x.into_raw(),
                Self::FunctionDeclarator(x) => x.into_raw(),
                Self::GnuAsmExpression(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::InitDeclarator(x) => x.into_raw(),
                Self::MsCallModifier(x) => x.into_raw(),
                Self::ParenthesizedDeclarator(x) => x.into_raw(),
                Self::PointerDeclarator(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_declaration | attribute_specifier | bitfield_clause | ms_declspec_modifier | storage_class_specifier | type_qualifier}`:
- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`BitfieldClause`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeDeclaration_AttributeSpecifier_BitfieldClause_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        AttributeDeclaration(AttributeDeclaration<'tree>),
        AttributeSpecifier(AttributeSpecifier<'tree>),
        BitfieldClause(BitfieldClause<'tree>),
        MsDeclspecModifier(MsDeclspecModifier<'tree>),
        StorageClassSpecifier(StorageClassSpecifier<'tree>),
        TypeQualifier(TypeQualifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > AttributeDeclaration_AttributeSpecifier_BitfieldClause_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        ///Returns the node if it is of type `attribute_declaration` ([`AttributeDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_declaration(
            self,
        ) -> ::std::option::Option<AttributeDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `attribute_specifier` ([`AttributeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_specifier(
            self,
        ) -> ::std::option::Option<AttributeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `bitfield_clause` ([`BitfieldClause`]), otherwise returns `None`
        #[inline]
        pub fn as_bitfield_clause(self) -> ::std::option::Option<BitfieldClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitfieldClause(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_declspec_modifier` ([`MsDeclspecModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_declspec_modifier(
            self,
        ) -> ::std::option::Option<MsDeclspecModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsDeclspecModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `storage_class_specifier` ([`StorageClassSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_storage_class_specifier(
            self,
        ) -> ::std::option::Option<StorageClassSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StorageClassSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_qualifier` ([`TypeQualifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_qualifier(self) -> ::std::option::Option<TypeQualifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeQualifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeDeclaration_AttributeSpecifier_BitfieldClause_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        type WithLifetime<'a> = AttributeDeclaration_AttributeSpecifier_BitfieldClause_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
            'a,
        >;
        const KIND: &'static str = "{attribute_declaration | attribute_specifier | bitfield_clause | ms_declspec_modifier | storage_class_specifier | type_qualifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "attribute_declaration" => {
                    Ok(unsafe {
                        Self::AttributeDeclaration(
                            <AttributeDeclaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "attribute_specifier" => {
                    Ok(unsafe {
                        Self::AttributeSpecifier(
                            <AttributeSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "bitfield_clause" => {
                    Ok(unsafe {
                        Self::BitfieldClause(
                            <BitfieldClause<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_declspec_modifier" => {
                    Ok(unsafe {
                        Self::MsDeclspecModifier(
                            <MsDeclspecModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "storage_class_specifier" => {
                    Ok(unsafe {
                        Self::StorageClassSpecifier(
                            <StorageClassSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_qualifier" => {
                    Ok(unsafe {
                        Self::TypeQualifier(
                            <TypeQualifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::BitfieldClause(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::StorageClassSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BitfieldClause(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StorageClassSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => x.into_raw(),
                Self::AttributeSpecifier(x) => x.into_raw(),
                Self::BitfieldClause(x) => x.into_raw(),
                Self::MsDeclspecModifier(x) => x.into_raw(),
                Self::StorageClassSpecifier(x) => x.into_raw(),
                Self::TypeQualifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_declaration | attribute_specifier | declaration | ms_call_modifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}`:
- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`Declaration`]
- [`MsCallModifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeDeclaration_AttributeSpecifier_Declaration_MsCallModifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        AttributeDeclaration(AttributeDeclaration<'tree>),
        AttributeSpecifier(AttributeSpecifier<'tree>),
        Declaration(Declaration<'tree>),
        MsCallModifier(MsCallModifier<'tree>),
        MsDeclspecModifier(MsDeclspecModifier<'tree>),
        StorageClassSpecifier(StorageClassSpecifier<'tree>),
        TypeQualifier(TypeQualifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > AttributeDeclaration_AttributeSpecifier_Declaration_MsCallModifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        ///Returns the node if it is of type `attribute_declaration` ([`AttributeDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_declaration(
            self,
        ) -> ::std::option::Option<AttributeDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `attribute_specifier` ([`AttributeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_specifier(
            self,
        ) -> ::std::option::Option<AttributeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_call_modifier` ([`MsCallModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_call_modifier(
            self,
        ) -> ::std::option::Option<MsCallModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsCallModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_declspec_modifier` ([`MsDeclspecModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_declspec_modifier(
            self,
        ) -> ::std::option::Option<MsDeclspecModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsDeclspecModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `storage_class_specifier` ([`StorageClassSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_storage_class_specifier(
            self,
        ) -> ::std::option::Option<StorageClassSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StorageClassSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_qualifier` ([`TypeQualifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_qualifier(self) -> ::std::option::Option<TypeQualifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeQualifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeDeclaration_AttributeSpecifier_Declaration_MsCallModifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        type WithLifetime<'a> = AttributeDeclaration_AttributeSpecifier_Declaration_MsCallModifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
            'a,
        >;
        const KIND: &'static str = "{attribute_declaration | attribute_specifier | declaration | ms_call_modifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "attribute_declaration" => {
                    Ok(unsafe {
                        Self::AttributeDeclaration(
                            <AttributeDeclaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "attribute_specifier" => {
                    Ok(unsafe {
                        Self::AttributeSpecifier(
                            <AttributeSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "declaration" => {
                    Ok(unsafe {
                        Self::Declaration(
                            <Declaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_call_modifier" => {
                    Ok(unsafe {
                        Self::MsCallModifier(
                            <MsCallModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_declspec_modifier" => {
                    Ok(unsafe {
                        Self::MsDeclspecModifier(
                            <MsDeclspecModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "storage_class_specifier" => {
                    Ok(unsafe {
                        Self::StorageClassSpecifier(
                            <StorageClassSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_qualifier" => {
                    Ok(unsafe {
                        Self::TypeQualifier(
                            <TypeQualifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::StorageClassSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StorageClassSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => x.into_raw(),
                Self::AttributeSpecifier(x) => x.into_raw(),
                Self::Declaration(x) => x.into_raw(),
                Self::MsCallModifier(x) => x.into_raw(),
                Self::MsDeclspecModifier(x) => x.into_raw(),
                Self::StorageClassSpecifier(x) => x.into_raw(),
                Self::TypeQualifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_declaration | attribute_specifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}`:
- [`AttributeDeclaration`]
- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]
- [`StorageClassSpecifier`]
- [`TypeQualifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        AttributeDeclaration(AttributeDeclaration<'tree>),
        AttributeSpecifier(AttributeSpecifier<'tree>),
        MsDeclspecModifier(MsDeclspecModifier<'tree>),
        StorageClassSpecifier(StorageClassSpecifier<'tree>),
        TypeQualifier(TypeQualifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        ///Returns the node if it is of type `attribute_declaration` ([`AttributeDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_declaration(
            self,
        ) -> ::std::option::Option<AttributeDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `attribute_specifier` ([`AttributeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_specifier(
            self,
        ) -> ::std::option::Option<AttributeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_declspec_modifier` ([`MsDeclspecModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_declspec_modifier(
            self,
        ) -> ::std::option::Option<MsDeclspecModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsDeclspecModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `storage_class_specifier` ([`StorageClassSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_storage_class_specifier(
            self,
        ) -> ::std::option::Option<StorageClassSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StorageClassSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_qualifier` ([`TypeQualifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_qualifier(self) -> ::std::option::Option<TypeQualifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeQualifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
        'tree,
    > {
        type WithLifetime<'a> = AttributeDeclaration_AttributeSpecifier_MsDeclspecModifier_StorageClassSpecifier_TypeQualifier<
            'a,
        >;
        const KIND: &'static str = "{attribute_declaration | attribute_specifier | ms_declspec_modifier | storage_class_specifier | type_qualifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "attribute_declaration" => {
                    Ok(unsafe {
                        Self::AttributeDeclaration(
                            <AttributeDeclaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "attribute_specifier" => {
                    Ok(unsafe {
                        Self::AttributeSpecifier(
                            <AttributeSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_declspec_modifier" => {
                    Ok(unsafe {
                        Self::MsDeclspecModifier(
                            <MsDeclspecModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "storage_class_specifier" => {
                    Ok(unsafe {
                        Self::StorageClassSpecifier(
                            <StorageClassSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_qualifier" => {
                    Ok(unsafe {
                        Self::TypeQualifier(
                            <TypeQualifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::StorageClassSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StorageClassSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => x.into_raw(),
                Self::AttributeSpecifier(x) => x.into_raw(),
                Self::MsDeclspecModifier(x) => x.into_raw(),
                Self::StorageClassSpecifier(x) => x.into_raw(),
                Self::TypeQualifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_declaration | statement}`:
- [`AttributeDeclaration`]
- [`Statement`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeDeclaration_Statement<'tree> {
        AttributeDeclaration(AttributeDeclaration<'tree>),
        Statement(Statement<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeDeclaration_Statement<'tree> {
        ///Returns the node if it is of type `attribute_declaration` ([`AttributeDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_declaration(
            self,
        ) -> ::std::option::Option<AttributeDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `statement` ([`Statement`]), otherwise returns `None`
        #[inline]
        pub fn as_statement(self) -> ::std::option::Option<Statement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Statement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `attributed_statement` ([`AttributedStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_attributed_statement(
            self,
        ) -> ::std::option::Option<AttributedStatement<'tree>> {
            self.as_statement()?.as_attributed_statement()
        }
        /**Returns the node if it is of type `break_statement` ([`BreakStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_break_statement(self) -> ::std::option::Option<BreakStatement<'tree>> {
            self.as_statement()?.as_break_statement()
        }
        /**Returns the node if it is of type `case_statement` ([`CaseStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_case_statement(self) -> ::std::option::Option<CaseStatement<'tree>> {
            self.as_statement()?.as_case_statement()
        }
        /**Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            self.as_statement()?.as_compound_statement()
        }
        /**Returns the node if it is of type `continue_statement` ([`ContinueStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_continue_statement(
            self,
        ) -> ::std::option::Option<ContinueStatement<'tree>> {
            self.as_statement()?.as_continue_statement()
        }
        /**Returns the node if it is of type `do_statement` ([`DoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_do_statement(self) -> ::std::option::Option<DoStatement<'tree>> {
            self.as_statement()?.as_do_statement()
        }
        /**Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            self.as_statement()?.as_expression_statement()
        }
        /**Returns the node if it is of type `for_statement` ([`ForStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_for_statement(self) -> ::std::option::Option<ForStatement<'tree>> {
            self.as_statement()?.as_for_statement()
        }
        /**Returns the node if it is of type `goto_statement` ([`GotoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_goto_statement(self) -> ::std::option::Option<GotoStatement<'tree>> {
            self.as_statement()?.as_goto_statement()
        }
        /**Returns the node if it is of type `if_statement` ([`IfStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_if_statement(self) -> ::std::option::Option<IfStatement<'tree>> {
            self.as_statement()?.as_if_statement()
        }
        /**Returns the node if it is of type `labeled_statement` ([`LabeledStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_labeled_statement(
            self,
        ) -> ::std::option::Option<LabeledStatement<'tree>> {
            self.as_statement()?.as_labeled_statement()
        }
        /**Returns the node if it is of type `return_statement` ([`ReturnStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_return_statement(
            self,
        ) -> ::std::option::Option<ReturnStatement<'tree>> {
            self.as_statement()?.as_return_statement()
        }
        /**Returns the node if it is of type `seh_leave_statement` ([`SehLeaveStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_leave_statement(
            self,
        ) -> ::std::option::Option<SehLeaveStatement<'tree>> {
            self.as_statement()?.as_seh_leave_statement()
        }
        /**Returns the node if it is of type `seh_try_statement` ([`SehTryStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_try_statement(
            self,
        ) -> ::std::option::Option<SehTryStatement<'tree>> {
            self.as_statement()?.as_seh_try_statement()
        }
        /**Returns the node if it is of type `switch_statement` ([`SwitchStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_switch_statement(
            self,
        ) -> ::std::option::Option<SwitchStatement<'tree>> {
            self.as_statement()?.as_switch_statement()
        }
        /**Returns the node if it is of type `while_statement` ([`WhileStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_while_statement(self) -> ::std::option::Option<WhileStatement<'tree>> {
            self.as_statement()?.as_while_statement()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeDeclaration_Statement<'tree> {
        type WithLifetime<'a> = AttributeDeclaration_Statement<'a>;
        const KIND: &'static str = "{attribute_declaration | statement}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributeDeclaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeDeclaration(this));
            }
            if let Ok(this) = <Statement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Statement(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeDeclaration(x) => x.into_raw(),
                Self::Statement(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_specifier | call_expression | gnu_asm_expression | identifier}`:
- [`AttributeSpecifier`]
- [`CallExpression`]
- [`GnuAsmExpression`]
- [`Identifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeSpecifier_CallExpression_GnuAsmExpression_Identifier<'tree> {
        AttributeSpecifier(AttributeSpecifier<'tree>),
        CallExpression(CallExpression<'tree>),
        GnuAsmExpression(GnuAsmExpression<'tree>),
        Identifier(Identifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeSpecifier_CallExpression_GnuAsmExpression_Identifier<'tree> {
        ///Returns the node if it is of type `attribute_specifier` ([`AttributeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_specifier(
            self,
        ) -> ::std::option::Option<AttributeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CallExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GnuAsmExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeSpecifier_CallExpression_GnuAsmExpression_Identifier<'tree> {
        type WithLifetime<'a> = AttributeSpecifier_CallExpression_GnuAsmExpression_Identifier<
            'a,
        >;
        const KIND: &'static str = "{attribute_specifier | call_expression | gnu_asm_expression | identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "attribute_specifier" => {
                    Ok(unsafe {
                        Self::AttributeSpecifier(
                            <AttributeSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "call_expression" => {
                    Ok(unsafe {
                        Self::CallExpression(
                            <CallExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "gnu_asm_expression" => {
                    Ok(unsafe {
                        Self::GnuAsmExpression(
                            <GnuAsmExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "identifier" => {
                    Ok(unsafe {
                        Self::Identifier(
                            <Identifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::GnuAsmExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GnuAsmExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => x.into_raw(),
                Self::CallExpression(x) => x.into_raw(),
                Self::GnuAsmExpression(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_specifier | ms_declspec_modifier}`:
- [`AttributeSpecifier`]
- [`MsDeclspecModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeSpecifier_MsDeclspecModifier<'tree> {
        AttributeSpecifier(AttributeSpecifier<'tree>),
        MsDeclspecModifier(MsDeclspecModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeSpecifier_MsDeclspecModifier<'tree> {
        ///Returns the node if it is of type `attribute_specifier` ([`AttributeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_specifier(
            self,
        ) -> ::std::option::Option<AttributeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_declspec_modifier` ([`MsDeclspecModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_declspec_modifier(
            self,
        ) -> ::std::option::Option<MsDeclspecModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsDeclspecModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeSpecifier_MsDeclspecModifier<'tree> {
        type WithLifetime<'a> = AttributeSpecifier_MsDeclspecModifier<'a>;
        const KIND: &'static str = "{attribute_specifier | ms_declspec_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "attribute_specifier" => {
                    Ok(unsafe {
                        Self::AttributeSpecifier(
                            <AttributeSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_declspec_modifier" => {
                    Ok(unsafe {
                        Self::MsDeclspecModifier(
                            <MsDeclspecModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsDeclspecModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => x.into_raw(),
                Self::MsDeclspecModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_specifier | type_qualifier}`:
- [`AttributeSpecifier`]
- [`TypeQualifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeSpecifier_TypeQualifier<'tree> {
        AttributeSpecifier(AttributeSpecifier<'tree>),
        TypeQualifier(TypeQualifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeSpecifier_TypeQualifier<'tree> {
        ///Returns the node if it is of type `attribute_specifier` ([`AttributeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_specifier(
            self,
        ) -> ::std::option::Option<AttributeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_qualifier` ([`TypeQualifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_qualifier(self) -> ::std::option::Option<TypeQualifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeQualifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeSpecifier_TypeQualifier<'tree> {
        type WithLifetime<'a> = AttributeSpecifier_TypeQualifier<'a>;
        const KIND: &'static str = "{attribute_specifier | type_qualifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "attribute_specifier" => {
                    Ok(unsafe {
                        Self::AttributeSpecifier(
                            <AttributeSpecifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_qualifier" => {
                    Ok(unsafe {
                        Self::TypeQualifier(
                            <TypeQualifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeSpecifier(x) => x.into_raw(),
                Self::TypeQualifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attributed_statement | break_statement | case_statement | compound_statement | continue_statement | declaration | do_statement | expression_statement | for_statement | function_definition | goto_statement | if_statement | labeled_statement | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | return_statement | switch_statement | type_definition | type_specifier | while_statement}`:
- [`AttributedStatement`]
- [`BreakStatement`]
- [`CaseStatement`]
- [`CompoundStatement`]
- [`ContinueStatement`]
- [`Declaration`]
- [`DoStatement`]
- [`ExpressionStatement`]
- [`ForStatement`]
- [`FunctionDefinition`]
- [`GotoStatement`]
- [`IfStatement`]
- [`LabeledStatement`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`ReturnStatement`]
- [`SwitchStatement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]
- [`WhileStatement`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributedStatement_BreakStatement_CaseStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_FunctionDefinition_GotoStatement_IfStatement_LabeledStatement_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_ReturnStatement_SwitchStatement_TypeDefinition_TypeSpecifier_WhileStatement<
        'tree,
    > {
        AttributedStatement(AttributedStatement<'tree>),
        BreakStatement(BreakStatement<'tree>),
        CaseStatement(CaseStatement<'tree>),
        CompoundStatement(CompoundStatement<'tree>),
        ContinueStatement(ContinueStatement<'tree>),
        Declaration(Declaration<'tree>),
        DoStatement(DoStatement<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
        ForStatement(ForStatement<'tree>),
        FunctionDefinition(FunctionDefinition<'tree>),
        GotoStatement(GotoStatement<'tree>),
        IfStatement(IfStatement<'tree>),
        LabeledStatement(LabeledStatement<'tree>),
        LinkageSpecification(LinkageSpecification<'tree>),
        PreprocCall(PreprocCall<'tree>),
        PreprocDef(PreprocDef<'tree>),
        PreprocFunctionDef(PreprocFunctionDef<'tree>),
        PreprocIf(PreprocIf<'tree>),
        PreprocIfdef(PreprocIfdef<'tree>),
        PreprocInclude(PreprocInclude<'tree>),
        ReturnStatement(ReturnStatement<'tree>),
        SwitchStatement(SwitchStatement<'tree>),
        TypeDefinition(TypeDefinition<'tree>),
        TypeSpecifier(TypeSpecifier<'tree>),
        WhileStatement(WhileStatement<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > AttributedStatement_BreakStatement_CaseStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_FunctionDefinition_GotoStatement_IfStatement_LabeledStatement_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_ReturnStatement_SwitchStatement_TypeDefinition_TypeSpecifier_WhileStatement<
        'tree,
    > {
        ///Returns the node if it is of type `attributed_statement` ([`AttributedStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_attributed_statement(
            self,
        ) -> ::std::option::Option<AttributedStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributedStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `break_statement` ([`BreakStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_break_statement(self) -> ::std::option::Option<BreakStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BreakStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `case_statement` ([`CaseStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_case_statement(self) -> ::std::option::Option<CaseStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CaseStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CompoundStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `continue_statement` ([`ContinueStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_continue_statement(
            self,
        ) -> ::std::option::Option<ContinueStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ContinueStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `do_statement` ([`DoStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_do_statement(self) -> ::std::option::Option<DoStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DoStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExpressionStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `for_statement` ([`ForStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_for_statement(self) -> ::std::option::Option<ForStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ForStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `function_definition` ([`FunctionDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_function_definition(
            self,
        ) -> ::std::option::Option<FunctionDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `goto_statement` ([`GotoStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_goto_statement(self) -> ::std::option::Option<GotoStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GotoStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `if_statement` ([`IfStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_if_statement(self) -> ::std::option::Option<IfStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IfStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `labeled_statement` ([`LabeledStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_labeled_statement(
            self,
        ) -> ::std::option::Option<LabeledStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LabeledStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `linkage_specification` ([`LinkageSpecification`]), otherwise returns `None`
        #[inline]
        pub fn as_linkage_specification(
            self,
        ) -> ::std::option::Option<LinkageSpecification<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LinkageSpecification(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_call` ([`PreprocCall`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_call(self) -> ::std::option::Option<PreprocCall<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocCall(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_def` ([`PreprocDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_def(self) -> ::std::option::Option<PreprocDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_function_def` ([`PreprocFunctionDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_function_def(
            self,
        ) -> ::std::option::Option<PreprocFunctionDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocFunctionDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_if` ([`PreprocIf`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_if(self) -> ::std::option::Option<PreprocIf<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIf(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_ifdef` ([`PreprocIfdef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_ifdef(self) -> ::std::option::Option<PreprocIfdef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIfdef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_include` ([`PreprocInclude`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_include(self) -> ::std::option::Option<PreprocInclude<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocInclude(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `return_statement` ([`ReturnStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_return_statement(
            self,
        ) -> ::std::option::Option<ReturnStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ReturnStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `switch_statement` ([`SwitchStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_switch_statement(
            self,
        ) -> ::std::option::Option<SwitchStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SwitchStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_definition` ([`TypeDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_type_definition(self) -> ::std::option::Option<TypeDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_specifier` ([`TypeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_specifier(self) -> ::std::option::Option<TypeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `while_statement` ([`WhileStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_while_statement(self) -> ::std::option::Option<WhileStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::WhileStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `enum_specifier` ([`EnumSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_enum_specifier(self) -> ::std::option::Option<EnumSpecifier<'tree>> {
            self.as_type_specifier()?.as_enum_specifier()
        }
        /**Returns the node if it is of type `macro_type_specifier` ([`MacroTypeSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_macro_type_specifier(
            self,
        ) -> ::std::option::Option<MacroTypeSpecifier<'tree>> {
            self.as_type_specifier()?.as_macro_type_specifier()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type_specifier()?.as_primitive_type()
        }
        /**Returns the node if it is of type `sized_type_specifier` ([`SizedTypeSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_sized_type_specifier(
            self,
        ) -> ::std::option::Option<SizedTypeSpecifier<'tree>> {
            self.as_type_specifier()?.as_sized_type_specifier()
        }
        /**Returns the node if it is of type `struct_specifier` ([`StructSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_struct_specifier(
            self,
        ) -> ::std::option::Option<StructSpecifier<'tree>> {
            self.as_type_specifier()?.as_struct_specifier()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type_specifier()?.as_type_identifier()
        }
        /**Returns the node if it is of type `union_specifier` ([`UnionSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_union_specifier(self) -> ::std::option::Option<UnionSpecifier<'tree>> {
            self.as_type_specifier()?.as_union_specifier()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributedStatement_BreakStatement_CaseStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_FunctionDefinition_GotoStatement_IfStatement_LabeledStatement_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_ReturnStatement_SwitchStatement_TypeDefinition_TypeSpecifier_WhileStatement<
        'tree,
    > {
        type WithLifetime<'a> = AttributedStatement_BreakStatement_CaseStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_FunctionDefinition_GotoStatement_IfStatement_LabeledStatement_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_ReturnStatement_SwitchStatement_TypeDefinition_TypeSpecifier_WhileStatement<
            'a,
        >;
        const KIND: &'static str = "{attributed_statement | break_statement | case_statement | compound_statement | continue_statement | declaration | do_statement | expression_statement | for_statement | function_definition | goto_statement | if_statement | labeled_statement | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | return_statement | switch_statement | type_definition | type_specifier | while_statement}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributedStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributedStatement(this));
            }
            if let Ok(this) = <BreakStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::BreakStatement(this));
            }
            if let Ok(this) = <CaseStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CaseStatement(this));
            }
            if let Ok(this) = <CompoundStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CompoundStatement(this));
            }
            if let Ok(this) = <ContinueStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ContinueStatement(this));
            }
            if let Ok(this) = <Declaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declaration(this));
            }
            if let Ok(this) = <DoStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::DoStatement(this));
            }
            if let Ok(this) = <ExpressionStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ExpressionStatement(this));
            }
            if let Ok(this) = <ForStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ForStatement(this));
            }
            if let Ok(this) = <FunctionDefinition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FunctionDefinition(this));
            }
            if let Ok(this) = <GotoStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GotoStatement(this));
            }
            if let Ok(this) = <IfStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::IfStatement(this));
            }
            if let Ok(this) = <LabeledStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LabeledStatement(this));
            }
            if let Ok(this) = <LinkageSpecification<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LinkageSpecification(this));
            }
            if let Ok(this) = <PreprocCall<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocCall(this));
            }
            if let Ok(this) = <PreprocDef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocDef(this));
            }
            if let Ok(this) = <PreprocFunctionDef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocFunctionDef(this));
            }
            if let Ok(this) = <PreprocIf<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocIf(this));
            }
            if let Ok(this) = <PreprocIfdef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocIfdef(this));
            }
            if let Ok(this) = <PreprocInclude<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocInclude(this));
            }
            if let Ok(this) = <ReturnStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ReturnStatement(this));
            }
            if let Ok(this) = <SwitchStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::SwitchStatement(this));
            }
            if let Ok(this) = <TypeDefinition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeDefinition(this));
            }
            if let Ok(this) = <TypeSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeSpecifier(this));
            }
            if let Ok(this) = <WhileStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::WhileStatement(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributedStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::BreakStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::CaseStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ContinueStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::DoStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ForStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw(x),
                Self::GotoStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::IfStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::LabeledStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::LinkageSpecification(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocInclude(x) => ::type_sitter_lib::Node::raw(x),
                Self::ReturnStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::SwitchStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::WhileStatement(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributedStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BreakStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CaseStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ContinueStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::DoStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ForStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GotoStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::IfStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LabeledStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LinkageSpecification(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocInclude(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ReturnStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SwitchStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::WhileStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributedStatement(x) => x.into_raw(),
                Self::BreakStatement(x) => x.into_raw(),
                Self::CaseStatement(x) => x.into_raw(),
                Self::CompoundStatement(x) => x.into_raw(),
                Self::ContinueStatement(x) => x.into_raw(),
                Self::Declaration(x) => x.into_raw(),
                Self::DoStatement(x) => x.into_raw(),
                Self::ExpressionStatement(x) => x.into_raw(),
                Self::ForStatement(x) => x.into_raw(),
                Self::FunctionDefinition(x) => x.into_raw(),
                Self::GotoStatement(x) => x.into_raw(),
                Self::IfStatement(x) => x.into_raw(),
                Self::LabeledStatement(x) => x.into_raw(),
                Self::LinkageSpecification(x) => x.into_raw(),
                Self::PreprocCall(x) => x.into_raw(),
                Self::PreprocDef(x) => x.into_raw(),
                Self::PreprocFunctionDef(x) => x.into_raw(),
                Self::PreprocIf(x) => x.into_raw(),
                Self::PreprocIfdef(x) => x.into_raw(),
                Self::PreprocInclude(x) => x.into_raw(),
                Self::ReturnStatement(x) => x.into_raw(),
                Self::SwitchStatement(x) => x.into_raw(),
                Self::TypeDefinition(x) => x.into_raw(),
                Self::TypeSpecifier(x) => x.into_raw(),
                Self::WhileStatement(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attributed_statement | break_statement | compound_statement | continue_statement | declaration | do_statement | expression_statement | for_statement | goto_statement | if_statement | labeled_statement | return_statement | seh_leave_statement | seh_try_statement | switch_statement | type_definition | while_statement}`:
- [`AttributedStatement`]
- [`BreakStatement`]
- [`CompoundStatement`]
- [`ContinueStatement`]
- [`Declaration`]
- [`DoStatement`]
- [`ExpressionStatement`]
- [`ForStatement`]
- [`GotoStatement`]
- [`IfStatement`]
- [`LabeledStatement`]
- [`ReturnStatement`]
- [`SehLeaveStatement`]
- [`SehTryStatement`]
- [`SwitchStatement`]
- [`TypeDefinition`]
- [`WhileStatement`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributedStatement_BreakStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_GotoStatement_IfStatement_LabeledStatement_ReturnStatement_SehLeaveStatement_SehTryStatement_SwitchStatement_TypeDefinition_WhileStatement<
        'tree,
    > {
        AttributedStatement(AttributedStatement<'tree>),
        BreakStatement(BreakStatement<'tree>),
        CompoundStatement(CompoundStatement<'tree>),
        ContinueStatement(ContinueStatement<'tree>),
        Declaration(Declaration<'tree>),
        DoStatement(DoStatement<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
        ForStatement(ForStatement<'tree>),
        GotoStatement(GotoStatement<'tree>),
        IfStatement(IfStatement<'tree>),
        LabeledStatement(LabeledStatement<'tree>),
        ReturnStatement(ReturnStatement<'tree>),
        SehLeaveStatement(SehLeaveStatement<'tree>),
        SehTryStatement(SehTryStatement<'tree>),
        SwitchStatement(SwitchStatement<'tree>),
        TypeDefinition(TypeDefinition<'tree>),
        WhileStatement(WhileStatement<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > AttributedStatement_BreakStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_GotoStatement_IfStatement_LabeledStatement_ReturnStatement_SehLeaveStatement_SehTryStatement_SwitchStatement_TypeDefinition_WhileStatement<
        'tree,
    > {
        ///Returns the node if it is of type `attributed_statement` ([`AttributedStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_attributed_statement(
            self,
        ) -> ::std::option::Option<AttributedStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributedStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `break_statement` ([`BreakStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_break_statement(self) -> ::std::option::Option<BreakStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BreakStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CompoundStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `continue_statement` ([`ContinueStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_continue_statement(
            self,
        ) -> ::std::option::Option<ContinueStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ContinueStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `do_statement` ([`DoStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_do_statement(self) -> ::std::option::Option<DoStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DoStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExpressionStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `for_statement` ([`ForStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_for_statement(self) -> ::std::option::Option<ForStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ForStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `goto_statement` ([`GotoStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_goto_statement(self) -> ::std::option::Option<GotoStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GotoStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `if_statement` ([`IfStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_if_statement(self) -> ::std::option::Option<IfStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IfStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `labeled_statement` ([`LabeledStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_labeled_statement(
            self,
        ) -> ::std::option::Option<LabeledStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LabeledStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `return_statement` ([`ReturnStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_return_statement(
            self,
        ) -> ::std::option::Option<ReturnStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ReturnStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `seh_leave_statement` ([`SehLeaveStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_seh_leave_statement(
            self,
        ) -> ::std::option::Option<SehLeaveStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SehLeaveStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `seh_try_statement` ([`SehTryStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_seh_try_statement(
            self,
        ) -> ::std::option::Option<SehTryStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SehTryStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `switch_statement` ([`SwitchStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_switch_statement(
            self,
        ) -> ::std::option::Option<SwitchStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SwitchStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_definition` ([`TypeDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_type_definition(self) -> ::std::option::Option<TypeDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `while_statement` ([`WhileStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_while_statement(self) -> ::std::option::Option<WhileStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::WhileStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributedStatement_BreakStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_GotoStatement_IfStatement_LabeledStatement_ReturnStatement_SehLeaveStatement_SehTryStatement_SwitchStatement_TypeDefinition_WhileStatement<
        'tree,
    > {
        type WithLifetime<'a> = AttributedStatement_BreakStatement_CompoundStatement_ContinueStatement_Declaration_DoStatement_ExpressionStatement_ForStatement_GotoStatement_IfStatement_LabeledStatement_ReturnStatement_SehLeaveStatement_SehTryStatement_SwitchStatement_TypeDefinition_WhileStatement<
            'a,
        >;
        const KIND: &'static str = "{attributed_statement | break_statement | compound_statement | continue_statement | declaration | do_statement | expression_statement | for_statement | goto_statement | if_statement | labeled_statement | return_statement | seh_leave_statement | seh_try_statement | switch_statement | type_definition | while_statement}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "attributed_statement" => {
                    Ok(unsafe {
                        Self::AttributedStatement(
                            <AttributedStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "break_statement" => {
                    Ok(unsafe {
                        Self::BreakStatement(
                            <BreakStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "compound_statement" => {
                    Ok(unsafe {
                        Self::CompoundStatement(
                            <CompoundStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "continue_statement" => {
                    Ok(unsafe {
                        Self::ContinueStatement(
                            <ContinueStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "declaration" => {
                    Ok(unsafe {
                        Self::Declaration(
                            <Declaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "do_statement" => {
                    Ok(unsafe {
                        Self::DoStatement(
                            <DoStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "expression_statement" => {
                    Ok(unsafe {
                        Self::ExpressionStatement(
                            <ExpressionStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "for_statement" => {
                    Ok(unsafe {
                        Self::ForStatement(
                            <ForStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "goto_statement" => {
                    Ok(unsafe {
                        Self::GotoStatement(
                            <GotoStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "if_statement" => {
                    Ok(unsafe {
                        Self::IfStatement(
                            <IfStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "labeled_statement" => {
                    Ok(unsafe {
                        Self::LabeledStatement(
                            <LabeledStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "return_statement" => {
                    Ok(unsafe {
                        Self::ReturnStatement(
                            <ReturnStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "seh_leave_statement" => {
                    Ok(unsafe {
                        Self::SehLeaveStatement(
                            <SehLeaveStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "seh_try_statement" => {
                    Ok(unsafe {
                        Self::SehTryStatement(
                            <SehTryStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "switch_statement" => {
                    Ok(unsafe {
                        Self::SwitchStatement(
                            <SwitchStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_definition" => {
                    Ok(unsafe {
                        Self::TypeDefinition(
                            <TypeDefinition<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "while_statement" => {
                    Ok(unsafe {
                        Self::WhileStatement(
                            <WhileStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributedStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::BreakStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ContinueStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::DoStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ForStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::GotoStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::IfStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::LabeledStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ReturnStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::SehLeaveStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::SehTryStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::SwitchStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw(x),
                Self::WhileStatement(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributedStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BreakStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ContinueStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::DoStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ForStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GotoStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::IfStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LabeledStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ReturnStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SehLeaveStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SehTryStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SwitchStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::WhileStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributedStatement(x) => x.into_raw(),
                Self::BreakStatement(x) => x.into_raw(),
                Self::CompoundStatement(x) => x.into_raw(),
                Self::ContinueStatement(x) => x.into_raw(),
                Self::Declaration(x) => x.into_raw(),
                Self::DoStatement(x) => x.into_raw(),
                Self::ExpressionStatement(x) => x.into_raw(),
                Self::ForStatement(x) => x.into_raw(),
                Self::GotoStatement(x) => x.into_raw(),
                Self::IfStatement(x) => x.into_raw(),
                Self::LabeledStatement(x) => x.into_raw(),
                Self::ReturnStatement(x) => x.into_raw(),
                Self::SehLeaveStatement(x) => x.into_raw(),
                Self::SehTryStatement(x) => x.into_raw(),
                Self::SwitchStatement(x) => x.into_raw(),
                Self::TypeDefinition(x) => x.into_raw(),
                Self::WhileStatement(x) => x.into_raw(),
            }
        }
    }
    /**One of `{binary_expression | call_expression | char_literal | identifier | number_literal | parenthesized_expression | preproc_defined | unary_expression}`:
- [`BinaryExpression`]
- [`CallExpression`]
- [`CharLiteral`]
- [`Identifier`]
- [`NumberLiteral`]
- [`ParenthesizedExpression`]
- [`PreprocDefined`]
- [`UnaryExpression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
        'tree,
    > {
        BinaryExpression(BinaryExpression<'tree>),
        CallExpression(CallExpression<'tree>),
        CharLiteral(CharLiteral<'tree>),
        Identifier(Identifier<'tree>),
        NumberLiteral(NumberLiteral<'tree>),
        ParenthesizedExpression(ParenthesizedExpression<'tree>),
        PreprocDefined(PreprocDefined<'tree>),
        UnaryExpression(UnaryExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
        'tree,
    > {
        ///Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BinaryExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CallExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CharLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::NumberLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ParenthesizedExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_defined` ([`PreprocDefined`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_defined(self) -> ::std::option::Option<PreprocDefined<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDefined(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::UnaryExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
        'tree,
    > {
        type WithLifetime<'a> = BinaryExpression_CallExpression_CharLiteral_Identifier_NumberLiteral_ParenthesizedExpression_PreprocDefined_UnaryExpression<
            'a,
        >;
        const KIND: &'static str = "{binary_expression | call_expression | char_literal | identifier | number_literal | parenthesized_expression | preproc_defined | unary_expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "binary_expression" => {
                    Ok(unsafe {
                        Self::BinaryExpression(
                            <BinaryExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "call_expression" => {
                    Ok(unsafe {
                        Self::CallExpression(
                            <CallExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "char_literal" => {
                    Ok(unsafe {
                        Self::CharLiteral(
                            <CharLiteral<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "identifier" => {
                    Ok(unsafe {
                        Self::Identifier(
                            <Identifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "number_literal" => {
                    Ok(unsafe {
                        Self::NumberLiteral(
                            <NumberLiteral<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "parenthesized_expression" => {
                    Ok(unsafe {
                        Self::ParenthesizedExpression(
                            <ParenthesizedExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_defined" => {
                    Ok(unsafe {
                        Self::PreprocDefined(
                            <PreprocDefined<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "unary_expression" => {
                    Ok(unsafe {
                        Self::UnaryExpression(
                            <UnaryExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::CharLiteral(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::NumberLiteral(x) => ::type_sitter_lib::Node::raw(x),
                Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw(x),
                Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CharLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::NumberLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::BinaryExpression(x) => x.into_raw(),
                Self::CallExpression(x) => x.into_raw(),
                Self::CharLiteral(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::NumberLiteral(x) => x.into_raw(),
                Self::ParenthesizedExpression(x) => x.into_raw(),
                Self::PreprocDefined(x) => x.into_raw(),
                Self::UnaryExpression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{call_expression | field_expression | identifier | parenthesized_expression | pointer_expression | subscript_expression}`:
- [`CallExpression`]
- [`FieldExpression`]
- [`Identifier`]
- [`ParenthesizedExpression`]
- [`PointerExpression`]
- [`SubscriptExpression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CallExpression_FieldExpression_Identifier_ParenthesizedExpression_PointerExpression_SubscriptExpression<
        'tree,
    > {
        CallExpression(CallExpression<'tree>),
        FieldExpression(FieldExpression<'tree>),
        Identifier(Identifier<'tree>),
        ParenthesizedExpression(ParenthesizedExpression<'tree>),
        PointerExpression(PointerExpression<'tree>),
        SubscriptExpression(SubscriptExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > CallExpression_FieldExpression_Identifier_ParenthesizedExpression_PointerExpression_SubscriptExpression<
        'tree,
    > {
        ///Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CallExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ParenthesizedExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PointerExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubscriptExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for CallExpression_FieldExpression_Identifier_ParenthesizedExpression_PointerExpression_SubscriptExpression<
        'tree,
    > {
        type WithLifetime<'a> = CallExpression_FieldExpression_Identifier_ParenthesizedExpression_PointerExpression_SubscriptExpression<
            'a,
        >;
        const KIND: &'static str = "{call_expression | field_expression | identifier | parenthesized_expression | pointer_expression | subscript_expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "call_expression" => {
                    Ok(unsafe {
                        Self::CallExpression(
                            <CallExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "field_expression" => {
                    Ok(unsafe {
                        Self::FieldExpression(
                            <FieldExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "identifier" => {
                    Ok(unsafe {
                        Self::Identifier(
                            <Identifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "parenthesized_expression" => {
                    Ok(unsafe {
                        Self::ParenthesizedExpression(
                            <ParenthesizedExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "pointer_expression" => {
                    Ok(unsafe {
                        Self::PointerExpression(
                            <PointerExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "subscript_expression" => {
                    Ok(unsafe {
                        Self::SubscriptExpression(
                            <SubscriptExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::PointerExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::SubscriptExpression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PointerExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SubscriptExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.into_raw(),
                Self::FieldExpression(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::ParenthesizedExpression(x) => x.into_raw(),
                Self::PointerExpression(x) => x.into_raw(),
                Self::SubscriptExpression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{call_expression | identifier | string_literal | system_lib_string}`:
- [`CallExpression`]
- [`Identifier`]
- [`StringLiteral`]
- [`SystemLibString`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CallExpression_Identifier_StringLiteral_SystemLibString<'tree> {
        CallExpression(CallExpression<'tree>),
        Identifier(Identifier<'tree>),
        StringLiteral(StringLiteral<'tree>),
        SystemLibString(SystemLibString<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> CallExpression_Identifier_StringLiteral_SystemLibString<'tree> {
        ///Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CallExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StringLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `system_lib_string` ([`SystemLibString`]), otherwise returns `None`
        #[inline]
        pub fn as_system_lib_string(
            self,
        ) -> ::std::option::Option<SystemLibString<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SystemLibString(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for CallExpression_Identifier_StringLiteral_SystemLibString<'tree> {
        type WithLifetime<'a> = CallExpression_Identifier_StringLiteral_SystemLibString<
            'a,
        >;
        const KIND: &'static str = "{call_expression | identifier | string_literal | system_lib_string}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "call_expression" => {
                    Ok(unsafe {
                        Self::CallExpression(
                            <CallExpression<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "identifier" => {
                    Ok(unsafe {
                        Self::Identifier(
                            <Identifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "string_literal" => {
                    Ok(unsafe {
                        Self::StringLiteral(
                            <StringLiteral<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "system_lib_string" => {
                    Ok(unsafe {
                        Self::SystemLibString(
                            <SystemLibString<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::StringLiteral(x) => ::type_sitter_lib::Node::raw(x),
                Self::SystemLibString(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SystemLibString(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::CallExpression(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::StringLiteral(x) => x.into_raw(),
                Self::SystemLibString(x) => x.into_raw(),
            }
        }
    }
    /**One of `{character | escape_sequence}`:
- [`Character`]
- [`EscapeSequence`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Character_EscapeSequence<'tree> {
        Character(Character<'tree>),
        EscapeSequence(EscapeSequence<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Character_EscapeSequence<'tree> {
        ///Returns the node if it is of type `character` ([`Character`]), otherwise returns `None`
        #[inline]
        pub fn as_character(self) -> ::std::option::Option<Character<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Character(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `escape_sequence` ([`EscapeSequence`]), otherwise returns `None`
        #[inline]
        pub fn as_escape_sequence(self) -> ::std::option::Option<EscapeSequence<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EscapeSequence(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Character_EscapeSequence<'tree> {
        type WithLifetime<'a> = Character_EscapeSequence<'a>;
        const KIND: &'static str = "{character | escape_sequence}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "character" => {
                    Ok(unsafe {
                        Self::Character(
                            <Character<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "escape_sequence" => {
                    Ok(unsafe {
                        Self::EscapeSequence(
                            <EscapeSequence<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Character(x) => ::type_sitter_lib::Node::raw(x),
                Self::EscapeSequence(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Character(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::EscapeSequence(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Character(x) => x.into_raw(),
                Self::EscapeSequence(x) => x.into_raw(),
            }
        }
    }
    /**One of `{comma_expression | compound_statement | expression | preproc_defined}`:
- [`CommaExpression`]
- [`CompoundStatement`]
- [`Expression`]
- [`PreprocDefined`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CommaExpression_CompoundStatement_Expression_PreprocDefined<'tree> {
        CommaExpression(CommaExpression<'tree>),
        CompoundStatement(CompoundStatement<'tree>),
        Expression(Expression<'tree>),
        PreprocDefined(PreprocDefined<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> CommaExpression_CompoundStatement_Expression_PreprocDefined<'tree> {
        ///Returns the node if it is of type `comma_expression` ([`CommaExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_comma_expression(
            self,
        ) -> ::std::option::Option<CommaExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CommaExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CompoundStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_defined` ([`PreprocDefined`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_defined(self) -> ::std::option::Option<PreprocDefined<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDefined(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for CommaExpression_CompoundStatement_Expression_PreprocDefined<'tree> {
        type WithLifetime<'a> = CommaExpression_CompoundStatement_Expression_PreprocDefined<
            'a,
        >;
        const KIND: &'static str = "{comma_expression | compound_statement | expression | preproc_defined}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <CommaExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CommaExpression(this));
            }
            if let Ok(this) = <CompoundStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CompoundStatement(this));
            }
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <PreprocDefined<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocDefined(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => x.into_raw(),
                Self::CompoundStatement(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
                Self::PreprocDefined(x) => x.into_raw(),
            }
        }
    }
    /**One of `{comma_expression | declaration | expression}`:
- [`CommaExpression`]
- [`Declaration`]
- [`Expression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CommaExpression_Declaration_Expression<'tree> {
        CommaExpression(CommaExpression<'tree>),
        Declaration(Declaration<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> CommaExpression_Declaration_Expression<'tree> {
        ///Returns the node if it is of type `comma_expression` ([`CommaExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_comma_expression(
            self,
        ) -> ::std::option::Option<CommaExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CommaExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for CommaExpression_Declaration_Expression<'tree> {
        type WithLifetime<'a> = CommaExpression_Declaration_Expression<'a>;
        const KIND: &'static str = "{comma_expression | declaration | expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <CommaExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CommaExpression(this));
            }
            if let Ok(this) = <Declaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declaration(this));
            }
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => x.into_raw(),
                Self::Declaration(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{comma_expression | expression}`:
- [`CommaExpression`]
- [`Expression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CommaExpression_Expression<'tree> {
        CommaExpression(CommaExpression<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> CommaExpression_Expression<'tree> {
        ///Returns the node if it is of type `comma_expression` ([`CommaExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_comma_expression(
            self,
        ) -> ::std::option::Option<CommaExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CommaExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for CommaExpression_Expression<'tree> {
        type WithLifetime<'a> = CommaExpression_Expression<'a>;
        const KIND: &'static str = "{comma_expression | expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <CommaExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CommaExpression(this));
            }
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::CommaExpression(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{compound_statement | expression | preproc_defined}`:
- [`CompoundStatement`]
- [`Expression`]
- [`PreprocDefined`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CompoundStatement_Expression_PreprocDefined<'tree> {
        CompoundStatement(CompoundStatement<'tree>),
        Expression(Expression<'tree>),
        PreprocDefined(PreprocDefined<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> CompoundStatement_Expression_PreprocDefined<'tree> {
        ///Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CompoundStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_defined` ([`PreprocDefined`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_defined(self) -> ::std::option::Option<PreprocDefined<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDefined(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for CompoundStatement_Expression_PreprocDefined<'tree> {
        type WithLifetime<'a> = CompoundStatement_Expression_PreprocDefined<'a>;
        const KIND: &'static str = "{compound_statement | expression | preproc_defined}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <CompoundStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CompoundStatement(this));
            }
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <PreprocDefined<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocDefined(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::CompoundStatement(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
                Self::PreprocDefined(x) => x.into_raw(),
            }
        }
    }
    /**One of `{compound_statement | identifier | parameter_declaration | variadic_parameter}`:
- [`CompoundStatement`]
- [`Identifier`]
- [`ParameterDeclaration`]
- [`VariadicParameter`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum CompoundStatement_Identifier_ParameterDeclaration_VariadicParameter<'tree> {
        CompoundStatement(CompoundStatement<'tree>),
        Identifier(Identifier<'tree>),
        ParameterDeclaration(ParameterDeclaration<'tree>),
        VariadicParameter(VariadicParameter<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > CompoundStatement_Identifier_ParameterDeclaration_VariadicParameter<'tree> {
        ///Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CompoundStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `parameter_declaration` ([`ParameterDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_parameter_declaration(
            self,
        ) -> ::std::option::Option<ParameterDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ParameterDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `variadic_parameter` ([`VariadicParameter`]), otherwise returns `None`
        #[inline]
        pub fn as_variadic_parameter(
            self,
        ) -> ::std::option::Option<VariadicParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VariadicParameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for CompoundStatement_Identifier_ParameterDeclaration_VariadicParameter<'tree> {
        type WithLifetime<'a> = CompoundStatement_Identifier_ParameterDeclaration_VariadicParameter<
            'a,
        >;
        const KIND: &'static str = "{compound_statement | identifier | parameter_declaration | variadic_parameter}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "compound_statement" => {
                    Ok(unsafe {
                        Self::CompoundStatement(
                            <CompoundStatement<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "identifier" => {
                    Ok(unsafe {
                        Self::Identifier(
                            <Identifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "parameter_declaration" => {
                    Ok(unsafe {
                        Self::ParameterDeclaration(
                            <ParameterDeclaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "variadic_parameter" => {
                    Ok(unsafe {
                        Self::VariadicParameter(
                            <VariadicParameter<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ParameterDeclaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::VariadicParameter(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::CompoundStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ParameterDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::VariadicParameter(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::CompoundStatement(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::ParameterDeclaration(x) => x.into_raw(),
                Self::VariadicParameter(x) => x.into_raw(),
            }
        }
    }
    /**One of `{concatenated_string | string_literal}`:
- [`ConcatenatedString`]
- [`StringLiteral`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ConcatenatedString_StringLiteral<'tree> {
        ConcatenatedString(ConcatenatedString<'tree>),
        StringLiteral(StringLiteral<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ConcatenatedString_StringLiteral<'tree> {
        ///Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ConcatenatedString(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StringLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ConcatenatedString_StringLiteral<'tree> {
        type WithLifetime<'a> = ConcatenatedString_StringLiteral<'a>;
        const KIND: &'static str = "{concatenated_string | string_literal}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "concatenated_string" => {
                    Ok(unsafe {
                        Self::ConcatenatedString(
                            <ConcatenatedString<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "string_literal" => {
                    Ok(unsafe {
                        Self::StringLiteral(
                            <StringLiteral<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ConcatenatedString(x) => ::type_sitter_lib::Node::raw(x),
                Self::StringLiteral(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ConcatenatedString(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ConcatenatedString(x) => x.into_raw(),
                Self::StringLiteral(x) => x.into_raw(),
            }
        }
    }
    /**One of `{declaration | declaration_list | function_definition}`:
- [`Declaration`]
- [`DeclarationList`]
- [`FunctionDefinition`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Declaration_DeclarationList_FunctionDefinition<'tree> {
        Declaration(Declaration<'tree>),
        DeclarationList(DeclarationList<'tree>),
        FunctionDefinition(FunctionDefinition<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Declaration_DeclarationList_FunctionDefinition<'tree> {
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `declaration_list` ([`DeclarationList`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration_list(
            self,
        ) -> ::std::option::Option<DeclarationList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DeclarationList(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `function_definition` ([`FunctionDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_function_definition(
            self,
        ) -> ::std::option::Option<FunctionDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Declaration_DeclarationList_FunctionDefinition<'tree> {
        type WithLifetime<'a> = Declaration_DeclarationList_FunctionDefinition<'a>;
        const KIND: &'static str = "{declaration | declaration_list | function_definition}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "declaration" => {
                    Ok(unsafe {
                        Self::Declaration(
                            <Declaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "declaration_list" => {
                    Ok(unsafe {
                        Self::DeclarationList(
                            <DeclarationList<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "function_definition" => {
                    Ok(unsafe {
                        Self::FunctionDefinition(
                            <FunctionDefinition<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::DeclarationList(x) => ::type_sitter_lib::Node::raw(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::DeclarationList(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => x.into_raw(),
                Self::DeclarationList(x) => x.into_raw(),
                Self::FunctionDefinition(x) => x.into_raw(),
            }
        }
    }
    /**One of `{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}`:
- [`Declaration`]
- [`Enumerator`]
- [`FieldDeclaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    > {
        Declaration(Declaration<'tree>),
        Enumerator(Enumerator<'tree>),
        FieldDeclaration(FieldDeclaration<'tree>),
        FunctionDefinition(FunctionDefinition<'tree>),
        LinkageSpecification(LinkageSpecification<'tree>),
        PreprocCall(PreprocCall<'tree>),
        PreprocDef(PreprocDef<'tree>),
        PreprocFunctionDef(PreprocFunctionDef<'tree>),
        PreprocIf(PreprocIf<'tree>),
        PreprocIfdef(PreprocIfdef<'tree>),
        PreprocInclude(PreprocInclude<'tree>),
        Statement(Statement<'tree>),
        TypeDefinition(TypeDefinition<'tree>),
        TypeSpecifier(TypeSpecifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    > {
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `enumerator` ([`Enumerator`]), otherwise returns `None`
        #[inline]
        pub fn as_enumerator(self) -> ::std::option::Option<Enumerator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Enumerator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `field_declaration` ([`FieldDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_field_declaration(
            self,
        ) -> ::std::option::Option<FieldDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `function_definition` ([`FunctionDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_function_definition(
            self,
        ) -> ::std::option::Option<FunctionDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `linkage_specification` ([`LinkageSpecification`]), otherwise returns `None`
        #[inline]
        pub fn as_linkage_specification(
            self,
        ) -> ::std::option::Option<LinkageSpecification<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LinkageSpecification(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_call` ([`PreprocCall`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_call(self) -> ::std::option::Option<PreprocCall<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocCall(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_def` ([`PreprocDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_def(self) -> ::std::option::Option<PreprocDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_function_def` ([`PreprocFunctionDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_function_def(
            self,
        ) -> ::std::option::Option<PreprocFunctionDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocFunctionDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_if` ([`PreprocIf`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_if(self) -> ::std::option::Option<PreprocIf<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIf(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_ifdef` ([`PreprocIfdef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_ifdef(self) -> ::std::option::Option<PreprocIfdef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIfdef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_include` ([`PreprocInclude`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_include(self) -> ::std::option::Option<PreprocInclude<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocInclude(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `statement` ([`Statement`]), otherwise returns `None`
        #[inline]
        pub fn as_statement(self) -> ::std::option::Option<Statement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Statement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_definition` ([`TypeDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_type_definition(self) -> ::std::option::Option<TypeDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_specifier` ([`TypeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_specifier(self) -> ::std::option::Option<TypeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `attributed_statement` ([`AttributedStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_attributed_statement(
            self,
        ) -> ::std::option::Option<AttributedStatement<'tree>> {
            self.as_statement()?.as_attributed_statement()
        }
        /**Returns the node if it is of type `break_statement` ([`BreakStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_break_statement(self) -> ::std::option::Option<BreakStatement<'tree>> {
            self.as_statement()?.as_break_statement()
        }
        /**Returns the node if it is of type `case_statement` ([`CaseStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_case_statement(self) -> ::std::option::Option<CaseStatement<'tree>> {
            self.as_statement()?.as_case_statement()
        }
        /**Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            self.as_statement()?.as_compound_statement()
        }
        /**Returns the node if it is of type `continue_statement` ([`ContinueStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_continue_statement(
            self,
        ) -> ::std::option::Option<ContinueStatement<'tree>> {
            self.as_statement()?.as_continue_statement()
        }
        /**Returns the node if it is of type `do_statement` ([`DoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_do_statement(self) -> ::std::option::Option<DoStatement<'tree>> {
            self.as_statement()?.as_do_statement()
        }
        /**Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            self.as_statement()?.as_expression_statement()
        }
        /**Returns the node if it is of type `for_statement` ([`ForStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_for_statement(self) -> ::std::option::Option<ForStatement<'tree>> {
            self.as_statement()?.as_for_statement()
        }
        /**Returns the node if it is of type `goto_statement` ([`GotoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_goto_statement(self) -> ::std::option::Option<GotoStatement<'tree>> {
            self.as_statement()?.as_goto_statement()
        }
        /**Returns the node if it is of type `if_statement` ([`IfStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_if_statement(self) -> ::std::option::Option<IfStatement<'tree>> {
            self.as_statement()?.as_if_statement()
        }
        /**Returns the node if it is of type `labeled_statement` ([`LabeledStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_labeled_statement(
            self,
        ) -> ::std::option::Option<LabeledStatement<'tree>> {
            self.as_statement()?.as_labeled_statement()
        }
        /**Returns the node if it is of type `return_statement` ([`ReturnStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_return_statement(
            self,
        ) -> ::std::option::Option<ReturnStatement<'tree>> {
            self.as_statement()?.as_return_statement()
        }
        /**Returns the node if it is of type `seh_leave_statement` ([`SehLeaveStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_leave_statement(
            self,
        ) -> ::std::option::Option<SehLeaveStatement<'tree>> {
            self.as_statement()?.as_seh_leave_statement()
        }
        /**Returns the node if it is of type `seh_try_statement` ([`SehTryStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_try_statement(
            self,
        ) -> ::std::option::Option<SehTryStatement<'tree>> {
            self.as_statement()?.as_seh_try_statement()
        }
        /**Returns the node if it is of type `switch_statement` ([`SwitchStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_switch_statement(
            self,
        ) -> ::std::option::Option<SwitchStatement<'tree>> {
            self.as_statement()?.as_switch_statement()
        }
        /**Returns the node if it is of type `while_statement` ([`WhileStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_while_statement(self) -> ::std::option::Option<WhileStatement<'tree>> {
            self.as_statement()?.as_while_statement()
        }
        /**Returns the node if it is of type `enum_specifier` ([`EnumSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_enum_specifier(self) -> ::std::option::Option<EnumSpecifier<'tree>> {
            self.as_type_specifier()?.as_enum_specifier()
        }
        /**Returns the node if it is of type `macro_type_specifier` ([`MacroTypeSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_macro_type_specifier(
            self,
        ) -> ::std::option::Option<MacroTypeSpecifier<'tree>> {
            self.as_type_specifier()?.as_macro_type_specifier()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type_specifier()?.as_primitive_type()
        }
        /**Returns the node if it is of type `sized_type_specifier` ([`SizedTypeSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_sized_type_specifier(
            self,
        ) -> ::std::option::Option<SizedTypeSpecifier<'tree>> {
            self.as_type_specifier()?.as_sized_type_specifier()
        }
        /**Returns the node if it is of type `struct_specifier` ([`StructSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_struct_specifier(
            self,
        ) -> ::std::option::Option<StructSpecifier<'tree>> {
            self.as_type_specifier()?.as_struct_specifier()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type_specifier()?.as_type_identifier()
        }
        /**Returns the node if it is of type `union_specifier` ([`UnionSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_union_specifier(self) -> ::std::option::Option<UnionSpecifier<'tree>> {
            self.as_type_specifier()?.as_union_specifier()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    > {
        type WithLifetime<'a> = Declaration_Enumerator_FieldDeclaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
            'a,
        >;
        const KIND: &'static str = "{declaration | enumerator | field_declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Declaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declaration(this));
            }
            if let Ok(this) = <Enumerator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Enumerator(this));
            }
            if let Ok(this) = <FieldDeclaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldDeclaration(this));
            }
            if let Ok(this) = <FunctionDefinition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FunctionDefinition(this));
            }
            if let Ok(this) = <LinkageSpecification<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LinkageSpecification(this));
            }
            if let Ok(this) = <PreprocCall<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocCall(this));
            }
            if let Ok(this) = <PreprocDef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocDef(this));
            }
            if let Ok(this) = <PreprocFunctionDef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocFunctionDef(this));
            }
            if let Ok(this) = <PreprocIf<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocIf(this));
            }
            if let Ok(this) = <PreprocIfdef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocIfdef(this));
            }
            if let Ok(this) = <PreprocInclude<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocInclude(this));
            }
            if let Ok(this) = <Statement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Statement(this));
            }
            if let Ok(this) = <TypeDefinition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeDefinition(this));
            }
            if let Ok(this) = <TypeSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeSpecifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::Enumerator(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldDeclaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw(x),
                Self::LinkageSpecification(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocInclude(x) => ::type_sitter_lib::Node::raw(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Enumerator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LinkageSpecification(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocInclude(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => x.into_raw(),
                Self::Enumerator(x) => x.into_raw(),
                Self::FieldDeclaration(x) => x.into_raw(),
                Self::FunctionDefinition(x) => x.into_raw(),
                Self::LinkageSpecification(x) => x.into_raw(),
                Self::PreprocCall(x) => x.into_raw(),
                Self::PreprocDef(x) => x.into_raw(),
                Self::PreprocFunctionDef(x) => x.into_raw(),
                Self::PreprocIf(x) => x.into_raw(),
                Self::PreprocIfdef(x) => x.into_raw(),
                Self::PreprocInclude(x) => x.into_raw(),
                Self::Statement(x) => x.into_raw(),
                Self::TypeDefinition(x) => x.into_raw(),
                Self::TypeSpecifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}`:
- [`Declaration`]
- [`FunctionDefinition`]
- [`LinkageSpecification`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]
- [`PreprocInclude`]
- [`Statement`]
- [`TypeDefinition`]
- [`TypeSpecifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Declaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    > {
        Declaration(Declaration<'tree>),
        FunctionDefinition(FunctionDefinition<'tree>),
        LinkageSpecification(LinkageSpecification<'tree>),
        PreprocCall(PreprocCall<'tree>),
        PreprocDef(PreprocDef<'tree>),
        PreprocFunctionDef(PreprocFunctionDef<'tree>),
        PreprocIf(PreprocIf<'tree>),
        PreprocIfdef(PreprocIfdef<'tree>),
        PreprocInclude(PreprocInclude<'tree>),
        Statement(Statement<'tree>),
        TypeDefinition(TypeDefinition<'tree>),
        TypeSpecifier(TypeSpecifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > Declaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    > {
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `function_definition` ([`FunctionDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_function_definition(
            self,
        ) -> ::std::option::Option<FunctionDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `linkage_specification` ([`LinkageSpecification`]), otherwise returns `None`
        #[inline]
        pub fn as_linkage_specification(
            self,
        ) -> ::std::option::Option<LinkageSpecification<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LinkageSpecification(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_call` ([`PreprocCall`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_call(self) -> ::std::option::Option<PreprocCall<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocCall(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_def` ([`PreprocDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_def(self) -> ::std::option::Option<PreprocDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_function_def` ([`PreprocFunctionDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_function_def(
            self,
        ) -> ::std::option::Option<PreprocFunctionDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocFunctionDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_if` ([`PreprocIf`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_if(self) -> ::std::option::Option<PreprocIf<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIf(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_ifdef` ([`PreprocIfdef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_ifdef(self) -> ::std::option::Option<PreprocIfdef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIfdef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_include` ([`PreprocInclude`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_include(self) -> ::std::option::Option<PreprocInclude<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocInclude(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `statement` ([`Statement`]), otherwise returns `None`
        #[inline]
        pub fn as_statement(self) -> ::std::option::Option<Statement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Statement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_definition` ([`TypeDefinition`]), otherwise returns `None`
        #[inline]
        pub fn as_type_definition(self) -> ::std::option::Option<TypeDefinition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDefinition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_specifier` ([`TypeSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_specifier(self) -> ::std::option::Option<TypeSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `attributed_statement` ([`AttributedStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_attributed_statement(
            self,
        ) -> ::std::option::Option<AttributedStatement<'tree>> {
            self.as_statement()?.as_attributed_statement()
        }
        /**Returns the node if it is of type `break_statement` ([`BreakStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_break_statement(self) -> ::std::option::Option<BreakStatement<'tree>> {
            self.as_statement()?.as_break_statement()
        }
        /**Returns the node if it is of type `case_statement` ([`CaseStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_case_statement(self) -> ::std::option::Option<CaseStatement<'tree>> {
            self.as_statement()?.as_case_statement()
        }
        /**Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            self.as_statement()?.as_compound_statement()
        }
        /**Returns the node if it is of type `continue_statement` ([`ContinueStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_continue_statement(
            self,
        ) -> ::std::option::Option<ContinueStatement<'tree>> {
            self.as_statement()?.as_continue_statement()
        }
        /**Returns the node if it is of type `do_statement` ([`DoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_do_statement(self) -> ::std::option::Option<DoStatement<'tree>> {
            self.as_statement()?.as_do_statement()
        }
        /**Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            self.as_statement()?.as_expression_statement()
        }
        /**Returns the node if it is of type `for_statement` ([`ForStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_for_statement(self) -> ::std::option::Option<ForStatement<'tree>> {
            self.as_statement()?.as_for_statement()
        }
        /**Returns the node if it is of type `goto_statement` ([`GotoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_goto_statement(self) -> ::std::option::Option<GotoStatement<'tree>> {
            self.as_statement()?.as_goto_statement()
        }
        /**Returns the node if it is of type `if_statement` ([`IfStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_if_statement(self) -> ::std::option::Option<IfStatement<'tree>> {
            self.as_statement()?.as_if_statement()
        }
        /**Returns the node if it is of type `labeled_statement` ([`LabeledStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_labeled_statement(
            self,
        ) -> ::std::option::Option<LabeledStatement<'tree>> {
            self.as_statement()?.as_labeled_statement()
        }
        /**Returns the node if it is of type `return_statement` ([`ReturnStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_return_statement(
            self,
        ) -> ::std::option::Option<ReturnStatement<'tree>> {
            self.as_statement()?.as_return_statement()
        }
        /**Returns the node if it is of type `seh_leave_statement` ([`SehLeaveStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_leave_statement(
            self,
        ) -> ::std::option::Option<SehLeaveStatement<'tree>> {
            self.as_statement()?.as_seh_leave_statement()
        }
        /**Returns the node if it is of type `seh_try_statement` ([`SehTryStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_try_statement(
            self,
        ) -> ::std::option::Option<SehTryStatement<'tree>> {
            self.as_statement()?.as_seh_try_statement()
        }
        /**Returns the node if it is of type `switch_statement` ([`SwitchStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_switch_statement(
            self,
        ) -> ::std::option::Option<SwitchStatement<'tree>> {
            self.as_statement()?.as_switch_statement()
        }
        /**Returns the node if it is of type `while_statement` ([`WhileStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_while_statement(self) -> ::std::option::Option<WhileStatement<'tree>> {
            self.as_statement()?.as_while_statement()
        }
        /**Returns the node if it is of type `enum_specifier` ([`EnumSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_enum_specifier(self) -> ::std::option::Option<EnumSpecifier<'tree>> {
            self.as_type_specifier()?.as_enum_specifier()
        }
        /**Returns the node if it is of type `macro_type_specifier` ([`MacroTypeSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_macro_type_specifier(
            self,
        ) -> ::std::option::Option<MacroTypeSpecifier<'tree>> {
            self.as_type_specifier()?.as_macro_type_specifier()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type_specifier()?.as_primitive_type()
        }
        /**Returns the node if it is of type `sized_type_specifier` ([`SizedTypeSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_sized_type_specifier(
            self,
        ) -> ::std::option::Option<SizedTypeSpecifier<'tree>> {
            self.as_type_specifier()?.as_sized_type_specifier()
        }
        /**Returns the node if it is of type `struct_specifier` ([`StructSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_struct_specifier(
            self,
        ) -> ::std::option::Option<StructSpecifier<'tree>> {
            self.as_type_specifier()?.as_struct_specifier()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type_specifier()?.as_type_identifier()
        }
        /**Returns the node if it is of type `union_specifier` ([`UnionSpecifier`]), otherwise returns `None`.

Follows the following chain:
- `type_specifier` ([`TypeSpecifier < 'tree >`], from [`as_type_specifier`](Self::as_type_specifier))*/
        #[inline]
        pub fn as_union_specifier(self) -> ::std::option::Option<UnionSpecifier<'tree>> {
            self.as_type_specifier()?.as_union_specifier()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Declaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
        'tree,
    > {
        type WithLifetime<'a> = Declaration_FunctionDefinition_LinkageSpecification_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef_PreprocInclude_Statement_TypeDefinition_TypeSpecifier<
            'a,
        >;
        const KIND: &'static str = "{declaration | function_definition | linkage_specification | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef | preproc_include | statement | type_definition | type_specifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Declaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declaration(this));
            }
            if let Ok(this) = <FunctionDefinition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FunctionDefinition(this));
            }
            if let Ok(this) = <LinkageSpecification<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LinkageSpecification(this));
            }
            if let Ok(this) = <PreprocCall<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocCall(this));
            }
            if let Ok(this) = <PreprocDef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocDef(this));
            }
            if let Ok(this) = <PreprocFunctionDef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocFunctionDef(this));
            }
            if let Ok(this) = <PreprocIf<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocIf(this));
            }
            if let Ok(this) = <PreprocIfdef<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocIfdef(this));
            }
            if let Ok(this) = <PreprocInclude<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocInclude(this));
            }
            if let Ok(this) = <Statement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Statement(this));
            }
            if let Ok(this) = <TypeDefinition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeDefinition(this));
            }
            if let Ok(this) = <TypeSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeSpecifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw(x),
                Self::LinkageSpecification(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocInclude(x) => ::type_sitter_lib::Node::raw(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FunctionDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LinkageSpecification(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocInclude(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => x.into_raw(),
                Self::FunctionDefinition(x) => x.into_raw(),
                Self::LinkageSpecification(x) => x.into_raw(),
                Self::PreprocCall(x) => x.into_raw(),
                Self::PreprocDef(x) => x.into_raw(),
                Self::PreprocFunctionDef(x) => x.into_raw(),
                Self::PreprocIf(x) => x.into_raw(),
                Self::PreprocIfdef(x) => x.into_raw(),
                Self::PreprocInclude(x) => x.into_raw(),
                Self::Statement(x) => x.into_raw(),
                Self::TypeDefinition(x) => x.into_raw(),
                Self::TypeSpecifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{declaration | statement}`:
- [`Declaration`]
- [`Statement`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Declaration_Statement<'tree> {
        Declaration(Declaration<'tree>),
        Statement(Statement<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Declaration_Statement<'tree> {
        ///Returns the node if it is of type `declaration` ([`Declaration`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration(self) -> ::std::option::Option<Declaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `statement` ([`Statement`]), otherwise returns `None`
        #[inline]
        pub fn as_statement(self) -> ::std::option::Option<Statement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Statement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `attributed_statement` ([`AttributedStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_attributed_statement(
            self,
        ) -> ::std::option::Option<AttributedStatement<'tree>> {
            self.as_statement()?.as_attributed_statement()
        }
        /**Returns the node if it is of type `break_statement` ([`BreakStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_break_statement(self) -> ::std::option::Option<BreakStatement<'tree>> {
            self.as_statement()?.as_break_statement()
        }
        /**Returns the node if it is of type `case_statement` ([`CaseStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_case_statement(self) -> ::std::option::Option<CaseStatement<'tree>> {
            self.as_statement()?.as_case_statement()
        }
        /**Returns the node if it is of type `compound_statement` ([`CompoundStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_compound_statement(
            self,
        ) -> ::std::option::Option<CompoundStatement<'tree>> {
            self.as_statement()?.as_compound_statement()
        }
        /**Returns the node if it is of type `continue_statement` ([`ContinueStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_continue_statement(
            self,
        ) -> ::std::option::Option<ContinueStatement<'tree>> {
            self.as_statement()?.as_continue_statement()
        }
        /**Returns the node if it is of type `do_statement` ([`DoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_do_statement(self) -> ::std::option::Option<DoStatement<'tree>> {
            self.as_statement()?.as_do_statement()
        }
        /**Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            self.as_statement()?.as_expression_statement()
        }
        /**Returns the node if it is of type `for_statement` ([`ForStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_for_statement(self) -> ::std::option::Option<ForStatement<'tree>> {
            self.as_statement()?.as_for_statement()
        }
        /**Returns the node if it is of type `goto_statement` ([`GotoStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_goto_statement(self) -> ::std::option::Option<GotoStatement<'tree>> {
            self.as_statement()?.as_goto_statement()
        }
        /**Returns the node if it is of type `if_statement` ([`IfStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_if_statement(self) -> ::std::option::Option<IfStatement<'tree>> {
            self.as_statement()?.as_if_statement()
        }
        /**Returns the node if it is of type `labeled_statement` ([`LabeledStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_labeled_statement(
            self,
        ) -> ::std::option::Option<LabeledStatement<'tree>> {
            self.as_statement()?.as_labeled_statement()
        }
        /**Returns the node if it is of type `return_statement` ([`ReturnStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_return_statement(
            self,
        ) -> ::std::option::Option<ReturnStatement<'tree>> {
            self.as_statement()?.as_return_statement()
        }
        /**Returns the node if it is of type `seh_leave_statement` ([`SehLeaveStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_leave_statement(
            self,
        ) -> ::std::option::Option<SehLeaveStatement<'tree>> {
            self.as_statement()?.as_seh_leave_statement()
        }
        /**Returns the node if it is of type `seh_try_statement` ([`SehTryStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_seh_try_statement(
            self,
        ) -> ::std::option::Option<SehTryStatement<'tree>> {
            self.as_statement()?.as_seh_try_statement()
        }
        /**Returns the node if it is of type `switch_statement` ([`SwitchStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_switch_statement(
            self,
        ) -> ::std::option::Option<SwitchStatement<'tree>> {
            self.as_statement()?.as_switch_statement()
        }
        /**Returns the node if it is of type `while_statement` ([`WhileStatement`]), otherwise returns `None`.

Follows the following chain:
- `statement` ([`Statement < 'tree >`], from [`as_statement`](Self::as_statement))*/
        #[inline]
        pub fn as_while_statement(self) -> ::std::option::Option<WhileStatement<'tree>> {
            self.as_statement()?.as_while_statement()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Declaration_Statement<'tree> {
        type WithLifetime<'a> = Declaration_Statement<'a>;
        const KIND: &'static str = "{declaration | statement}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Declaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declaration(this));
            }
            if let Ok(this) = <Statement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Statement(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Statement(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Declaration(x) => x.into_raw(),
                Self::Statement(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_declarator | _field_declarator | _type_declarator}`:
- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Declarator_FieldDeclarator_TypeDeclarator<'tree> {
        Declarator(Declarator<'tree>),
        FieldDeclarator(FieldDeclarator<'tree>),
        TypeDeclarator(TypeDeclarator<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Declarator_FieldDeclarator_TypeDeclarator<'tree> {
        ///Returns the node if it is of type `_declarator` ([`Declarator`]), otherwise returns `None`
        #[inline]
        pub fn as_declarator(self) -> ::std::option::Option<Declarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_field_declarator` ([`FieldDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_field_declarator(
            self,
        ) -> ::std::option::Option<FieldDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_type_declarator` ([`TypeDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_type_declarator(self) -> ::std::option::Option<TypeDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_array_declarator(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_attributed_declarator(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_function_declarator(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_declarator()?.as_identifier()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_pointer_declarator(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_array_declarator_(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_field_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_attributed_declarator_(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_field_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_field_identifier(
            self,
        ) -> ::std::option::Option<FieldIdentifier<'tree>> {
            self.as_field_declarator()?.as_field_identifier()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_function_declarator_(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_field_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator_(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_field_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_pointer_declarator_(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_field_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_array_declarator__(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_type_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_attributed_declarator__(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_type_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_function_declarator__(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_type_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator__(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_type_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_pointer_declarator__(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_type_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type_declarator()?.as_primitive_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type_declarator()?.as_type_identifier()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Declarator_FieldDeclarator_TypeDeclarator<'tree> {
        type WithLifetime<'a> = Declarator_FieldDeclarator_TypeDeclarator<'a>;
        const KIND: &'static str = "{_declarator | _field_declarator | _type_declarator}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Declarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declarator(this));
            }
            if let Ok(this) = <FieldDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldDeclarator(this));
            }
            if let Ok(this) = <TypeDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeDeclarator(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDeclarator(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => x.into_raw(),
                Self::FieldDeclarator(x) => x.into_raw(),
                Self::TypeDeclarator(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_declarator | _field_declarator | _type_declarator | attribute_declaration}`:
- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]
- [`AttributeDeclaration`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Declarator_FieldDeclarator_TypeDeclarator_AttributeDeclaration<'tree> {
        Declarator(Declarator<'tree>),
        FieldDeclarator(FieldDeclarator<'tree>),
        TypeDeclarator(TypeDeclarator<'tree>),
        AttributeDeclaration(AttributeDeclaration<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Declarator_FieldDeclarator_TypeDeclarator_AttributeDeclaration<'tree> {
        ///Returns the node if it is of type `_declarator` ([`Declarator`]), otherwise returns `None`
        #[inline]
        pub fn as_declarator(self) -> ::std::option::Option<Declarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_field_declarator` ([`FieldDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_field_declarator(
            self,
        ) -> ::std::option::Option<FieldDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_type_declarator` ([`TypeDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_type_declarator(self) -> ::std::option::Option<TypeDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `attribute_declaration` ([`AttributeDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_declaration(
            self,
        ) -> ::std::option::Option<AttributeDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_array_declarator(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_attributed_declarator(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_function_declarator(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_declarator()?.as_identifier()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_pointer_declarator(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_array_declarator_(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_field_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_attributed_declarator_(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_field_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_field_identifier(
            self,
        ) -> ::std::option::Option<FieldIdentifier<'tree>> {
            self.as_field_declarator()?.as_field_identifier()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_function_declarator_(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_field_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator_(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_field_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_pointer_declarator_(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_field_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_array_declarator__(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_type_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_attributed_declarator__(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_type_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_function_declarator__(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_type_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator__(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_type_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_pointer_declarator__(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_type_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type_declarator()?.as_primitive_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type_declarator()?.as_type_identifier()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Declarator_FieldDeclarator_TypeDeclarator_AttributeDeclaration<'tree> {
        type WithLifetime<'a> = Declarator_FieldDeclarator_TypeDeclarator_AttributeDeclaration<
            'a,
        >;
        const KIND: &'static str = "{_declarator | _field_declarator | _type_declarator | attribute_declaration}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Declarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declarator(this));
            }
            if let Ok(this) = <FieldDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldDeclarator(this));
            }
            if let Ok(this) = <TypeDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeDeclarator(this));
            }
            if let Ok(this) = <AttributeDeclaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeDeclaration(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AttributeDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => x.into_raw(),
                Self::FieldDeclarator(x) => x.into_raw(),
                Self::TypeDeclarator(x) => x.into_raw(),
                Self::AttributeDeclaration(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_declarator | _field_declarator | _type_declarator | ms_call_modifier}`:
- [`Declarator`]
- [`FieldDeclarator`]
- [`TypeDeclarator`]
- [`MsCallModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Declarator_FieldDeclarator_TypeDeclarator_MsCallModifier<'tree> {
        Declarator(Declarator<'tree>),
        FieldDeclarator(FieldDeclarator<'tree>),
        TypeDeclarator(TypeDeclarator<'tree>),
        MsCallModifier(MsCallModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Declarator_FieldDeclarator_TypeDeclarator_MsCallModifier<'tree> {
        ///Returns the node if it is of type `_declarator` ([`Declarator`]), otherwise returns `None`
        #[inline]
        pub fn as_declarator(self) -> ::std::option::Option<Declarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Declarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_field_declarator` ([`FieldDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_field_declarator(
            self,
        ) -> ::std::option::Option<FieldDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_type_declarator` ([`TypeDeclarator`]), otherwise returns `None`
        #[inline]
        pub fn as_type_declarator(self) -> ::std::option::Option<TypeDeclarator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDeclarator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_call_modifier` ([`MsCallModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_call_modifier(
            self,
        ) -> ::std::option::Option<MsCallModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsCallModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_array_declarator(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_attributed_declarator(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_function_declarator(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_declarator()?.as_identifier()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_declarator` ([`Declarator < 'tree >`], from [`as_declarator`](Self::as_declarator))*/
        #[inline]
        pub fn as_pointer_declarator(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_array_declarator_(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_field_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_attributed_declarator_(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_field_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_field_identifier(
            self,
        ) -> ::std::option::Option<FieldIdentifier<'tree>> {
            self.as_field_declarator()?.as_field_identifier()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_function_declarator_(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_field_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator_(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_field_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_field_declarator` ([`FieldDeclarator < 'tree >`], from [`as_field_declarator`](Self::as_field_declarator))*/
        #[inline]
        pub fn as_pointer_declarator_(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_field_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `array_declarator` ([`ArrayDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_array_declarator__(
            self,
        ) -> ::std::option::Option<ArrayDeclarator<'tree>> {
            self.as_type_declarator()?.as_array_declarator()
        }
        /**Returns the node if it is of type `attributed_declarator` ([`AttributedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_attributed_declarator__(
            self,
        ) -> ::std::option::Option<AttributedDeclarator<'tree>> {
            self.as_type_declarator()?.as_attributed_declarator()
        }
        /**Returns the node if it is of type `function_declarator` ([`FunctionDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_function_declarator__(
            self,
        ) -> ::std::option::Option<FunctionDeclarator<'tree>> {
            self.as_type_declarator()?.as_function_declarator()
        }
        /**Returns the node if it is of type `parenthesized_declarator` ([`ParenthesizedDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_parenthesized_declarator__(
            self,
        ) -> ::std::option::Option<ParenthesizedDeclarator<'tree>> {
            self.as_type_declarator()?.as_parenthesized_declarator()
        }
        /**Returns the node if it is of type `pointer_declarator` ([`PointerDeclarator`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_pointer_declarator__(
            self,
        ) -> ::std::option::Option<PointerDeclarator<'tree>> {
            self.as_type_declarator()?.as_pointer_declarator()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type_declarator()?.as_primitive_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type_declarator` ([`TypeDeclarator < 'tree >`], from [`as_type_declarator`](Self::as_type_declarator))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type_declarator()?.as_type_identifier()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Declarator_FieldDeclarator_TypeDeclarator_MsCallModifier<'tree> {
        type WithLifetime<'a> = Declarator_FieldDeclarator_TypeDeclarator_MsCallModifier<
            'a,
        >;
        const KIND: &'static str = "{_declarator | _field_declarator | _type_declarator | ms_call_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Declarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Declarator(this));
            }
            if let Ok(this) = <FieldDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldDeclarator(this));
            }
            if let Ok(this) = <TypeDeclarator<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeDeclarator(this));
            }
            if let Ok(this) = <MsCallModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MsCallModifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDeclarator(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDeclarator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsCallModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Declarator(x) => x.into_raw(),
                Self::FieldDeclarator(x) => x.into_raw(),
                Self::TypeDeclarator(x) => x.into_raw(),
                Self::MsCallModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{enumerator | preproc_call | preproc_if | preproc_ifdef}`:
- [`Enumerator`]
- [`PreprocCall`]
- [`PreprocIf`]
- [`PreprocIfdef`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Enumerator_PreprocCall_PreprocIf_PreprocIfdef<'tree> {
        Enumerator(Enumerator<'tree>),
        PreprocCall(PreprocCall<'tree>),
        PreprocIf(PreprocIf<'tree>),
        PreprocIfdef(PreprocIfdef<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Enumerator_PreprocCall_PreprocIf_PreprocIfdef<'tree> {
        ///Returns the node if it is of type `enumerator` ([`Enumerator`]), otherwise returns `None`
        #[inline]
        pub fn as_enumerator(self) -> ::std::option::Option<Enumerator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Enumerator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_call` ([`PreprocCall`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_call(self) -> ::std::option::Option<PreprocCall<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocCall(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_if` ([`PreprocIf`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_if(self) -> ::std::option::Option<PreprocIf<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIf(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_ifdef` ([`PreprocIfdef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_ifdef(self) -> ::std::option::Option<PreprocIfdef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIfdef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Enumerator_PreprocCall_PreprocIf_PreprocIfdef<'tree> {
        type WithLifetime<'a> = Enumerator_PreprocCall_PreprocIf_PreprocIfdef<'a>;
        const KIND: &'static str = "{enumerator | preproc_call | preproc_if | preproc_ifdef}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "enumerator" => {
                    Ok(unsafe {
                        Self::Enumerator(
                            <Enumerator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_call" => {
                    Ok(unsafe {
                        Self::PreprocCall(
                            <PreprocCall<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_if" => {
                    Ok(unsafe {
                        Self::PreprocIf(
                            <PreprocIf<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_ifdef" => {
                    Ok(unsafe {
                        Self::PreprocIfdef(
                            <PreprocIfdef<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Enumerator(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Enumerator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Enumerator(x) => x.into_raw(),
                Self::PreprocCall(x) => x.into_raw(),
                Self::PreprocIf(x) => x.into_raw(),
                Self::PreprocIfdef(x) => x.into_raw(),
            }
        }
    }
    /**One of `{escape_sequence | string_content}`:
- [`EscapeSequence`]
- [`StringContent`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EscapeSequence_StringContent<'tree> {
        EscapeSequence(EscapeSequence<'tree>),
        StringContent(StringContent<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EscapeSequence_StringContent<'tree> {
        ///Returns the node if it is of type `escape_sequence` ([`EscapeSequence`]), otherwise returns `None`
        #[inline]
        pub fn as_escape_sequence(self) -> ::std::option::Option<EscapeSequence<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EscapeSequence(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `string_content` ([`StringContent`]), otherwise returns `None`
        #[inline]
        pub fn as_string_content(self) -> ::std::option::Option<StringContent<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StringContent(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for EscapeSequence_StringContent<'tree> {
        type WithLifetime<'a> = EscapeSequence_StringContent<'a>;
        const KIND: &'static str = "{escape_sequence | string_content}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "escape_sequence" => {
                    Ok(unsafe {
                        Self::EscapeSequence(
                            <EscapeSequence<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "string_content" => {
                    Ok(unsafe {
                        Self::StringContent(
                            <StringContent<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => ::type_sitter_lib::Node::raw(x),
                Self::StringContent(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StringContent(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.into_raw(),
                Self::StringContent(x) => x.into_raw(),
            }
        }
    }
    /**One of `{expression | initializer_list}`:
- [`Expression`]
- [`InitializerList`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_InitializerList<'tree> {
        Expression(Expression<'tree>),
        InitializerList(InitializerList<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_InitializerList<'tree> {
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `initializer_list` ([`InitializerList`]), otherwise returns `None`
        #[inline]
        pub fn as_initializer_list(
            self,
        ) -> ::std::option::Option<InitializerList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::InitializerList(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Expression_InitializerList<'tree> {
        type WithLifetime<'a> = Expression_InitializerList<'a>;
        const KIND: &'static str = "{expression | initializer_list}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <InitializerList<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::InitializerList(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::InitializerList(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::InitializerList(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::InitializerList(x) => x.into_raw(),
            }
        }
    }
    /**One of `{expression | initializer_list | initializer_pair}`:
- [`Expression`]
- [`InitializerList`]
- [`InitializerPair`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_InitializerList_InitializerPair<'tree> {
        Expression(Expression<'tree>),
        InitializerList(InitializerList<'tree>),
        InitializerPair(InitializerPair<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_InitializerList_InitializerPair<'tree> {
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `initializer_list` ([`InitializerList`]), otherwise returns `None`
        #[inline]
        pub fn as_initializer_list(
            self,
        ) -> ::std::option::Option<InitializerList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::InitializerList(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `initializer_pair` ([`InitializerPair`]), otherwise returns `None`
        #[inline]
        pub fn as_initializer_pair(
            self,
        ) -> ::std::option::Option<InitializerPair<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::InitializerPair(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Expression_InitializerList_InitializerPair<'tree> {
        type WithLifetime<'a> = Expression_InitializerList_InitializerPair<'a>;
        const KIND: &'static str = "{expression | initializer_list | initializer_pair}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <InitializerList<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::InitializerList(this));
            }
            if let Ok(this) = <InitializerPair<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::InitializerPair(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::InitializerList(x) => ::type_sitter_lib::Node::raw(x),
                Self::InitializerPair(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::InitializerList(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::InitializerPair(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::InitializerList(x) => x.into_raw(),
                Self::InitializerPair(x) => x.into_raw(),
            }
        }
    }
    /**One of `{expression | preproc_defined}`:
- [`Expression`]
- [`PreprocDefined`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_PreprocDefined<'tree> {
        Expression(Expression<'tree>),
        PreprocDefined(PreprocDefined<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_PreprocDefined<'tree> {
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_defined` ([`PreprocDefined`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_defined(self) -> ::std::option::Option<PreprocDefined<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDefined(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Expression_PreprocDefined<'tree> {
        type WithLifetime<'a> = Expression_PreprocDefined<'a>;
        const KIND: &'static str = "{expression | preproc_defined}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <PreprocDefined<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PreprocDefined(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDefined(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::PreprocDefined(x) => x.into_raw(),
            }
        }
    }
    /**One of `{expression | type_descriptor}`:
- [`Expression`]
- [`TypeDescriptor`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_TypeDescriptor<'tree> {
        Expression(Expression<'tree>),
        TypeDescriptor(TypeDescriptor<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_TypeDescriptor<'tree> {
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_descriptor` ([`TypeDescriptor`]), otherwise returns `None`
        #[inline]
        pub fn as_type_descriptor(self) -> ::std::option::Option<TypeDescriptor<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeDescriptor(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Expression_TypeDescriptor<'tree> {
        type WithLifetime<'a> = Expression_TypeDescriptor<'a>;
        const KIND: &'static str = "{expression | type_descriptor}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <TypeDescriptor<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeDescriptor(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeDescriptor(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeDescriptor(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::TypeDescriptor(x) => x.into_raw(),
            }
        }
    }
    /**One of `{field_declaration | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef}`:
- [`FieldDeclaration`]
- [`PreprocCall`]
- [`PreprocDef`]
- [`PreprocFunctionDef`]
- [`PreprocIf`]
- [`PreprocIfdef`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldDeclaration_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef<
        'tree,
    > {
        FieldDeclaration(FieldDeclaration<'tree>),
        PreprocCall(PreprocCall<'tree>),
        PreprocDef(PreprocDef<'tree>),
        PreprocFunctionDef(PreprocFunctionDef<'tree>),
        PreprocIf(PreprocIf<'tree>),
        PreprocIfdef(PreprocIfdef<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > FieldDeclaration_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef<
        'tree,
    > {
        ///Returns the node if it is of type `field_declaration` ([`FieldDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_field_declaration(
            self,
        ) -> ::std::option::Option<FieldDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_call` ([`PreprocCall`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_call(self) -> ::std::option::Option<PreprocCall<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocCall(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_def` ([`PreprocDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_def(self) -> ::std::option::Option<PreprocDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_function_def` ([`PreprocFunctionDef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_function_def(
            self,
        ) -> ::std::option::Option<PreprocFunctionDef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocFunctionDef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_if` ([`PreprocIf`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_if(self) -> ::std::option::Option<PreprocIf<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIf(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_ifdef` ([`PreprocIfdef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_ifdef(self) -> ::std::option::Option<PreprocIfdef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocIfdef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FieldDeclaration_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef<
        'tree,
    > {
        type WithLifetime<'a> = FieldDeclaration_PreprocCall_PreprocDef_PreprocFunctionDef_PreprocIf_PreprocIfdef<
            'a,
        >;
        const KIND: &'static str = "{field_declaration | preproc_call | preproc_def | preproc_function_def | preproc_if | preproc_ifdef}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "field_declaration" => {
                    Ok(unsafe {
                        Self::FieldDeclaration(
                            <FieldDeclaration<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_call" => {
                    Ok(unsafe {
                        Self::PreprocCall(
                            <PreprocCall<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_def" => {
                    Ok(unsafe {
                        Self::PreprocDef(
                            <PreprocDef<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_function_def" => {
                    Ok(unsafe {
                        Self::PreprocFunctionDef(
                            <PreprocFunctionDef<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_if" => {
                    Ok(unsafe {
                        Self::PreprocIf(
                            <PreprocIf<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_ifdef" => {
                    Ok(unsafe {
                        Self::PreprocIfdef(
                            <PreprocIfdef<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDeclaration(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocCall(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocFunctionDef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIf(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocIfdef(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDeclaration(x) => x.into_raw(),
                Self::PreprocCall(x) => x.into_raw(),
                Self::PreprocDef(x) => x.into_raw(),
                Self::PreprocFunctionDef(x) => x.into_raw(),
                Self::PreprocIf(x) => x.into_raw(),
                Self::PreprocIfdef(x) => x.into_raw(),
            }
        }
    }
    /**One of `{field_designator | field_identifier | subscript_designator | subscript_range_designator}`:
- [`FieldDesignator`]
- [`FieldIdentifier`]
- [`SubscriptDesignator`]
- [`SubscriptRangeDesignator`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldDesignator_FieldIdentifier_SubscriptDesignator_SubscriptRangeDesignator<
        'tree,
    > {
        FieldDesignator(FieldDesignator<'tree>),
        FieldIdentifier(FieldIdentifier<'tree>),
        SubscriptDesignator(SubscriptDesignator<'tree>),
        SubscriptRangeDesignator(SubscriptRangeDesignator<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > FieldDesignator_FieldIdentifier_SubscriptDesignator_SubscriptRangeDesignator<
        'tree,
    > {
        ///Returns the node if it is of type `field_designator` ([`FieldDesignator`]), otherwise returns `None`
        #[inline]
        pub fn as_field_designator(
            self,
        ) -> ::std::option::Option<FieldDesignator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDesignator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_field_identifier(
            self,
        ) -> ::std::option::Option<FieldIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `subscript_designator` ([`SubscriptDesignator`]), otherwise returns `None`
        #[inline]
        pub fn as_subscript_designator(
            self,
        ) -> ::std::option::Option<SubscriptDesignator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubscriptDesignator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `subscript_range_designator` ([`SubscriptRangeDesignator`]), otherwise returns `None`
        #[inline]
        pub fn as_subscript_range_designator(
            self,
        ) -> ::std::option::Option<SubscriptRangeDesignator<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubscriptRangeDesignator(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FieldDesignator_FieldIdentifier_SubscriptDesignator_SubscriptRangeDesignator<
        'tree,
    > {
        type WithLifetime<'a> = FieldDesignator_FieldIdentifier_SubscriptDesignator_SubscriptRangeDesignator<
            'a,
        >;
        const KIND: &'static str = "{field_designator | field_identifier | subscript_designator | subscript_range_designator}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "field_designator" => {
                    Ok(unsafe {
                        Self::FieldDesignator(
                            <FieldDesignator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "field_identifier" => {
                    Ok(unsafe {
                        Self::FieldIdentifier(
                            <FieldIdentifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "subscript_designator" => {
                    Ok(unsafe {
                        Self::SubscriptDesignator(
                            <SubscriptDesignator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "subscript_range_designator" => {
                    Ok(unsafe {
                        Self::SubscriptRangeDesignator(
                            <SubscriptRangeDesignator<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDesignator(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::SubscriptDesignator(x) => ::type_sitter_lib::Node::raw(x),
                Self::SubscriptRangeDesignator(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDesignator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SubscriptDesignator(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SubscriptRangeDesignator(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDesignator(x) => x.into_raw(),
                Self::FieldIdentifier(x) => x.into_raw(),
                Self::SubscriptDesignator(x) => x.into_raw(),
                Self::SubscriptRangeDesignator(x) => x.into_raw(),
            }
        }
    }
    /**One of `{identifier | string_literal}`:
- [`Identifier`]
- [`StringLiteral`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_StringLiteral<'tree> {
        Identifier(Identifier<'tree>),
        StringLiteral(StringLiteral<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_StringLiteral<'tree> {
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StringLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Identifier_StringLiteral<'tree> {
        type WithLifetime<'a> = Identifier_StringLiteral<'a>;
        const KIND: &'static str = "{identifier | string_literal}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "identifier" => {
                    Ok(unsafe {
                        Self::Identifier(
                            <Identifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "string_literal" => {
                    Ok(unsafe {
                        Self::StringLiteral(
                            <StringLiteral<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::StringLiteral(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::StringLiteral(x) => x.into_raw(),
            }
        }
    }
    /**One of `{%= | &= | *= | += | -= | /= | <<= | = | >>= | ^= | |=}`:
- [`symbols::ModEq`]
- [`symbols::AndEq`]
- [`symbols::MulEq`]
- [`symbols::AddEq`]
- [`symbols::SubEq`]
- [`symbols::DivEq`]
- [`symbols::LtLtEq`]
- [`symbols::Eq`]
- [`symbols::GtGtEq`]
- [`symbols::BitXorEq`]
- [`symbols::OrEq`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_Eq_GtGtEq_BitXorEq_OrEq<'tree> {
        ModEq(symbols::ModEq<'tree>),
        AndEq(symbols::AndEq<'tree>),
        MulEq(symbols::MulEq<'tree>),
        AddEq(symbols::AddEq<'tree>),
        SubEq(symbols::SubEq<'tree>),
        DivEq(symbols::DivEq<'tree>),
        LtLtEq(symbols::LtLtEq<'tree>),
        Eq(symbols::Eq<'tree>),
        GtGtEq(symbols::GtGtEq<'tree>),
        BitXorEq(symbols::BitXorEq<'tree>),
        OrEq(symbols::OrEq<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_Eq_GtGtEq_BitXorEq_OrEq<'tree> {
        ///Returns the node if it is of type `%=` ([`symbols::ModEq`]), otherwise returns `None`
        #[inline]
        pub fn as_mod_eq(self) -> ::std::option::Option<symbols::ModEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ModEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `&=` ([`symbols::AndEq`]), otherwise returns `None`
        #[inline]
        pub fn as_and_eq(self) -> ::std::option::Option<symbols::AndEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AndEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `*=` ([`symbols::MulEq`]), otherwise returns `None`
        #[inline]
        pub fn as_mul_eq(self) -> ::std::option::Option<symbols::MulEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MulEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `+=` ([`symbols::AddEq`]), otherwise returns `None`
        #[inline]
        pub fn as_add_eq(self) -> ::std::option::Option<symbols::AddEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AddEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `-=` ([`symbols::SubEq`]), otherwise returns `None`
        #[inline]
        pub fn as_sub_eq(self) -> ::std::option::Option<symbols::SubEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `/=` ([`symbols::DivEq`]), otherwise returns `None`
        #[inline]
        pub fn as_div_eq(self) -> ::std::option::Option<symbols::DivEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DivEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<<=` ([`symbols::LtLtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_lt_lt_eq(self) -> ::std::option::Option<symbols::LtLtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtLtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `=` ([`symbols::Eq`]), otherwise returns `None`
        #[inline]
        pub fn as_eq(self) -> ::std::option::Option<symbols::Eq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Eq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>>=` ([`symbols::GtGtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_gt_gt_eq(self) -> ::std::option::Option<symbols::GtGtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtGtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `^=` ([`symbols::BitXorEq`]), otherwise returns `None`
        #[inline]
        pub fn as_bit_xor_eq(self) -> ::std::option::Option<symbols::BitXorEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitXorEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `|=` ([`symbols::OrEq`]), otherwise returns `None`
        #[inline]
        pub fn as_or_eq(self) -> ::std::option::Option<symbols::OrEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_Eq_GtGtEq_BitXorEq_OrEq<'tree> {
        type WithLifetime<'a> = ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_Eq_GtGtEq_BitXorEq_OrEq<
            'a,
        >;
        const KIND: &'static str = "{%= | &= | *= | += | -= | /= | <<= | = | >>= | ^= | |=}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "%=" => {
                    Ok(unsafe {
                        Self::ModEq(
                            <symbols::ModEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "&=" => {
                    Ok(unsafe {
                        Self::AndEq(
                            <symbols::AndEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "*=" => {
                    Ok(unsafe {
                        Self::MulEq(
                            <symbols::MulEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "+=" => {
                    Ok(unsafe {
                        Self::AddEq(
                            <symbols::AddEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "-=" => {
                    Ok(unsafe {
                        Self::SubEq(
                            <symbols::SubEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "/=" => {
                    Ok(unsafe {
                        Self::DivEq(
                            <symbols::DivEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "<<=" => {
                    Ok(unsafe {
                        Self::LtLtEq(
                            <symbols::LtLtEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "=" => {
                    Ok(unsafe {
                        Self::Eq(
                            <symbols::Eq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                ">>=" => {
                    Ok(unsafe {
                        Self::GtGtEq(
                            <symbols::GtGtEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "^=" => {
                    Ok(unsafe {
                        Self::BitXorEq(
                            <symbols::BitXorEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "|=" => {
                    Ok(unsafe {
                        Self::OrEq(
                            <symbols::OrEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ModEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::AndEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::MulEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::AddEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::SubEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::DivEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::LtLtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::Eq(x) => ::type_sitter_lib::Node::raw(x),
                Self::GtGtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::BitXorEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::OrEq(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ModEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AndEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MulEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AddEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SubEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::DivEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LtLtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Eq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GtGtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BitXorEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::OrEq(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ModEq(x) => x.into_raw(),
                Self::AndEq(x) => x.into_raw(),
                Self::MulEq(x) => x.into_raw(),
                Self::AddEq(x) => x.into_raw(),
                Self::SubEq(x) => x.into_raw(),
                Self::DivEq(x) => x.into_raw(),
                Self::LtLtEq(x) => x.into_raw(),
                Self::Eq(x) => x.into_raw(),
                Self::GtGtEq(x) => x.into_raw(),
                Self::BitXorEq(x) => x.into_raw(),
                Self::OrEq(x) => x.into_raw(),
            }
        }
    }
    /**One of `{ms_based_modifier | ms_pointer_modifier | type_qualifier}`:
- [`MsBasedModifier`]
- [`MsPointerModifier`]
- [`TypeQualifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum MsBasedModifier_MsPointerModifier_TypeQualifier<'tree> {
        MsBasedModifier(MsBasedModifier<'tree>),
        MsPointerModifier(MsPointerModifier<'tree>),
        TypeQualifier(TypeQualifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MsBasedModifier_MsPointerModifier_TypeQualifier<'tree> {
        ///Returns the node if it is of type `ms_based_modifier` ([`MsBasedModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_based_modifier(
            self,
        ) -> ::std::option::Option<MsBasedModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsBasedModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_pointer_modifier` ([`MsPointerModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_pointer_modifier(
            self,
        ) -> ::std::option::Option<MsPointerModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsPointerModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_qualifier` ([`TypeQualifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_qualifier(self) -> ::std::option::Option<TypeQualifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeQualifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for MsBasedModifier_MsPointerModifier_TypeQualifier<'tree> {
        type WithLifetime<'a> = MsBasedModifier_MsPointerModifier_TypeQualifier<'a>;
        const KIND: &'static str = "{ms_based_modifier | ms_pointer_modifier | type_qualifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "ms_based_modifier" => {
                    Ok(unsafe {
                        Self::MsBasedModifier(
                            <MsBasedModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_pointer_modifier" => {
                    Ok(unsafe {
                        Self::MsPointerModifier(
                            <MsPointerModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_qualifier" => {
                    Ok(unsafe {
                        Self::TypeQualifier(
                            <TypeQualifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::MsBasedModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsPointerModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::MsBasedModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsPointerModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::MsBasedModifier(x) => x.into_raw(),
                Self::MsPointerModifier(x) => x.into_raw(),
                Self::TypeQualifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{ms_pointer_modifier | type_qualifier}`:
- [`MsPointerModifier`]
- [`TypeQualifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum MsPointerModifier_TypeQualifier<'tree> {
        MsPointerModifier(MsPointerModifier<'tree>),
        TypeQualifier(TypeQualifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MsPointerModifier_TypeQualifier<'tree> {
        ///Returns the node if it is of type `ms_pointer_modifier` ([`MsPointerModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_pointer_modifier(
            self,
        ) -> ::std::option::Option<MsPointerModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsPointerModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_qualifier` ([`TypeQualifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_qualifier(self) -> ::std::option::Option<TypeQualifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeQualifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for MsPointerModifier_TypeQualifier<'tree> {
        type WithLifetime<'a> = MsPointerModifier_TypeQualifier<'a>;
        const KIND: &'static str = "{ms_pointer_modifier | type_qualifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "ms_pointer_modifier" => {
                    Ok(unsafe {
                        Self::MsPointerModifier(
                            <MsPointerModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_qualifier" => {
                    Ok(unsafe {
                        Self::TypeQualifier(
                            <TypeQualifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::MsPointerModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::MsPointerModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeQualifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::MsPointerModifier(x) => x.into_raw(),
                Self::TypeQualifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{ms_restrict_modifier | ms_signed_ptr_modifier | ms_unaligned_ptr_modifier | ms_unsigned_ptr_modifier}`:
- [`MsRestrictModifier`]
- [`MsSignedPtrModifier`]
- [`MsUnalignedPtrModifier`]
- [`MsUnsignedPtrModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum MsRestrictModifier_MsSignedPtrModifier_MsUnalignedPtrModifier_MsUnsignedPtrModifier<
        'tree,
    > {
        MsRestrictModifier(MsRestrictModifier<'tree>),
        MsSignedPtrModifier(MsSignedPtrModifier<'tree>),
        MsUnalignedPtrModifier(MsUnalignedPtrModifier<'tree>),
        MsUnsignedPtrModifier(MsUnsignedPtrModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > MsRestrictModifier_MsSignedPtrModifier_MsUnalignedPtrModifier_MsUnsignedPtrModifier<
        'tree,
    > {
        ///Returns the node if it is of type `ms_restrict_modifier` ([`MsRestrictModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_restrict_modifier(
            self,
        ) -> ::std::option::Option<MsRestrictModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsRestrictModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_signed_ptr_modifier` ([`MsSignedPtrModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_signed_ptr_modifier(
            self,
        ) -> ::std::option::Option<MsSignedPtrModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsSignedPtrModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_unaligned_ptr_modifier` ([`MsUnalignedPtrModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_unaligned_ptr_modifier(
            self,
        ) -> ::std::option::Option<MsUnalignedPtrModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsUnalignedPtrModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ms_unsigned_ptr_modifier` ([`MsUnsignedPtrModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_ms_unsigned_ptr_modifier(
            self,
        ) -> ::std::option::Option<MsUnsignedPtrModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MsUnsignedPtrModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for MsRestrictModifier_MsSignedPtrModifier_MsUnalignedPtrModifier_MsUnsignedPtrModifier<
        'tree,
    > {
        type WithLifetime<'a> = MsRestrictModifier_MsSignedPtrModifier_MsUnalignedPtrModifier_MsUnsignedPtrModifier<
            'a,
        >;
        const KIND: &'static str = "{ms_restrict_modifier | ms_signed_ptr_modifier | ms_unaligned_ptr_modifier | ms_unsigned_ptr_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "ms_restrict_modifier" => {
                    Ok(unsafe {
                        Self::MsRestrictModifier(
                            <MsRestrictModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_signed_ptr_modifier" => {
                    Ok(unsafe {
                        Self::MsSignedPtrModifier(
                            <MsSignedPtrModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_unaligned_ptr_modifier" => {
                    Ok(unsafe {
                        Self::MsUnalignedPtrModifier(
                            <MsUnalignedPtrModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "ms_unsigned_ptr_modifier" => {
                    Ok(unsafe {
                        Self::MsUnsignedPtrModifier(
                            <MsUnsignedPtrModifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::MsRestrictModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsSignedPtrModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsUnalignedPtrModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::MsUnsignedPtrModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::MsRestrictModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsSignedPtrModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsUnalignedPtrModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MsUnsignedPtrModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::MsRestrictModifier(x) => x.into_raw(),
                Self::MsSignedPtrModifier(x) => x.into_raw(),
                Self::MsUnalignedPtrModifier(x) => x.into_raw(),
                Self::MsUnsignedPtrModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{* | expression}`:
- [`symbols::Mul`]
- [`Expression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Mul_Expression<'tree> {
        Mul(symbols::Mul<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mul_Expression<'tree> {
        ///Returns the node if it is of type `*` ([`symbols::Mul`]), otherwise returns `None`
        #[inline]
        pub fn as_mul(self) -> ::std::option::Option<symbols::Mul<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mul(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `alignof_expression` ([`AlignofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_alignof_expression(
            self,
        ) -> ::std::option::Option<AlignofExpression<'tree>> {
            self.as_expression()?.as_alignof_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `cast_expression` ([`CastExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_cast_expression(self) -> ::std::option::Option<CastExpression<'tree>> {
            self.as_expression()?.as_cast_expression()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_char_literal()
        }
        /**Returns the node if it is of type `compound_literal_expression` ([`CompoundLiteralExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_literal_expression(
            self,
        ) -> ::std::option::Option<CompoundLiteralExpression<'tree>> {
            self.as_expression()?.as_compound_literal_expression()
        }
        /**Returns the node if it is of type `concatenated_string` ([`ConcatenatedString`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_concatenated_string(
            self,
        ) -> ::std::option::Option<ConcatenatedString<'tree>> {
            self.as_expression()?.as_concatenated_string()
        }
        /**Returns the node if it is of type `conditional_expression` ([`ConditionalExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_conditional_expression(
            self,
        ) -> ::std::option::Option<ConditionalExpression<'tree>> {
            self.as_expression()?.as_conditional_expression()
        }
        /**Returns the node if it is of type `extension_expression` ([`ExtensionExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_extension_expression(
            self,
        ) -> ::std::option::Option<ExtensionExpression<'tree>> {
            self.as_expression()?.as_extension_expression()
        }
        /**Returns the node if it is of type `false` ([`False`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_false(self) -> ::std::option::Option<False<'tree>> {
            self.as_expression()?.as_false()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `generic_expression` ([`GenericExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_expression(
            self,
        ) -> ::std::option::Option<GenericExpression<'tree>> {
            self.as_expression()?.as_generic_expression()
        }
        /**Returns the node if it is of type `gnu_asm_expression` ([`GnuAsmExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gnu_asm_expression(
            self,
        ) -> ::std::option::Option<GnuAsmExpression<'tree>> {
            self.as_expression()?.as_gnu_asm_expression()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `null` ([`Null`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_null(self) -> ::std::option::Option<Null<'tree>> {
            self.as_expression()?.as_null()
        }
        /**Returns the node if it is of type `number_literal` ([`NumberLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_number_literal(self) -> ::std::option::Option<NumberLiteral<'tree>> {
            self.as_expression()?.as_number_literal()
        }
        /**Returns the node if it is of type `offsetof_expression` ([`OffsetofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_offsetof_expression(
            self,
        ) -> ::std::option::Option<OffsetofExpression<'tree>> {
            self.as_expression()?.as_offsetof_expression()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `pointer_expression` ([`PointerExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_pointer_expression(
            self,
        ) -> ::std::option::Option<PointerExpression<'tree>> {
            self.as_expression()?.as_pointer_expression()
        }
        /**Returns the node if it is of type `sizeof_expression` ([`SizeofExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_sizeof_expression(
            self,
        ) -> ::std::option::Option<SizeofExpression<'tree>> {
            self.as_expression()?.as_sizeof_expression()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_string_literal()
        }
        /**Returns the node if it is of type `subscript_expression` ([`SubscriptExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_subscript_expression(
            self,
        ) -> ::std::option::Option<SubscriptExpression<'tree>> {
            self.as_expression()?.as_subscript_expression()
        }
        /**Returns the node if it is of type `true` ([`True`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_true(self) -> ::std::option::Option<True<'tree>> {
            self.as_expression()?.as_true()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `update_expression` ([`UpdateExpression`]), otherwise returns `None`.

Follows the following chain:
- `expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_update_expression(
            self,
        ) -> ::std::option::Option<UpdateExpression<'tree>> {
            self.as_expression()?.as_update_expression()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Mul_Expression<'tree> {
        type WithLifetime<'a> = Mul_Expression<'a>;
        const KIND: &'static str = "{* | expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <symbols::Mul<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Mul(this));
            }
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Mul(x) => ::type_sitter_lib::Node::raw(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Mul(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Mul(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}`:
- [`symbols::NotEq`]
- [`symbols::Mod`]
- [`symbols::And`]
- [`symbols::AndAnd`]
- [`symbols::Mul`]
- [`symbols::Add`]
- [`symbols::Sub`]
- [`symbols::Div`]
- [`symbols::Lt`]
- [`symbols::LtLt`]
- [`symbols::LtEq`]
- [`symbols::EqEq`]
- [`symbols::Gt`]
- [`symbols::GtEq`]
- [`symbols::GtGt`]
- [`symbols::BitXor`]
- [`symbols::Or`]
- [`symbols::OrOr`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
        'tree,
    > {
        NotEq(symbols::NotEq<'tree>),
        Mod(symbols::Mod<'tree>),
        And(symbols::And<'tree>),
        AndAnd(symbols::AndAnd<'tree>),
        Mul(symbols::Mul<'tree>),
        Add(symbols::Add<'tree>),
        Sub(symbols::Sub<'tree>),
        Div(symbols::Div<'tree>),
        Lt(symbols::Lt<'tree>),
        LtLt(symbols::LtLt<'tree>),
        LtEq(symbols::LtEq<'tree>),
        EqEq(symbols::EqEq<'tree>),
        Gt(symbols::Gt<'tree>),
        GtEq(symbols::GtEq<'tree>),
        GtGt(symbols::GtGt<'tree>),
        BitXor(symbols::BitXor<'tree>),
        Or(symbols::Or<'tree>),
        OrOr(symbols::OrOr<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
        'tree,
    > {
        ///Returns the node if it is of type `!=` ([`symbols::NotEq`]), otherwise returns `None`
        #[inline]
        pub fn as_not_eq(self) -> ::std::option::Option<symbols::NotEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::NotEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `%` ([`symbols::Mod`]), otherwise returns `None`
        #[inline]
        pub fn as_mod(self) -> ::std::option::Option<symbols::Mod<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mod(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `&` ([`symbols::And`]), otherwise returns `None`
        #[inline]
        pub fn as_and(self) -> ::std::option::Option<symbols::And<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::And(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `&&` ([`symbols::AndAnd`]), otherwise returns `None`
        #[inline]
        pub fn as_and_and(self) -> ::std::option::Option<symbols::AndAnd<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AndAnd(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `*` ([`symbols::Mul`]), otherwise returns `None`
        #[inline]
        pub fn as_mul(self) -> ::std::option::Option<symbols::Mul<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mul(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `+` ([`symbols::Add`]), otherwise returns `None`
        #[inline]
        pub fn as_add(self) -> ::std::option::Option<symbols::Add<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Add(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `-` ([`symbols::Sub`]), otherwise returns `None`
        #[inline]
        pub fn as_sub(self) -> ::std::option::Option<symbols::Sub<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Sub(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `/` ([`symbols::Div`]), otherwise returns `None`
        #[inline]
        pub fn as_div(self) -> ::std::option::Option<symbols::Div<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Div(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<` ([`symbols::Lt`]), otherwise returns `None`
        #[inline]
        pub fn as_lt(self) -> ::std::option::Option<symbols::Lt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<<` ([`symbols::LtLt`]), otherwise returns `None`
        #[inline]
        pub fn as_lt_lt(self) -> ::std::option::Option<symbols::LtLt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtLt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<=` ([`symbols::LtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_lt_eq(self) -> ::std::option::Option<symbols::LtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `==` ([`symbols::EqEq`]), otherwise returns `None`
        #[inline]
        pub fn as_eq_eq(self) -> ::std::option::Option<symbols::EqEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EqEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>` ([`symbols::Gt`]), otherwise returns `None`
        #[inline]
        pub fn as_gt(self) -> ::std::option::Option<symbols::Gt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Gt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>=` ([`symbols::GtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_gt_eq(self) -> ::std::option::Option<symbols::GtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>>` ([`symbols::GtGt`]), otherwise returns `None`
        #[inline]
        pub fn as_gt_gt(self) -> ::std::option::Option<symbols::GtGt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtGt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `^` ([`symbols::BitXor`]), otherwise returns `None`
        #[inline]
        pub fn as_bit_xor(self) -> ::std::option::Option<symbols::BitXor<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitXor(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `|` ([`symbols::Or`]), otherwise returns `None`
        #[inline]
        pub fn as_or(self) -> ::std::option::Option<symbols::Or<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Or(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `||` ([`symbols::OrOr`]), otherwise returns `None`
        #[inline]
        pub fn as_or_or(self) -> ::std::option::Option<symbols::OrOr<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrOr(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
        'tree,
    > {
        type WithLifetime<'a> = NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
            'a,
        >;
        const KIND: &'static str = "{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "!=" => {
                    Ok(unsafe {
                        Self::NotEq(
                            <symbols::NotEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "%" => {
                    Ok(unsafe {
                        Self::Mod(
                            <symbols::Mod<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "&" => {
                    Ok(unsafe {
                        Self::And(
                            <symbols::And<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "&&" => {
                    Ok(unsafe {
                        Self::AndAnd(
                            <symbols::AndAnd<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "*" => {
                    Ok(unsafe {
                        Self::Mul(
                            <symbols::Mul<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "+" => {
                    Ok(unsafe {
                        Self::Add(
                            <symbols::Add<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "-" => {
                    Ok(unsafe {
                        Self::Sub(
                            <symbols::Sub<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "/" => {
                    Ok(unsafe {
                        Self::Div(
                            <symbols::Div<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "<" => {
                    Ok(unsafe {
                        Self::Lt(
                            <symbols::Lt<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "<<" => {
                    Ok(unsafe {
                        Self::LtLt(
                            <symbols::LtLt<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "<=" => {
                    Ok(unsafe {
                        Self::LtEq(
                            <symbols::LtEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "==" => {
                    Ok(unsafe {
                        Self::EqEq(
                            <symbols::EqEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                ">" => {
                    Ok(unsafe {
                        Self::Gt(
                            <symbols::Gt<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                ">=" => {
                    Ok(unsafe {
                        Self::GtEq(
                            <symbols::GtEq<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                ">>" => {
                    Ok(unsafe {
                        Self::GtGt(
                            <symbols::GtGt<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "^" => {
                    Ok(unsafe {
                        Self::BitXor(
                            <symbols::BitXor<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "|" => {
                    Ok(unsafe {
                        Self::Or(
                            <symbols::Or<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "||" => {
                    Ok(unsafe {
                        Self::OrOr(
                            <symbols::OrOr<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::NotEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::Mod(x) => ::type_sitter_lib::Node::raw(x),
                Self::And(x) => ::type_sitter_lib::Node::raw(x),
                Self::AndAnd(x) => ::type_sitter_lib::Node::raw(x),
                Self::Mul(x) => ::type_sitter_lib::Node::raw(x),
                Self::Add(x) => ::type_sitter_lib::Node::raw(x),
                Self::Sub(x) => ::type_sitter_lib::Node::raw(x),
                Self::Div(x) => ::type_sitter_lib::Node::raw(x),
                Self::Lt(x) => ::type_sitter_lib::Node::raw(x),
                Self::LtLt(x) => ::type_sitter_lib::Node::raw(x),
                Self::LtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::EqEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::Gt(x) => ::type_sitter_lib::Node::raw(x),
                Self::GtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::GtGt(x) => ::type_sitter_lib::Node::raw(x),
                Self::BitXor(x) => ::type_sitter_lib::Node::raw(x),
                Self::Or(x) => ::type_sitter_lib::Node::raw(x),
                Self::OrOr(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::NotEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Mod(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::And(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AndAnd(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Mul(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Add(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Sub(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Div(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Lt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LtLt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::EqEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Gt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GtGt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BitXor(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Or(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::OrOr(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::NotEq(x) => x.into_raw(),
                Self::Mod(x) => x.into_raw(),
                Self::And(x) => x.into_raw(),
                Self::AndAnd(x) => x.into_raw(),
                Self::Mul(x) => x.into_raw(),
                Self::Add(x) => x.into_raw(),
                Self::Sub(x) => x.into_raw(),
                Self::Div(x) => x.into_raw(),
                Self::Lt(x) => x.into_raw(),
                Self::LtLt(x) => x.into_raw(),
                Self::LtEq(x) => x.into_raw(),
                Self::EqEq(x) => x.into_raw(),
                Self::Gt(x) => x.into_raw(),
                Self::GtEq(x) => x.into_raw(),
                Self::GtGt(x) => x.into_raw(),
                Self::BitXor(x) => x.into_raw(),
                Self::Or(x) => x.into_raw(),
                Self::OrOr(x) => x.into_raw(),
            }
        }
    }
    /**One of `{! | + | - | ~}`:
- [`symbols::Not`]
- [`symbols::Add`]
- [`symbols::Sub`]
- [`symbols::BitNot`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Not_Add_Sub_BitNot<'tree> {
        Not(symbols::Not<'tree>),
        Add(symbols::Add<'tree>),
        Sub(symbols::Sub<'tree>),
        BitNot(symbols::BitNot<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Not_Add_Sub_BitNot<'tree> {
        ///Returns the node if it is of type `!` ([`symbols::Not`]), otherwise returns `None`
        #[inline]
        pub fn as_not(self) -> ::std::option::Option<symbols::Not<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Not(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `+` ([`symbols::Add`]), otherwise returns `None`
        #[inline]
        pub fn as_add(self) -> ::std::option::Option<symbols::Add<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Add(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `-` ([`symbols::Sub`]), otherwise returns `None`
        #[inline]
        pub fn as_sub(self) -> ::std::option::Option<symbols::Sub<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Sub(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `~` ([`symbols::BitNot`]), otherwise returns `None`
        #[inline]
        pub fn as_bit_not(self) -> ::std::option::Option<symbols::BitNot<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitNot(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Not_Add_Sub_BitNot<'tree> {
        type WithLifetime<'a> = Not_Add_Sub_BitNot<'a>;
        const KIND: &'static str = "{! | + | - | ~}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "!" => {
                    Ok(unsafe {
                        Self::Not(
                            <symbols::Not<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "+" => {
                    Ok(unsafe {
                        Self::Add(
                            <symbols::Add<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "-" => {
                    Ok(unsafe {
                        Self::Sub(
                            <symbols::Sub<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "~" => {
                    Ok(unsafe {
                        Self::BitNot(
                            <symbols::BitNot<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Not(x) => ::type_sitter_lib::Node::raw(x),
                Self::Add(x) => ::type_sitter_lib::Node::raw(x),
                Self::Sub(x) => ::type_sitter_lib::Node::raw(x),
                Self::BitNot(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Not(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Add(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Sub(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BitNot(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Not(x) => x.into_raw(),
                Self::Add(x) => x.into_raw(),
                Self::Sub(x) => x.into_raw(),
                Self::BitNot(x) => x.into_raw(),
            }
        }
    }
    /**One of `{preproc_elif | preproc_elifdef | preproc_else}`:
- [`PreprocElif`]
- [`PreprocElifdef`]
- [`PreprocElse`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PreprocElif_PreprocElifdef_PreprocElse<'tree> {
        PreprocElif(PreprocElif<'tree>),
        PreprocElifdef(PreprocElifdef<'tree>),
        PreprocElse(PreprocElse<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> PreprocElif_PreprocElifdef_PreprocElse<'tree> {
        ///Returns the node if it is of type `preproc_elif` ([`PreprocElif`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_elif(self) -> ::std::option::Option<PreprocElif<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocElif(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_elifdef` ([`PreprocElifdef`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_elifdef(self) -> ::std::option::Option<PreprocElifdef<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocElifdef(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `preproc_else` ([`PreprocElse`]), otherwise returns `None`
        #[inline]
        pub fn as_preproc_else(self) -> ::std::option::Option<PreprocElse<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PreprocElse(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for PreprocElif_PreprocElifdef_PreprocElse<'tree> {
        type WithLifetime<'a> = PreprocElif_PreprocElifdef_PreprocElse<'a>;
        const KIND: &'static str = "{preproc_elif | preproc_elifdef | preproc_else}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "preproc_elif" => {
                    Ok(unsafe {
                        Self::PreprocElif(
                            <PreprocElif<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_elifdef" => {
                    Ok(unsafe {
                        Self::PreprocElifdef(
                            <PreprocElifdef<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "preproc_else" => {
                    Ok(unsafe {
                        Self::PreprocElse(
                            <PreprocElse<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::PreprocElif(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocElifdef(x) => ::type_sitter_lib::Node::raw(x),
                Self::PreprocElse(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::PreprocElif(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocElifdef(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PreprocElse(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::PreprocElif(x) => x.into_raw(),
                Self::PreprocElifdef(x) => x.into_raw(),
                Self::PreprocElse(x) => x.into_raw(),
            }
        }
    }
    /**One of `{primitive_type | type_identifier}`:
- [`PrimitiveType`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum PrimitiveType_TypeIdentifier<'tree> {
        PrimitiveType(PrimitiveType<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> PrimitiveType_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PrimitiveType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for PrimitiveType_TypeIdentifier<'tree> {
        type WithLifetime<'a> = PrimitiveType_TypeIdentifier<'a>;
        const KIND: &'static str = "{primitive_type | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "primitive_type" => {
                    Ok(unsafe {
                        Self::PrimitiveType(
                            <PrimitiveType<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "type_identifier" => {
                    Ok(unsafe {
                        Self::TypeIdentifier(
                            <TypeIdentifier<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::PrimitiveType(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{seh_except_clause | seh_finally_clause}`:
- [`SehExceptClause`]
- [`SehFinallyClause`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum SehExceptClause_SehFinallyClause<'tree> {
        SehExceptClause(SehExceptClause<'tree>),
        SehFinallyClause(SehFinallyClause<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SehExceptClause_SehFinallyClause<'tree> {
        ///Returns the node if it is of type `seh_except_clause` ([`SehExceptClause`]), otherwise returns `None`
        #[inline]
        pub fn as_seh_except_clause(
            self,
        ) -> ::std::option::Option<SehExceptClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SehExceptClause(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `seh_finally_clause` ([`SehFinallyClause`]), otherwise returns `None`
        #[inline]
        pub fn as_seh_finally_clause(
            self,
        ) -> ::std::option::Option<SehFinallyClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SehFinallyClause(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Get the field `body`.

This child has type `compound_statement` ([`CompoundStatement`])*/
        #[inline]
        pub fn body(
            &self,
        ) -> ::type_sitter_lib::NodeResult<'tree, CompoundStatement<'tree>> {
            ::type_sitter_lib::Node::raw(self)
                .child_by_field_name("body")
                .map(
                    <CompoundStatement<
                        'tree,
                    > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
                )
                .expect(
                    "required child not present, there should at least be a MISSING node in its place",
                )
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for SehExceptClause_SehFinallyClause<'tree> {
        type WithLifetime<'a> = SehExceptClause_SehFinallyClause<'a>;
        const KIND: &'static str = "{seh_except_clause | seh_finally_clause}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "seh_except_clause" => {
                    Ok(unsafe {
                        Self::SehExceptClause(
                            <SehExceptClause<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "seh_finally_clause" => {
                    Ok(unsafe {
                        Self::SehFinallyClause(
                            <SehFinallyClause<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::SehExceptClause(x) => ::type_sitter_lib::Node::raw(x),
                Self::SehFinallyClause(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::SehExceptClause(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SehFinallyClause(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::SehExceptClause(x) => x.into_raw(),
                Self::SehFinallyClause(x) => x.into_raw(),
            }
        }
    }
    /**One of `{-> | .}`:
- [`symbols::SubGt`]
- [`symbols::Dot`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum SubGt_Dot<'tree> {
        SubGt(symbols::SubGt<'tree>),
        Dot(symbols::Dot<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubGt_Dot<'tree> {
        ///Returns the node if it is of type `->` ([`symbols::SubGt`]), otherwise returns `None`
        #[inline]
        pub fn as_sub_gt(self) -> ::std::option::Option<symbols::SubGt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubGt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `.` ([`symbols::Dot`]), otherwise returns `None`
        #[inline]
        pub fn as_dot(self) -> ::std::option::Option<symbols::Dot<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Dot(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for SubGt_Dot<'tree> {
        type WithLifetime<'a> = SubGt_Dot<'a>;
        const KIND: &'static str = "{-> | .}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            match node.kind() {
                "->" => {
                    Ok(unsafe {
                        Self::SubGt(
                            <symbols::SubGt<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                "." => {
                    Ok(unsafe {
                        Self::Dot(
                            <symbols::Dot<
                                'tree,
                            > as ::type_sitter_lib::Node<
                                'tree,
                            >>::from_raw_unchecked(node),
                        )
                    })
                }
                _ => Err(::type_sitter_lib::IncorrectKind::new::<Self>(node)),
            }
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::SubGt(x) => ::type_sitter_lib::Node::raw(x),
                Self::Dot(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::SubGt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Dot(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::SubGt(x) => x.into_raw(),
                Self::Dot(x) => x.into_raw(),
            }
        }
    }
}
