/**Typed node `_declaration_statement`

This node type has subtypes:

- `associated_type` ([`AssociatedType`])
- `attribute_item` ([`AttributeItem`])
- `const_item` ([`ConstItem`])
- `empty_statement` ([`EmptyStatement`])
- `enum_item` ([`EnumItem`])
- `extern_crate_declaration` ([`ExternCrateDeclaration`])
- `foreign_mod_item` ([`ForeignModItem`])
- `function_item` ([`FunctionItem`])
- `function_signature_item` ([`FunctionSignatureItem`])
- `impl_item` ([`ImplItem`])
- `inner_attribute_item` ([`InnerAttributeItem`])
- `let_declaration` ([`LetDeclaration`])
- `macro_definition` ([`MacroDefinition`])
- `macro_invocation` ([`MacroInvocation`])
- `mod_item` ([`ModItem`])
- `static_item` ([`StaticItem`])
- `struct_item` ([`StructItem`])
- `trait_item` ([`TraitItem`])
- `type_item` ([`TypeItem`])
- `union_item` ([`UnionItem`])
- `use_declaration` ([`UseDeclaration`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum DeclarationStatement<'tree> {
    AssociatedType(AssociatedType<'tree>),
    AttributeItem(AttributeItem<'tree>),
    ConstItem(ConstItem<'tree>),
    EmptyStatement(EmptyStatement<'tree>),
    EnumItem(EnumItem<'tree>),
    ExternCrateDeclaration(ExternCrateDeclaration<'tree>),
    ForeignModItem(ForeignModItem<'tree>),
    FunctionItem(FunctionItem<'tree>),
    FunctionSignatureItem(FunctionSignatureItem<'tree>),
    ImplItem(ImplItem<'tree>),
    InnerAttributeItem(InnerAttributeItem<'tree>),
    LetDeclaration(LetDeclaration<'tree>),
    MacroDefinition(MacroDefinition<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    ModItem(ModItem<'tree>),
    StaticItem(StaticItem<'tree>),
    StructItem(StructItem<'tree>),
    TraitItem(TraitItem<'tree>),
    TypeItem(TypeItem<'tree>),
    UnionItem(UnionItem<'tree>),
    UseDeclaration(UseDeclaration<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> DeclarationStatement<'tree> {
    ///Returns the node if it is of type `associated_type` ([`AssociatedType`]), otherwise returns `None`
    #[inline]
    pub fn as_associated_type(self) -> ::std::option::Option<AssociatedType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AssociatedType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
    #[inline]
    pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AttributeItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `const_item` ([`ConstItem`]), otherwise returns `None`
    #[inline]
    pub fn as_const_item(self) -> ::std::option::Option<ConstItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConstItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `empty_statement` ([`EmptyStatement`]), otherwise returns `None`
    #[inline]
    pub fn as_empty_statement(self) -> ::std::option::Option<EmptyStatement<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::EmptyStatement(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `enum_item` ([`EnumItem`]), otherwise returns `None`
    #[inline]
    pub fn as_enum_item(self) -> ::std::option::Option<EnumItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::EnumItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `extern_crate_declaration` ([`ExternCrateDeclaration`]), otherwise returns `None`
    #[inline]
    pub fn as_extern_crate_declaration(
        self,
    ) -> ::std::option::Option<ExternCrateDeclaration<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ExternCrateDeclaration(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `foreign_mod_item` ([`ForeignModItem`]), otherwise returns `None`
    #[inline]
    pub fn as_foreign_mod_item(self) -> ::std::option::Option<ForeignModItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ForeignModItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `function_item` ([`FunctionItem`]), otherwise returns `None`
    #[inline]
    pub fn as_function_item(self) -> ::std::option::Option<FunctionItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `function_signature_item` ([`FunctionSignatureItem`]), otherwise returns `None`
    #[inline]
    pub fn as_function_signature_item(
        self,
    ) -> ::std::option::Option<FunctionSignatureItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionSignatureItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `impl_item` ([`ImplItem`]), otherwise returns `None`
    #[inline]
    pub fn as_impl_item(self) -> ::std::option::Option<ImplItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ImplItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`
    #[inline]
    pub fn as_inner_attribute_item(
        self,
    ) -> ::std::option::Option<InnerAttributeItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::InnerAttributeItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `let_declaration` ([`LetDeclaration`]), otherwise returns `None`
    #[inline]
    pub fn as_let_declaration(self) -> ::std::option::Option<LetDeclaration<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::LetDeclaration(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `macro_definition` ([`MacroDefinition`]), otherwise returns `None`
    #[inline]
    pub fn as_macro_definition(self) -> ::std::option::Option<MacroDefinition<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroDefinition(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`
    #[inline]
    pub fn as_macro_invocation(self) -> ::std::option::Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `mod_item` ([`ModItem`]), otherwise returns `None`
    #[inline]
    pub fn as_mod_item(self) -> ::std::option::Option<ModItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ModItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `static_item` ([`StaticItem`]), otherwise returns `None`
    #[inline]
    pub fn as_static_item(self) -> ::std::option::Option<StaticItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StaticItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `struct_item` ([`StructItem`]), otherwise returns `None`
    #[inline]
    pub fn as_struct_item(self) -> ::std::option::Option<StructItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StructItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `trait_item` ([`TraitItem`]), otherwise returns `None`
    #[inline]
    pub fn as_trait_item(self) -> ::std::option::Option<TraitItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TraitItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `type_item` ([`TypeItem`]), otherwise returns `None`
    #[inline]
    pub fn as_type_item(self) -> ::std::option::Option<TypeItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `union_item` ([`UnionItem`]), otherwise returns `None`
    #[inline]
    pub fn as_union_item(self) -> ::std::option::Option<UnionItem<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnionItem(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `use_declaration` ([`UseDeclaration`]), otherwise returns `None`
    #[inline]
    pub fn as_use_declaration(self) -> ::std::option::Option<UseDeclaration<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UseDeclaration(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for DeclarationStatement<'tree> {
    type WithLifetime<'a> = DeclarationStatement<'a>;
    const KIND: &'static str = "_declaration_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if let Ok(this) = <AssociatedType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AssociatedType(this));
        }
        if let Ok(this) = <AttributeItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AttributeItem(this));
        }
        if let Ok(this) = <ConstItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ConstItem(this));
        }
        if let Ok(this) = <EmptyStatement<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::EmptyStatement(this));
        }
        if let Ok(this) = <EnumItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::EnumItem(this));
        }
        if let Ok(this) = <ExternCrateDeclaration<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ExternCrateDeclaration(this));
        }
        if let Ok(this) = <ForeignModItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ForeignModItem(this));
        }
        if let Ok(this) = <FunctionItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::FunctionItem(this));
        }
        if let Ok(this) = <FunctionSignatureItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::FunctionSignatureItem(this));
        }
        if let Ok(this) = <ImplItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ImplItem(this));
        }
        if let Ok(this) = <InnerAttributeItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::InnerAttributeItem(this));
        }
        if let Ok(this) = <LetDeclaration<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::LetDeclaration(this));
        }
        if let Ok(this) = <MacroDefinition<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MacroDefinition(this));
        }
        if let Ok(this) = <MacroInvocation<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MacroInvocation(this));
        }
        if let Ok(this) = <ModItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ModItem(this));
        }
        if let Ok(this) = <StaticItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::StaticItem(this));
        }
        if let Ok(this) = <StructItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::StructItem(this));
        }
        if let Ok(this) = <TraitItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TraitItem(this));
        }
        if let Ok(this) = <TypeItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TypeItem(this));
        }
        if let Ok(this) = <UnionItem<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnionItem(this));
        }
        if let Ok(this) = <UseDeclaration<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UseDeclaration(this));
        }
        Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::AssociatedType(x) => ::type_sitter_lib::Node::raw(x),
            Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::ConstItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::EmptyStatement(x) => ::type_sitter_lib::Node::raw(x),
            Self::EnumItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::ExternCrateDeclaration(x) => ::type_sitter_lib::Node::raw(x),
            Self::ForeignModItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::FunctionItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::FunctionSignatureItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::ImplItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::InnerAttributeItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::LetDeclaration(x) => ::type_sitter_lib::Node::raw(x),
            Self::MacroDefinition(x) => ::type_sitter_lib::Node::raw(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw(x),
            Self::ModItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::StaticItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::StructItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::TraitItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::TypeItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::UnionItem(x) => ::type_sitter_lib::Node::raw(x),
            Self::UseDeclaration(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::AssociatedType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ConstItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::EmptyStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::EnumItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ExternCrateDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ForeignModItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FunctionItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FunctionSignatureItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ImplItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::InnerAttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::LetDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MacroDefinition(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ModItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StaticItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StructItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TraitItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TypeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UnionItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UseDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::AssociatedType(x) => x.into_raw(),
            Self::AttributeItem(x) => x.into_raw(),
            Self::ConstItem(x) => x.into_raw(),
            Self::EmptyStatement(x) => x.into_raw(),
            Self::EnumItem(x) => x.into_raw(),
            Self::ExternCrateDeclaration(x) => x.into_raw(),
            Self::ForeignModItem(x) => x.into_raw(),
            Self::FunctionItem(x) => x.into_raw(),
            Self::FunctionSignatureItem(x) => x.into_raw(),
            Self::ImplItem(x) => x.into_raw(),
            Self::InnerAttributeItem(x) => x.into_raw(),
            Self::LetDeclaration(x) => x.into_raw(),
            Self::MacroDefinition(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::ModItem(x) => x.into_raw(),
            Self::StaticItem(x) => x.into_raw(),
            Self::StructItem(x) => x.into_raw(),
            Self::TraitItem(x) => x.into_raw(),
            Self::TypeItem(x) => x.into_raw(),
            Self::UnionItem(x) => x.into_raw(),
            Self::UseDeclaration(x) => x.into_raw(),
        }
    }
}
/**Typed node `_expression`

This node type has subtypes:

- `_literal` ([`Literal`])
- `array_expression` ([`ArrayExpression`])
- `assignment_expression` ([`AssignmentExpression`])
- `async_block` ([`AsyncBlock`])
- `await_expression` ([`AwaitExpression`])
- `binary_expression` ([`BinaryExpression`])
- `block` ([`Block`])
- `break_expression` ([`BreakExpression`])
- `call_expression` ([`CallExpression`])
- `closure_expression` ([`ClosureExpression`])
- `compound_assignment_expr` ([`CompoundAssignmentExpr`])
- `const_block` ([`ConstBlock`])
- `continue_expression` ([`ContinueExpression`])
- `field_expression` ([`FieldExpression`])
- `for_expression` ([`ForExpression`])
- `gen_block` ([`GenBlock`])
- `generic_function` ([`GenericFunction`])
- `identifier` ([`Identifier`])
- `if_expression` ([`IfExpression`])
- `index_expression` ([`IndexExpression`])
- `loop_expression` ([`LoopExpression`])
- `macro_invocation` ([`MacroInvocation`])
- `match_expression` ([`MatchExpression`])
- `metavariable` ([`Metavariable`])
- `parenthesized_expression` ([`ParenthesizedExpression`])
- `range_expression` ([`RangeExpression`])
- `reference_expression` ([`ReferenceExpression`])
- `return_expression` ([`ReturnExpression`])
- `scoped_identifier` ([`ScopedIdentifier`])
- `self` ([`Self_`])
- `struct_expression` ([`StructExpression`])
- `try_block` ([`TryBlock`])
- `try_expression` ([`TryExpression`])
- `tuple_expression` ([`TupleExpression`])
- `type_cast_expression` ([`TypeCastExpression`])
- `unary_expression` ([`UnaryExpression`])
- `unit_expression` ([`UnitExpression`])
- `unsafe_block` ([`UnsafeBlock`])
- `while_expression` ([`WhileExpression`])
- `yield_expression` ([`YieldExpression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Expression<'tree> {
    Literal(Literal<'tree>),
    ArrayExpression(ArrayExpression<'tree>),
    AssignmentExpression(AssignmentExpression<'tree>),
    AsyncBlock(AsyncBlock<'tree>),
    AwaitExpression(AwaitExpression<'tree>),
    BinaryExpression(BinaryExpression<'tree>),
    Block(Block<'tree>),
    BreakExpression(BreakExpression<'tree>),
    CallExpression(CallExpression<'tree>),
    ClosureExpression(ClosureExpression<'tree>),
    CompoundAssignmentExpr(CompoundAssignmentExpr<'tree>),
    ConstBlock(ConstBlock<'tree>),
    ContinueExpression(ContinueExpression<'tree>),
    FieldExpression(FieldExpression<'tree>),
    ForExpression(ForExpression<'tree>),
    GenBlock(GenBlock<'tree>),
    GenericFunction(GenericFunction<'tree>),
    Identifier(Identifier<'tree>),
    IfExpression(IfExpression<'tree>),
    IndexExpression(IndexExpression<'tree>),
    LoopExpression(LoopExpression<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    MatchExpression(MatchExpression<'tree>),
    Metavariable(Metavariable<'tree>),
    ParenthesizedExpression(ParenthesizedExpression<'tree>),
    RangeExpression(RangeExpression<'tree>),
    ReferenceExpression(ReferenceExpression<'tree>),
    ReturnExpression(ReturnExpression<'tree>),
    ScopedIdentifier(ScopedIdentifier<'tree>),
    Self_(Self_<'tree>),
    StructExpression(StructExpression<'tree>),
    TryBlock(TryBlock<'tree>),
    TryExpression(TryExpression<'tree>),
    TupleExpression(TupleExpression<'tree>),
    TypeCastExpression(TypeCastExpression<'tree>),
    UnaryExpression(UnaryExpression<'tree>),
    UnitExpression(UnitExpression<'tree>),
    UnsafeBlock(UnsafeBlock<'tree>),
    WhileExpression(WhileExpression<'tree>),
    YieldExpression(YieldExpression<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Expression<'tree> {
    ///Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`
    #[inline]
    pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Literal(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_array_expression(self) -> ::std::option::Option<ArrayExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ArrayExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_assignment_expression(
        self,
    ) -> ::std::option::Option<AssignmentExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AssignmentExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`
    #[inline]
    pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AsyncBlock(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_await_expression(self) -> ::std::option::Option<AwaitExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AwaitExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_binary_expression(self) -> ::std::option::Option<BinaryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BinaryExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`
    #[inline]
    pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Block(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_break_expression(self) -> ::std::option::Option<BreakExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BreakExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CallExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_closure_expression(
        self,
    ) -> ::std::option::Option<ClosureExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ClosureExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`
    #[inline]
    pub fn as_compound_assignment_expr(
        self,
    ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CompoundAssignmentExpr(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`
    #[inline]
    pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConstBlock(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_continue_expression(
        self,
    ) -> ::std::option::Option<ContinueExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ContinueExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_field_expression(self) -> ::std::option::Option<FieldExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FieldExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ForExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`
    #[inline]
    pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GenBlock(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`
    #[inline]
    pub fn as_generic_function(self) -> ::std::option::Option<GenericFunction<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GenericFunction(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
    #[inline]
    pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Identifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IfExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_index_expression(self) -> ::std::option::Option<IndexExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IndexExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::LoopExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`
    #[inline]
    pub fn as_macro_invocation(self) -> ::std::option::Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_match_expression(self) -> ::std::option::Option<MatchExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MatchExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
    #[inline]
    pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Metavariable(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_parenthesized_expression(
        self,
    ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ParenthesizedExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_range_expression(self) -> ::std::option::Option<RangeExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RangeExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_reference_expression(
        self,
    ) -> ::std::option::Option<ReferenceExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReferenceExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_return_expression(self) -> ::std::option::Option<ReturnExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReturnExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
    #[inline]
    pub fn as_scoped_identifier(self) -> ::std::option::Option<ScopedIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ScopedIdentifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
    #[inline]
    pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Self_(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_struct_expression(self) -> ::std::option::Option<StructExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StructExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`
    #[inline]
    pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TryBlock(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TryExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_tuple_expression(self) -> ::std::option::Option<TupleExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TupleExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_type_cast_expression(
        self,
    ) -> ::std::option::Option<TypeCastExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeCastExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_unary_expression(self) -> ::std::option::Option<UnaryExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnaryExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnitExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`
    #[inline]
    pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnsafeBlock(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_while_expression(self) -> ::std::option::Option<WhileExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::WhileExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`
    #[inline]
    pub fn as_yield_expression(self) -> ::std::option::Option<YieldExpression<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::YieldExpression(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
    #[inline]
    pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
        self.as_literal()?.as_boolean_literal()
    }
    /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
    #[inline]
    pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
        self.as_literal()?.as_char_literal()
    }
    /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
    #[inline]
    pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
        self.as_literal()?.as_float_literal()
    }
    /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
    #[inline]
    pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
        self.as_literal()?.as_integer_literal()
    }
    /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
    #[inline]
    pub fn as_raw_string_literal(
        self,
    ) -> ::std::option::Option<RawStringLiteral<'tree>> {
        self.as_literal()?.as_raw_string_literal()
    }
    /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
    #[inline]
    pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
        self.as_literal()?.as_string_literal()
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Expression<'tree> {
    type WithLifetime<'a> = Expression<'a>;
    const KIND: &'static str = "_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if let Ok(this) = <Literal<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Literal(this));
        }
        if let Ok(this) = <ArrayExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ArrayExpression(this));
        }
        if let Ok(this) = <AssignmentExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AssignmentExpression(this));
        }
        if let Ok(this) = <AsyncBlock<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AsyncBlock(this));
        }
        if let Ok(this) = <AwaitExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AwaitExpression(this));
        }
        if let Ok(this) = <BinaryExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::BinaryExpression(this));
        }
        if let Ok(this) = <Block<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Block(this));
        }
        if let Ok(this) = <BreakExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::BreakExpression(this));
        }
        if let Ok(this) = <CallExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::CallExpression(this));
        }
        if let Ok(this) = <ClosureExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ClosureExpression(this));
        }
        if let Ok(this) = <CompoundAssignmentExpr<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::CompoundAssignmentExpr(this));
        }
        if let Ok(this) = <ConstBlock<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ConstBlock(this));
        }
        if let Ok(this) = <ContinueExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ContinueExpression(this));
        }
        if let Ok(this) = <FieldExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::FieldExpression(this));
        }
        if let Ok(this) = <ForExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ForExpression(this));
        }
        if let Ok(this) = <GenBlock<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::GenBlock(this));
        }
        if let Ok(this) = <GenericFunction<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::GenericFunction(this));
        }
        if let Ok(this) = <Identifier<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Identifier(this));
        }
        if let Ok(this) = <IfExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::IfExpression(this));
        }
        if let Ok(this) = <IndexExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::IndexExpression(this));
        }
        if let Ok(this) = <LoopExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::LoopExpression(this));
        }
        if let Ok(this) = <MacroInvocation<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MacroInvocation(this));
        }
        if let Ok(this) = <MatchExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MatchExpression(this));
        }
        if let Ok(this) = <Metavariable<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Metavariable(this));
        }
        if let Ok(this) = <ParenthesizedExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ParenthesizedExpression(this));
        }
        if let Ok(this) = <RangeExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RangeExpression(this));
        }
        if let Ok(this) = <ReferenceExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ReferenceExpression(this));
        }
        if let Ok(this) = <ReturnExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ReturnExpression(this));
        }
        if let Ok(this) = <ScopedIdentifier<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ScopedIdentifier(this));
        }
        if let Ok(this) = <Self_<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Self_(this));
        }
        if let Ok(this) = <StructExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::StructExpression(this));
        }
        if let Ok(this) = <TryBlock<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TryBlock(this));
        }
        if let Ok(this) = <TryExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TryExpression(this));
        }
        if let Ok(this) = <TupleExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TupleExpression(this));
        }
        if let Ok(this) = <TypeCastExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TypeCastExpression(this));
        }
        if let Ok(this) = <UnaryExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnaryExpression(this));
        }
        if let Ok(this) = <UnitExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnitExpression(this));
        }
        if let Ok(this) = <UnsafeBlock<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnsafeBlock(this));
        }
        if let Ok(this) = <WhileExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::WhileExpression(this));
        }
        if let Ok(this) = <YieldExpression<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::YieldExpression(this));
        }
        Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::Literal(x) => ::type_sitter_lib::Node::raw(x),
            Self::ArrayExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::AssignmentExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::AsyncBlock(x) => ::type_sitter_lib::Node::raw(x),
            Self::AwaitExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::Block(x) => ::type_sitter_lib::Node::raw(x),
            Self::BreakExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::CallExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ClosureExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::CompoundAssignmentExpr(x) => ::type_sitter_lib::Node::raw(x),
            Self::ConstBlock(x) => ::type_sitter_lib::Node::raw(x),
            Self::ContinueExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::FieldExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ForExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::GenBlock(x) => ::type_sitter_lib::Node::raw(x),
            Self::GenericFunction(x) => ::type_sitter_lib::Node::raw(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::IfExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::IndexExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::LoopExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw(x),
            Self::MatchExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
            Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::RangeExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ReferenceExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ReturnExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
            Self::StructExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::TryBlock(x) => ::type_sitter_lib::Node::raw(x),
            Self::TryExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::TupleExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::TypeCastExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::UnitExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::UnsafeBlock(x) => ::type_sitter_lib::Node::raw(x),
            Self::WhileExpression(x) => ::type_sitter_lib::Node::raw(x),
            Self::YieldExpression(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::Literal(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ArrayExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AssignmentExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AsyncBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::AwaitExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Block(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::BreakExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CallExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ClosureExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CompoundAssignmentExpr(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ConstBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ContinueExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FieldExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ForExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::GenBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::GenericFunction(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::IfExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::IndexExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::LoopExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MatchExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::RangeExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ReferenceExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ReturnExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StructExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TryBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TupleExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TypeCastExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UnitExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UnsafeBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::WhileExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::YieldExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::Literal(x) => x.into_raw(),
            Self::ArrayExpression(x) => x.into_raw(),
            Self::AssignmentExpression(x) => x.into_raw(),
            Self::AsyncBlock(x) => x.into_raw(),
            Self::AwaitExpression(x) => x.into_raw(),
            Self::BinaryExpression(x) => x.into_raw(),
            Self::Block(x) => x.into_raw(),
            Self::BreakExpression(x) => x.into_raw(),
            Self::CallExpression(x) => x.into_raw(),
            Self::ClosureExpression(x) => x.into_raw(),
            Self::CompoundAssignmentExpr(x) => x.into_raw(),
            Self::ConstBlock(x) => x.into_raw(),
            Self::ContinueExpression(x) => x.into_raw(),
            Self::FieldExpression(x) => x.into_raw(),
            Self::ForExpression(x) => x.into_raw(),
            Self::GenBlock(x) => x.into_raw(),
            Self::GenericFunction(x) => x.into_raw(),
            Self::Identifier(x) => x.into_raw(),
            Self::IfExpression(x) => x.into_raw(),
            Self::IndexExpression(x) => x.into_raw(),
            Self::LoopExpression(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::MatchExpression(x) => x.into_raw(),
            Self::Metavariable(x) => x.into_raw(),
            Self::ParenthesizedExpression(x) => x.into_raw(),
            Self::RangeExpression(x) => x.into_raw(),
            Self::ReferenceExpression(x) => x.into_raw(),
            Self::ReturnExpression(x) => x.into_raw(),
            Self::ScopedIdentifier(x) => x.into_raw(),
            Self::Self_(x) => x.into_raw(),
            Self::StructExpression(x) => x.into_raw(),
            Self::TryBlock(x) => x.into_raw(),
            Self::TryExpression(x) => x.into_raw(),
            Self::TupleExpression(x) => x.into_raw(),
            Self::TypeCastExpression(x) => x.into_raw(),
            Self::UnaryExpression(x) => x.into_raw(),
            Self::UnitExpression(x) => x.into_raw(),
            Self::UnsafeBlock(x) => x.into_raw(),
            Self::WhileExpression(x) => x.into_raw(),
            Self::YieldExpression(x) => x.into_raw(),
        }
    }
}
/**Typed node `_literal`

This node type has subtypes:

- `boolean_literal` ([`BooleanLiteral`])
- `char_literal` ([`CharLiteral`])
- `float_literal` ([`FloatLiteral`])
- `integer_literal` ([`IntegerLiteral`])
- `raw_string_literal` ([`RawStringLiteral`])
- `string_literal` ([`StringLiteral`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Literal<'tree> {
    BooleanLiteral(BooleanLiteral<'tree>),
    CharLiteral(CharLiteral<'tree>),
    FloatLiteral(FloatLiteral<'tree>),
    IntegerLiteral(IntegerLiteral<'tree>),
    RawStringLiteral(RawStringLiteral<'tree>),
    StringLiteral(StringLiteral<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Literal<'tree> {
    ///Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BooleanLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CharLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FloatLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IntegerLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_raw_string_literal(
        self,
    ) -> ::std::option::Option<RawStringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RawStringLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StringLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Literal<'tree> {
    type WithLifetime<'a> = Literal<'a>;
    const KIND: &'static str = "_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if let Ok(this) = <BooleanLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::BooleanLiteral(this));
        }
        if let Ok(this) = <CharLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::CharLiteral(this));
        }
        if let Ok(this) = <FloatLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::FloatLiteral(this));
        }
        if let Ok(this) = <IntegerLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::IntegerLiteral(this));
        }
        if let Ok(this) = <RawStringLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RawStringLiteral(this));
        }
        if let Ok(this) = <StringLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::StringLiteral(this));
        }
        Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::CharLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::FloatLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::RawStringLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::StringLiteral(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CharLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FloatLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::RawStringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => x.into_raw(),
            Self::CharLiteral(x) => x.into_raw(),
            Self::FloatLiteral(x) => x.into_raw(),
            Self::IntegerLiteral(x) => x.into_raw(),
            Self::RawStringLiteral(x) => x.into_raw(),
            Self::StringLiteral(x) => x.into_raw(),
        }
    }
}
/**Typed node `_literal_pattern`

This node type has subtypes:

- `boolean_literal` ([`BooleanLiteral`])
- `char_literal` ([`CharLiteral`])
- `float_literal` ([`FloatLiteral`])
- `integer_literal` ([`IntegerLiteral`])
- `negative_literal` ([`NegativeLiteral`])
- `raw_string_literal` ([`RawStringLiteral`])
- `string_literal` ([`StringLiteral`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum LiteralPattern<'tree> {
    BooleanLiteral(BooleanLiteral<'tree>),
    CharLiteral(CharLiteral<'tree>),
    FloatLiteral(FloatLiteral<'tree>),
    IntegerLiteral(IntegerLiteral<'tree>),
    NegativeLiteral(NegativeLiteral<'tree>),
    RawStringLiteral(RawStringLiteral<'tree>),
    StringLiteral(StringLiteral<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> LiteralPattern<'tree> {
    ///Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BooleanLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CharLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FloatLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::IntegerLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_negative_literal(self) -> ::std::option::Option<NegativeLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::NegativeLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_raw_string_literal(
        self,
    ) -> ::std::option::Option<RawStringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RawStringLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`
    #[inline]
    pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StringLiteral(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LiteralPattern<'tree> {
    type WithLifetime<'a> = LiteralPattern<'a>;
    const KIND: &'static str = "_literal_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if let Ok(this) = <BooleanLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::BooleanLiteral(this));
        }
        if let Ok(this) = <CharLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::CharLiteral(this));
        }
        if let Ok(this) = <FloatLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::FloatLiteral(this));
        }
        if let Ok(this) = <IntegerLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::IntegerLiteral(this));
        }
        if let Ok(this) = <NegativeLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::NegativeLiteral(this));
        }
        if let Ok(this) = <RawStringLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RawStringLiteral(this));
        }
        if let Ok(this) = <StringLiteral<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::StringLiteral(this));
        }
        Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::CharLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::FloatLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::NegativeLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::RawStringLiteral(x) => ::type_sitter_lib::Node::raw(x),
            Self::StringLiteral(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CharLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FloatLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::NegativeLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::RawStringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StringLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::BooleanLiteral(x) => x.into_raw(),
            Self::CharLiteral(x) => x.into_raw(),
            Self::FloatLiteral(x) => x.into_raw(),
            Self::IntegerLiteral(x) => x.into_raw(),
            Self::NegativeLiteral(x) => x.into_raw(),
            Self::RawStringLiteral(x) => x.into_raw(),
            Self::StringLiteral(x) => x.into_raw(),
        }
    }
}
/**Typed node `_pattern`

This node type has subtypes:

- `_` ([`symbols::__`])
- `_literal_pattern` ([`LiteralPattern`])
- `captured_pattern` ([`CapturedPattern`])
- `const_block` ([`ConstBlock`])
- `identifier` ([`Identifier`])
- `macro_invocation` ([`MacroInvocation`])
- `mut_pattern` ([`MutPattern`])
- `or_pattern` ([`OrPattern`])
- `range_pattern` ([`RangePattern`])
- `ref_pattern` ([`RefPattern`])
- `reference_pattern` ([`ReferencePattern`])
- `remaining_field_pattern` ([`RemainingFieldPattern`])
- `scoped_identifier` ([`ScopedIdentifier`])
- `slice_pattern` ([`SlicePattern`])
- `struct_pattern` ([`StructPattern`])
- `tuple_pattern` ([`TuplePattern`])
- `tuple_struct_pattern` ([`TupleStructPattern`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Pattern<'tree> {
    __(symbols::__<'tree>),
    LiteralPattern(LiteralPattern<'tree>),
    CapturedPattern(CapturedPattern<'tree>),
    ConstBlock(ConstBlock<'tree>),
    Identifier(Identifier<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    MutPattern(MutPattern<'tree>),
    OrPattern(OrPattern<'tree>),
    RangePattern(RangePattern<'tree>),
    RefPattern(RefPattern<'tree>),
    ReferencePattern(ReferencePattern<'tree>),
    RemainingFieldPattern(RemainingFieldPattern<'tree>),
    ScopedIdentifier(ScopedIdentifier<'tree>),
    SlicePattern(SlicePattern<'tree>),
    StructPattern(StructPattern<'tree>),
    TuplePattern(TuplePattern<'tree>),
    TupleStructPattern(TupleStructPattern<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Pattern<'tree> {
    ///Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`
    #[inline]
    pub fn as___(self) -> ::std::option::Option<symbols::__<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::__(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_literal_pattern(self) -> ::std::option::Option<LiteralPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::LiteralPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_captured_pattern(self) -> ::std::option::Option<CapturedPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::CapturedPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`
    #[inline]
    pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ConstBlock(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
    #[inline]
    pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Identifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`
    #[inline]
    pub fn as_macro_invocation(self) -> ::std::option::Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_mut_pattern(self) -> ::std::option::Option<MutPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MutPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_or_pattern(self) -> ::std::option::Option<OrPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::OrPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`
    #[inline]
    pub fn as_range_pattern(self) -> ::std::option::Option<RangePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RangePattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_ref_pattern(self) -> ::std::option::Option<RefPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RefPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`
    #[inline]
    pub fn as_reference_pattern(self) -> ::std::option::Option<ReferencePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReferencePattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_remaining_field_pattern(
        self,
    ) -> ::std::option::Option<RemainingFieldPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RemainingFieldPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
    #[inline]
    pub fn as_scoped_identifier(self) -> ::std::option::Option<ScopedIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ScopedIdentifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`
    #[inline]
    pub fn as_slice_pattern(self) -> ::std::option::Option<SlicePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::SlicePattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_struct_pattern(self) -> ::std::option::Option<StructPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::StructPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`
    #[inline]
    pub fn as_tuple_pattern(self) -> ::std::option::Option<TuplePattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TuplePattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`
    #[inline]
    pub fn as_tuple_struct_pattern(
        self,
    ) -> ::std::option::Option<TupleStructPattern<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TupleStructPattern(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
    #[inline]
    pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
        self.as_literal_pattern()?.as_boolean_literal()
    }
    /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
    #[inline]
    pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
        self.as_literal_pattern()?.as_char_literal()
    }
    /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
    #[inline]
    pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
        self.as_literal_pattern()?.as_float_literal()
    }
    /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
    #[inline]
    pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
        self.as_literal_pattern()?.as_integer_literal()
    }
    /**Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
    #[inline]
    pub fn as_negative_literal(self) -> ::std::option::Option<NegativeLiteral<'tree>> {
        self.as_literal_pattern()?.as_negative_literal()
    }
    /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
    #[inline]
    pub fn as_raw_string_literal(
        self,
    ) -> ::std::option::Option<RawStringLiteral<'tree>> {
        self.as_literal_pattern()?.as_raw_string_literal()
    }
    /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
    #[inline]
    pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
        self.as_literal_pattern()?.as_string_literal()
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Pattern<'tree> {
    type WithLifetime<'a> = Pattern<'a>;
    const KIND: &'static str = "_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if let Ok(this) = <symbols::__<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::__(this));
        }
        if let Ok(this) = <LiteralPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::LiteralPattern(this));
        }
        if let Ok(this) = <CapturedPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::CapturedPattern(this));
        }
        if let Ok(this) = <ConstBlock<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ConstBlock(this));
        }
        if let Ok(this) = <Identifier<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Identifier(this));
        }
        if let Ok(this) = <MacroInvocation<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MacroInvocation(this));
        }
        if let Ok(this) = <MutPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MutPattern(this));
        }
        if let Ok(this) = <OrPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::OrPattern(this));
        }
        if let Ok(this) = <RangePattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RangePattern(this));
        }
        if let Ok(this) = <RefPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RefPattern(this));
        }
        if let Ok(this) = <ReferencePattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ReferencePattern(this));
        }
        if let Ok(this) = <RemainingFieldPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RemainingFieldPattern(this));
        }
        if let Ok(this) = <ScopedIdentifier<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ScopedIdentifier(this));
        }
        if let Ok(this) = <SlicePattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::SlicePattern(this));
        }
        if let Ok(this) = <StructPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::StructPattern(this));
        }
        if let Ok(this) = <TuplePattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TuplePattern(this));
        }
        if let Ok(this) = <TupleStructPattern<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TupleStructPattern(this));
        }
        Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::__(x) => ::type_sitter_lib::Node::raw(x),
            Self::LiteralPattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::CapturedPattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::ConstBlock(x) => ::type_sitter_lib::Node::raw(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw(x),
            Self::MutPattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::OrPattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::RangePattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::RefPattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::ReferencePattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::RemainingFieldPattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::SlicePattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::StructPattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::TuplePattern(x) => ::type_sitter_lib::Node::raw(x),
            Self::TupleStructPattern(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::__(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::LiteralPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::CapturedPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ConstBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MutPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::OrPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::RangePattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::RefPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ReferencePattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::RemainingFieldPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::SlicePattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::StructPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TuplePattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TupleStructPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::__(x) => x.into_raw(),
            Self::LiteralPattern(x) => x.into_raw(),
            Self::CapturedPattern(x) => x.into_raw(),
            Self::ConstBlock(x) => x.into_raw(),
            Self::Identifier(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::MutPattern(x) => x.into_raw(),
            Self::OrPattern(x) => x.into_raw(),
            Self::RangePattern(x) => x.into_raw(),
            Self::RefPattern(x) => x.into_raw(),
            Self::ReferencePattern(x) => x.into_raw(),
            Self::RemainingFieldPattern(x) => x.into_raw(),
            Self::ScopedIdentifier(x) => x.into_raw(),
            Self::SlicePattern(x) => x.into_raw(),
            Self::StructPattern(x) => x.into_raw(),
            Self::TuplePattern(x) => x.into_raw(),
            Self::TupleStructPattern(x) => x.into_raw(),
        }
    }
}
/**Typed node `_type`

This node type has subtypes:

- `abstract_type` ([`AbstractType`])
- `array_type` ([`ArrayType`])
- `bounded_type` ([`BoundedType`])
- `dynamic_type` ([`DynamicType`])
- `function_type` ([`FunctionType`])
- `generic_type` ([`GenericType`])
- `macro_invocation` ([`MacroInvocation`])
- `metavariable` ([`Metavariable`])
- `never_type` ([`NeverType`])
- `pointer_type` ([`PointerType`])
- `primitive_type` ([`PrimitiveType`])
- `reference_type` ([`ReferenceType`])
- `removed_trait_bound` ([`RemovedTraitBound`])
- `scoped_type_identifier` ([`ScopedTypeIdentifier`])
- `tuple_type` ([`TupleType`])
- `type_identifier` ([`TypeIdentifier`])
- `unit_type` ([`UnitType`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum Type<'tree> {
    AbstractType(AbstractType<'tree>),
    ArrayType(ArrayType<'tree>),
    BoundedType(BoundedType<'tree>),
    DynamicType(DynamicType<'tree>),
    FunctionType(FunctionType<'tree>),
    GenericType(GenericType<'tree>),
    MacroInvocation(MacroInvocation<'tree>),
    Metavariable(Metavariable<'tree>),
    NeverType(NeverType<'tree>),
    PointerType(PointerType<'tree>),
    PrimitiveType(PrimitiveType<'tree>),
    ReferenceType(ReferenceType<'tree>),
    RemovedTraitBound(RemovedTraitBound<'tree>),
    ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
    TupleType(TupleType<'tree>),
    TypeIdentifier(TypeIdentifier<'tree>),
    UnitType(UnitType<'tree>),
}
#[automatically_derived]
#[allow(unused)]
impl<'tree> Type<'tree> {
    ///Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`
    #[inline]
    pub fn as_abstract_type(self) -> ::std::option::Option<AbstractType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::AbstractType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`
    #[inline]
    pub fn as_array_type(self) -> ::std::option::Option<ArrayType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ArrayType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`
    #[inline]
    pub fn as_bounded_type(self) -> ::std::option::Option<BoundedType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::BoundedType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`
    #[inline]
    pub fn as_dynamic_type(self) -> ::std::option::Option<DynamicType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::DynamicType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`
    #[inline]
    pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::FunctionType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`
    #[inline]
    pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::GenericType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`
    #[inline]
    pub fn as_macro_invocation(self) -> ::std::option::Option<MacroInvocation<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::MacroInvocation(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
    #[inline]
    pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::Metavariable(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`
    #[inline]
    pub fn as_never_type(self) -> ::std::option::Option<NeverType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::NeverType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`
    #[inline]
    pub fn as_pointer_type(self) -> ::std::option::Option<PointerType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PointerType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`
    #[inline]
    pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::PrimitiveType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`
    #[inline]
    pub fn as_reference_type(self) -> ::std::option::Option<ReferenceType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ReferenceType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`
    #[inline]
    pub fn as_removed_trait_bound(
        self,
    ) -> ::std::option::Option<RemovedTraitBound<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::RemovedTraitBound(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
    #[inline]
    pub fn as_scoped_type_identifier(
        self,
    ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::ScopedTypeIdentifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`
    #[inline]
    pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TupleType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
    #[inline]
    pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::TypeIdentifier(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
    ///Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`
    #[inline]
    pub fn as_unit_type(self) -> ::std::option::Option<UnitType<'tree>> {
        #[allow(irrefutable_let_patterns)]
        if let Self::UnitType(x) = self {
            ::std::option::Option::Some(x)
        } else {
            ::std::option::Option::None
        }
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Type<'tree> {
    type WithLifetime<'a> = Type<'a>;
    const KIND: &'static str = "_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if let Ok(this) = <AbstractType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::AbstractType(this));
        }
        if let Ok(this) = <ArrayType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ArrayType(this));
        }
        if let Ok(this) = <BoundedType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::BoundedType(this));
        }
        if let Ok(this) = <DynamicType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::DynamicType(this));
        }
        if let Ok(this) = <FunctionType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::FunctionType(this));
        }
        if let Ok(this) = <GenericType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::GenericType(this));
        }
        if let Ok(this) = <MacroInvocation<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::MacroInvocation(this));
        }
        if let Ok(this) = <Metavariable<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::Metavariable(this));
        }
        if let Ok(this) = <NeverType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::NeverType(this));
        }
        if let Ok(this) = <PointerType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::PointerType(this));
        }
        if let Ok(this) = <PrimitiveType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::PrimitiveType(this));
        }
        if let Ok(this) = <ReferenceType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ReferenceType(this));
        }
        if let Ok(this) = <RemovedTraitBound<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::RemovedTraitBound(this));
        }
        if let Ok(this) = <ScopedTypeIdentifier<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::ScopedTypeIdentifier(this));
        }
        if let Ok(this) = <TupleType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TupleType(this));
        }
        if let Ok(this) = <TypeIdentifier<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::TypeIdentifier(this));
        }
        if let Ok(this) = <UnitType<
            'tree,
        > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
            return Ok(Self::UnitType(this));
        }
        Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        match self {
            Self::AbstractType(x) => ::type_sitter_lib::Node::raw(x),
            Self::ArrayType(x) => ::type_sitter_lib::Node::raw(x),
            Self::BoundedType(x) => ::type_sitter_lib::Node::raw(x),
            Self::DynamicType(x) => ::type_sitter_lib::Node::raw(x),
            Self::FunctionType(x) => ::type_sitter_lib::Node::raw(x),
            Self::GenericType(x) => ::type_sitter_lib::Node::raw(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw(x),
            Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
            Self::NeverType(x) => ::type_sitter_lib::Node::raw(x),
            Self::PointerType(x) => ::type_sitter_lib::Node::raw(x),
            Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw(x),
            Self::ReferenceType(x) => ::type_sitter_lib::Node::raw(x),
            Self::RemovedTraitBound(x) => ::type_sitter_lib::Node::raw(x),
            Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::TupleType(x) => ::type_sitter_lib::Node::raw(x),
            Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            Self::UnitType(x) => ::type_sitter_lib::Node::raw(x),
        }
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        match self {
            Self::AbstractType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ArrayType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::BoundedType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::DynamicType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::FunctionType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::GenericType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::NeverType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PointerType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ReferenceType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::RemovedTraitBound(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TupleType(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            Self::UnitType(x) => ::type_sitter_lib::Node::raw_mut(x),
        }
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        match self {
            Self::AbstractType(x) => x.into_raw(),
            Self::ArrayType(x) => x.into_raw(),
            Self::BoundedType(x) => x.into_raw(),
            Self::DynamicType(x) => x.into_raw(),
            Self::FunctionType(x) => x.into_raw(),
            Self::GenericType(x) => x.into_raw(),
            Self::MacroInvocation(x) => x.into_raw(),
            Self::Metavariable(x) => x.into_raw(),
            Self::NeverType(x) => x.into_raw(),
            Self::PointerType(x) => x.into_raw(),
            Self::PrimitiveType(x) => x.into_raw(),
            Self::ReferenceType(x) => x.into_raw(),
            Self::RemovedTraitBound(x) => x.into_raw(),
            Self::ScopedTypeIdentifier(x) => x.into_raw(),
            Self::TupleType(x) => x.into_raw(),
            Self::TypeIdentifier(x) => x.into_raw(),
            Self::UnitType(x) => x.into_raw(),
        }
    }
}
/**Typed node `abstract_type`

This node has these fields:

- `trait`: `{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}` ([`FunctionType`] | [`GenericType`] | [`RemovedTraitBound`] | [`ScopedTypeIdentifier`] | [`TupleType`] | [`TypeIdentifier`])

And an optional additional named child of type `type_parameters?` ([`TypeParameters`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AbstractType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AbstractType<'tree> {
    /**Get the field `trait`.

This child has type `{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}`:

- [`FunctionType`]
- [`GenericType`]
- [`RemovedTraitBound`]
- [`ScopedTypeIdentifier`]
- [`TupleType`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#trait(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("trait")
            .map(
                <anon_unions::FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AbstractType<'tree> {
    type WithLifetime<'a> = AbstractType<'a>;
    const KIND: &'static str = "abstract_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "abstract_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "abstract_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `arguments`

This node has named children of type `{_expression | attribute_item}*`:

- [`Expression`]
- [`AttributeItem`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Arguments<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Arguments<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for Arguments<'tree> {
    type Child = anon_unions::Expression_AttributeItem<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Arguments<'tree> {
    type WithLifetime<'a> = Arguments<'a>;
    const KIND: &'static str = "arguments";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "arguments" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "arguments");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `array_expression`

This node has these fields:

- `length`: `_expression?` ([`Expression`])

And additional named children of type `{_expression | attribute_item}*`:

- [`Expression`]
- [`AttributeItem`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ArrayExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ArrayExpression<'tree> {
    /**Get the optional field `length`.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn length(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("length")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{_expression | attribute_item}*`:

- [`Expression`]
- [`AttributeItem`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Expression_AttributeItem<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::Expression_AttributeItem<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ArrayExpression<'tree> {
    type WithLifetime<'a> = ArrayExpression<'a>;
    const KIND: &'static str = "array_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "array_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "array_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `array_type`

This node has these fields:

- `element`: `_type` ([`Type`])
- `length`: `_expression?` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ArrayType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ArrayType<'tree> {
    /**Get the field `element`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn element(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("element")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `length`.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn length(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("length")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ArrayType<'tree> {
    type WithLifetime<'a> = ArrayType<'a>;
    const KIND: &'static str = "array_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "array_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "array_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `assignment_expression`

This node has these fields:

- `left`: `_expression` ([`Expression`])
- `right`: `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AssignmentExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AssignmentExpression<'tree> {
    /**Get the field `left`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn left(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `right`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn right(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("right")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AssignmentExpression<'tree> {
    type WithLifetime<'a> = AssignmentExpression<'a>;
    const KIND: &'static str = "assignment_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "assignment_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "assignment_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `associated_type`

This node has these fields:

- `bounds`: `trait_bounds?` ([`TraitBounds`])
- `name`: `type_identifier` ([`TypeIdentifier`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And an optional additional named child of type `where_clause?` ([`WhereClause`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AssociatedType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AssociatedType<'tree> {
    /**Get the optional field `bounds`.

This child has type `trait_bounds?` ([`TraitBounds`])*/
    #[inline]
    pub fn bounds(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TraitBounds<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `where_clause?` ([`WhereClause`])*/
    #[inline]
    pub fn where_clause(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, WhereClause<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<WhereClause<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AssociatedType<'tree> {
    type WithLifetime<'a> = AssociatedType<'a>;
    const KIND: &'static str = "associated_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "associated_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "associated_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `async_block`

This node has a named child of type `block` ([`Block`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AsyncBlock<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AsyncBlock<'tree> {
    /**Get the node's only not-extra named child.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn block(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for AsyncBlock<'tree> {
    type Child = Block<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AsyncBlock<'tree> {
    type WithLifetime<'a> = AsyncBlock<'a>;
    const KIND: &'static str = "async_block";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "async_block" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "async_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `attribute`

This node has these fields:

- `arguments`: `token_tree?` ([`TokenTree`])
- `value`: `_expression?` ([`Expression`])

And an additional named child of type `{crate | identifier | metavariable | scoped_identifier | self | super}`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Attribute<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Attribute<'tree> {
    /**Get the optional field `arguments`.

This child has type `token_tree?` ([`TokenTree`])*/
    #[inline]
    pub fn arguments(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, TokenTree<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("arguments")
            .map(<TokenTree<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `value`.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child.

This child has type `{crate | identifier | metavariable | scoped_identifier | self | super}`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]
*/
    #[inline]
    pub fn other(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Attribute<'tree> {
    type WithLifetime<'a> = Attribute<'a>;
    const KIND: &'static str = "attribute";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "attribute" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attribute");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `attribute_item`

This node has a named child of type `attribute` ([`Attribute`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AttributeItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AttributeItem<'tree> {
    /**Get the node's only not-extra named child.

This child has type `attribute` ([`Attribute`])*/
    #[inline]
    pub fn attribute(&self) -> ::type_sitter_lib::NodeResult<'tree, Attribute<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Attribute<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for AttributeItem<'tree> {
    type Child = Attribute<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AttributeItem<'tree> {
    type WithLifetime<'a> = AttributeItem<'a>;
    const KIND: &'static str = "attribute_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "attribute_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "attribute_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `await_expression`

This node has a named child of type `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct AwaitExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> AwaitExpression<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for AwaitExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for AwaitExpression<'tree> {
    type WithLifetime<'a> = AwaitExpression<'a>;
    const KIND: &'static str = "await_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "await_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "await_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `base_field_initializer`

This node has a named child of type `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BaseFieldInitializer<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BaseFieldInitializer<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for BaseFieldInitializer<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BaseFieldInitializer<'tree> {
    type WithLifetime<'a> = BaseFieldInitializer<'a>;
    const KIND: &'static str = "base_field_initializer";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "base_field_initializer" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "base_field_initializer");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `binary_expression`

This node has these fields:

- `left`: `_expression` ([`Expression`])
- `operator`: `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}` ([`symbols::NotEq`] | [`symbols::Mod`] | [`symbols::And`] | [`symbols::AndAnd`] | [`symbols::Mul`] | [`symbols::Add`] | [`symbols::Sub`] | [`symbols::Div`] | [`symbols::Lt`] | [`symbols::LtLt`] | [`symbols::LtEq`] | [`symbols::EqEq`] | [`symbols::Gt`] | [`symbols::GtEq`] | [`symbols::GtGt`] | [`symbols::BitXor`] | [`symbols::Or`] | [`symbols::OrOr`])
- `right`: `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BinaryExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BinaryExpression<'tree> {
    /**Get the field `left`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn left(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}`:

- [`symbols::NotEq`]
- [`symbols::Mod`]
- [`symbols::And`]
- [`symbols::AndAnd`]
- [`symbols::Mul`]
- [`symbols::Add`]
- [`symbols::Sub`]
- [`symbols::Div`]
- [`symbols::Lt`]
- [`symbols::LtLt`]
- [`symbols::LtEq`]
- [`symbols::EqEq`]
- [`symbols::Gt`]
- [`symbols::GtEq`]
- [`symbols::GtGt`]
- [`symbols::BitXor`]
- [`symbols::Or`]
- [`symbols::OrOr`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `right`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn right(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("right")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BinaryExpression<'tree> {
    type WithLifetime<'a> = BinaryExpression<'a>;
    const KIND: &'static str = "binary_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "binary_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "binary_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `block`

This node has named children of type `{_declaration_statement | _expression | expression_statement | label}*`:

- [`DeclarationStatement`]
- [`Expression`]
- [`ExpressionStatement`]
- [`Label`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Block<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Block<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for Block<'tree> {
    type Child = anon_unions::DeclarationStatement_Expression_ExpressionStatement_Label<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Block<'tree> {
    type WithLifetime<'a> = Block<'a>;
    const KIND: &'static str = "block";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "block" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `block_comment`

This node has these fields:

- `doc`: `doc_comment?` ([`DocComment`])
- `inner`: `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])
- `outer`: `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BlockComment<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BlockComment<'tree> {
    /**Get the optional field `doc`.

This child has type `doc_comment?` ([`DocComment`])*/
    #[inline]
    pub fn doc(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, DocComment<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("doc")
            .map(<DocComment<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `inner`.

This child has type `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])*/
    #[inline]
    pub fn inner(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, InnerDocCommentMarker<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("inner")
            .map(
                <InnerDocCommentMarker<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `outer`.

This child has type `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])*/
    #[inline]
    pub fn outer(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, OuterDocCommentMarker<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("outer")
            .map(
                <OuterDocCommentMarker<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BlockComment<'tree> {
    type WithLifetime<'a> = BlockComment<'a>;
    const KIND: &'static str = "block_comment";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "block_comment" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "block_comment");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `boolean_literal`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BooleanLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BooleanLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BooleanLiteral<'tree> {
    type WithLifetime<'a> = BooleanLiteral<'a>;
    const KIND: &'static str = "boolean_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "boolean_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "boolean_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `bounded_type`

This node has named children of type `{_type | lifetime}+`:

- [`Type`]
- [`Lifetime`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BoundedType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BoundedType<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for BoundedType<'tree> {
    type Child = anon_unions::Type_Lifetime<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BoundedType<'tree> {
    type WithLifetime<'a> = BoundedType<'a>;
    const KIND: &'static str = "bounded_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "bounded_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "bounded_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `bracketed_type`

This node has a named child of type `{_type | qualified_type}`:

- [`Type`]
- [`QualifiedType`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BracketedType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BracketedType<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for BracketedType<'tree> {
    type Child = anon_unions::Type_QualifiedType<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BracketedType<'tree> {
    type WithLifetime<'a> = BracketedType<'a>;
    const KIND: &'static str = "bracketed_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "bracketed_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "bracketed_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `break_expression`

This node has named children of type `{_expression | label}*`:

- [`Expression`]
- [`Label`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct BreakExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> BreakExpression<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for BreakExpression<'tree> {
    type Child = anon_unions::Expression_Label<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for BreakExpression<'tree> {
    type WithLifetime<'a> = BreakExpression<'a>;
    const KIND: &'static str = "break_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "break_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "break_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `call_expression`

This node has these fields:

- `arguments`: `arguments` ([`Arguments`])
- `function`: `{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | gen_block | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}` ([`Literal`] | [`ArrayExpression`] | [`AssignmentExpression`] | [`AsyncBlock`] | [`AwaitExpression`] | [`BinaryExpression`] | [`Block`] | [`BreakExpression`] | [`CallExpression`] | [`ClosureExpression`] | [`CompoundAssignmentExpr`] | [`ConstBlock`] | [`ContinueExpression`] | [`FieldExpression`] | [`ForExpression`] | [`GenBlock`] | [`GenericFunction`] | [`Identifier`] | [`IfExpression`] | [`IndexExpression`] | [`LoopExpression`] | [`MacroInvocation`] | [`MatchExpression`] | [`Metavariable`] | [`ParenthesizedExpression`] | [`ReferenceExpression`] | [`ReturnExpression`] | [`ScopedIdentifier`] | [`Self_`] | [`StructExpression`] | [`TryBlock`] | [`TryExpression`] | [`TupleExpression`] | [`TypeCastExpression`] | [`UnaryExpression`] | [`UnitExpression`] | [`UnsafeBlock`] | [`WhileExpression`] | [`YieldExpression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CallExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CallExpression<'tree> {
    /**Get the field `arguments`.

This child has type `arguments` ([`Arguments`])*/
    #[inline]
    pub fn arguments(&self) -> ::type_sitter_lib::NodeResult<'tree, Arguments<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("arguments")
            .map(<Arguments<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `function`.

This child has type `{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | gen_block | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}`:

- [`Literal`]
- [`ArrayExpression`]
- [`AssignmentExpression`]
- [`AsyncBlock`]
- [`AwaitExpression`]
- [`BinaryExpression`]
- [`Block`]
- [`BreakExpression`]
- [`CallExpression`]
- [`ClosureExpression`]
- [`CompoundAssignmentExpr`]
- [`ConstBlock`]
- [`ContinueExpression`]
- [`FieldExpression`]
- [`ForExpression`]
- [`GenBlock`]
- [`GenericFunction`]
- [`Identifier`]
- [`IfExpression`]
- [`IndexExpression`]
- [`LoopExpression`]
- [`MacroInvocation`]
- [`MatchExpression`]
- [`Metavariable`]
- [`ParenthesizedExpression`]
- [`ReferenceExpression`]
- [`ReturnExpression`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`StructExpression`]
- [`TryBlock`]
- [`TryExpression`]
- [`TupleExpression`]
- [`TypeCastExpression`]
- [`UnaryExpression`]
- [`UnitExpression`]
- [`UnsafeBlock`]
- [`WhileExpression`]
- [`YieldExpression`]
*/
    #[inline]
    pub fn function(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenBlock_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("function")
            .map(
                <anon_unions::Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenBlock_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CallExpression<'tree> {
    type WithLifetime<'a> = CallExpression<'a>;
    const KIND: &'static str = "call_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "call_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "call_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `captured_pattern`

This node has named children of type `_pattern+` ([`Pattern`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CapturedPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CapturedPattern<'tree> {
    /**Get the node's not-extra named children.

These children have type `_pattern+` ([`Pattern`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for CapturedPattern<'tree> {
    type Child = Pattern<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CapturedPattern<'tree> {
    type WithLifetime<'a> = CapturedPattern<'a>;
    const KIND: &'static str = "captured_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "captured_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "captured_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `char_literal`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CharLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CharLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CharLiteral<'tree> {
    type WithLifetime<'a> = CharLiteral<'a>;
    const KIND: &'static str = "char_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "char_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "char_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `closure_expression`

This node has these fields:

- `body`: `{_ | _expression}` ([`symbols::__`] | [`Expression`])
- `parameters`: `closure_parameters` ([`ClosureParameters`])
- `return_type`: `_type?` ([`Type`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ClosureExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ClosureExpression<'tree> {
    /**Get the field `body`.

This child has type `{_ | _expression}`:

- [`symbols::__`]
- [`Expression`]
*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, anon_unions::___Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <anon_unions::___Expression<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `parameters`.

This child has type `closure_parameters` ([`ClosureParameters`])*/
    #[inline]
    pub fn parameters(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, ClosureParameters<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("parameters")
            .map(
                <ClosureParameters<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `return_type`.

This child has type `_type?` ([`Type`])*/
    #[inline]
    pub fn return_type(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Type<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ClosureExpression<'tree> {
    type WithLifetime<'a> = ClosureExpression<'a>;
    const KIND: &'static str = "closure_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "closure_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "closure_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `closure_parameters`

This node has named children of type `{_pattern | parameter}*`:

- [`Pattern`]
- [`Parameter`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ClosureParameters<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ClosureParameters<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ClosureParameters<'tree> {
    type Child = anon_unions::Pattern_Parameter<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ClosureParameters<'tree> {
    type WithLifetime<'a> = ClosureParameters<'a>;
    const KIND: &'static str = "closure_parameters";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "closure_parameters" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "closure_parameters");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `compound_assignment_expr`

This node has these fields:

- `left`: `_expression` ([`Expression`])
- `operator`: `{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}` ([`symbols::ModEq`] | [`symbols::AndEq`] | [`symbols::MulEq`] | [`symbols::AddEq`] | [`symbols::SubEq`] | [`symbols::DivEq`] | [`symbols::LtLtEq`] | [`symbols::GtGtEq`] | [`symbols::BitXorEq`] | [`symbols::OrEq`])
- `right`: `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct CompoundAssignmentExpr<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> CompoundAssignmentExpr<'tree> {
    /**Get the field `left`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn left(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `operator`.

This child has type `{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}`:

- [`symbols::ModEq`]
- [`symbols::AndEq`]
- [`symbols::MulEq`]
- [`symbols::AddEq`]
- [`symbols::SubEq`]
- [`symbols::DivEq`]
- [`symbols::LtLtEq`]
- [`symbols::GtGtEq`]
- [`symbols::BitXorEq`]
- [`symbols::OrEq`]
*/
    #[inline]
    pub fn operator(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("operator")
            .map(
                <anon_unions::ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `right`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn right(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("right")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for CompoundAssignmentExpr<'tree> {
    type WithLifetime<'a> = CompoundAssignmentExpr<'a>;
    const KIND: &'static str = "compound_assignment_expr";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "compound_assignment_expr" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "compound_assignment_expr");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `const_block`

This node has these fields:

- `body`: `block` ([`Block`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstBlock<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstBlock<'tree> {
    /**Get the field `body`.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ConstBlock<'tree> {
    type WithLifetime<'a> = ConstBlock<'a>;
    const KIND: &'static str = "const_block";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "const_block" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "const_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `const_item`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `type`: `_type` ([`Type`])
- `value`: `_expression?` ([`Expression`])

And an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstItem<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `value`.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `visibility_modifier?` ([`VisibilityModifier`])*/
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, VisibilityModifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ConstItem<'tree> {
    type WithLifetime<'a> = ConstItem<'a>;
    const KIND: &'static str = "const_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "const_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "const_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `const_parameter`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `type`: `_type` ([`Type`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstParameter<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstParameter<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ConstParameter<'tree> {
    type WithLifetime<'a> = ConstParameter<'a>;
    const KIND: &'static str = "const_parameter";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "const_parameter" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "const_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `constrained_type_parameter`

This node has these fields:

- `bounds`: `trait_bounds` ([`TraitBounds`])
- `left`: `{lifetime | type_identifier}` ([`Lifetime`] | [`TypeIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ConstrainedTypeParameter<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ConstrainedTypeParameter<'tree> {
    /**Get the field `bounds`.

This child has type `trait_bounds` ([`TraitBounds`])*/
    #[inline]
    pub fn bounds(&self) -> ::type_sitter_lib::NodeResult<'tree, TraitBounds<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `left`.

This child has type `{lifetime | type_identifier}`:

- [`Lifetime`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn left(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Lifetime_TypeIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(
                <anon_unions::Lifetime_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ConstrainedTypeParameter<'tree> {
    type WithLifetime<'a> = ConstrainedTypeParameter<'a>;
    const KIND: &'static str = "constrained_type_parameter";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "constrained_type_parameter" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "constrained_type_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `continue_expression`

This node has an optional named child of type `label?` ([`Label`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ContinueExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ContinueExpression<'tree> {
    /**Get the node's only not-extra named child, if it has one.

This child has type `label?` ([`Label`])*/
    #[inline]
    pub fn label(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Label<'tree>>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for ContinueExpression<'tree> {
    type Child = Label<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ContinueExpression<'tree> {
    type WithLifetime<'a> = ContinueExpression<'a>;
    const KIND: &'static str = "continue_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "continue_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "continue_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `crate`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Crate<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Crate<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Crate<'tree> {
    type WithLifetime<'a> = Crate<'a>;
    const KIND: &'static str = "crate";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "crate" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "crate");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `declaration_list`

This node has named children of type `_declaration_statement*` ([`DeclarationStatement`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DeclarationList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DeclarationList<'tree> {
    /**Get the node's not-extra named children.

These children have type `_declaration_statement*` ([`DeclarationStatement`])*/
    #[inline]
    pub fn declaration_statements<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, DeclarationStatement<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(
                <DeclarationStatement<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for DeclarationList<'tree> {
    type Child = DeclarationStatement<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for DeclarationList<'tree> {
    type WithLifetime<'a> = DeclarationList<'a>;
    const KIND: &'static str = "declaration_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "declaration_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `doc_comment`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DocComment<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DocComment<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for DocComment<'tree> {
    type WithLifetime<'a> = DocComment<'a>;
    const KIND: &'static str = "doc_comment";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "doc_comment" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "doc_comment");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `dynamic_type`

This node has these fields:

- `trait`: `{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}` ([`FunctionType`] | [`GenericType`] | [`HigherRankedTraitBound`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct DynamicType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> DynamicType<'tree> {
    /**Get the field `trait`.

This child has type `{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}`:

- [`FunctionType`]
- [`GenericType`]
- [`HigherRankedTraitBound`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#trait(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("trait")
            .map(
                <anon_unions::FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for DynamicType<'tree> {
    type WithLifetime<'a> = DynamicType<'a>;
    const KIND: &'static str = "dynamic_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "dynamic_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "dynamic_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `else_clause`

This node has a named child of type `{block | if_expression}`:

- [`Block`]
- [`IfExpression`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ElseClause<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ElseClause<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for ElseClause<'tree> {
    type Child = anon_unions::Block_IfExpression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ElseClause<'tree> {
    type WithLifetime<'a> = ElseClause<'a>;
    const KIND: &'static str = "else_clause";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "else_clause" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "else_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `empty_statement`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EmptyStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EmptyStatement<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EmptyStatement<'tree> {
    type WithLifetime<'a> = EmptyStatement<'a>;
    const KIND: &'static str = "empty_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "empty_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "empty_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `enum_item`

This node has these fields:

- `body`: `enum_variant_list` ([`EnumVariantList`])
- `name`: `type_identifier` ([`TypeIdentifier`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And additional named children of type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumItem<'tree> {
    /**Get the field `body`.

This child has type `enum_variant_list` ([`EnumVariantList`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, EnumVariantList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <EnumVariantList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::VisibilityModifier_WhereClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EnumItem<'tree> {
    type WithLifetime<'a> = EnumItem<'a>;
    const KIND: &'static str = "enum_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "enum_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enum_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `enum_variant`

This node has these fields:

- `body`: `{field_declaration_list | ordered_field_declaration_list}?` ([`FieldDeclarationList`] | [`OrderedFieldDeclarationList`])
- `name`: `identifier` ([`Identifier`])
- `value`: `_expression?` ([`Expression`])

And an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumVariant<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumVariant<'tree> {
    /**Get the optional field `body`.

This child has type `{field_declaration_list | ordered_field_declaration_list}?`:

- [`FieldDeclarationList`]
- [`OrderedFieldDeclarationList`]
*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::FieldDeclarationList_OrderedFieldDeclarationList<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <anon_unions::FieldDeclarationList_OrderedFieldDeclarationList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `value`.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `visibility_modifier?` ([`VisibilityModifier`])*/
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, VisibilityModifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EnumVariant<'tree> {
    type WithLifetime<'a> = EnumVariant<'a>;
    const KIND: &'static str = "enum_variant";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "enum_variant" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enum_variant");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `enum_variant_list`

This node has named children of type `{attribute_item | enum_variant}*`:

- [`AttributeItem`]
- [`EnumVariant`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EnumVariantList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EnumVariantList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for EnumVariantList<'tree> {
    type Child = anon_unions::AttributeItem_EnumVariant<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EnumVariantList<'tree> {
    type WithLifetime<'a> = EnumVariantList<'a>;
    const KIND: &'static str = "enum_variant_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "enum_variant_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "enum_variant_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `escape_sequence`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct EscapeSequence<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> EscapeSequence<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for EscapeSequence<'tree> {
    type WithLifetime<'a> = EscapeSequence<'a>;
    const KIND: &'static str = "escape_sequence";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "escape_sequence" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "escape_sequence");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `expression_statement`

This node has a named child of type `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExpressionStatement<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExpressionStatement<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for ExpressionStatement<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ExpressionStatement<'tree> {
    type WithLifetime<'a> = ExpressionStatement<'a>;
    const KIND: &'static str = "expression_statement";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "expression_statement" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "expression_statement");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `extern_crate_declaration`

This node has these fields:

- `alias`: `identifier?` ([`Identifier`])
- `name`: `identifier` ([`Identifier`])

And additional named children of type `{crate | visibility_modifier}+`:

- [`Crate`]
- [`VisibilityModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExternCrateDeclaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExternCrateDeclaration<'tree> {
    /**Get the optional field `alias`.

This child has type `identifier?` ([`Identifier`])*/
    #[inline]
    pub fn alias(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Identifier<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alias")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{crate | visibility_modifier}+`:

- [`Crate`]
- [`VisibilityModifier`]
*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Crate_VisibilityModifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::Crate_VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ExternCrateDeclaration<'tree> {
    type WithLifetime<'a> = ExternCrateDeclaration<'a>;
    const KIND: &'static str = "extern_crate_declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "extern_crate_declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "extern_crate_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `extern_modifier`

This node has an optional named child of type `string_literal?` ([`StringLiteral`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ExternModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ExternModifier<'tree> {
    /**Get the node's only not-extra named child, if it has one.

This child has type `string_literal?` ([`StringLiteral`])*/
    #[inline]
    pub fn string_literal(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, StringLiteral<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<StringLiteral<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for ExternModifier<'tree> {
    type Child = StringLiteral<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ExternModifier<'tree> {
    type WithLifetime<'a> = ExternModifier<'a>;
    const KIND: &'static str = "extern_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "extern_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "extern_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_declaration`

This node has these fields:

- `name`: `field_identifier` ([`FieldIdentifier`])
- `type`: `_type` ([`Type`])

And an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldDeclaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDeclaration<'tree> {
    /**Get the field `name`.

This child has type `field_identifier` ([`FieldIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, FieldIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(
                <FieldIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `visibility_modifier?` ([`VisibilityModifier`])*/
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, VisibilityModifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldDeclaration<'tree> {
    type WithLifetime<'a> = FieldDeclaration<'a>;
    const KIND: &'static str = "field_declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_declaration_list`

This node has named children of type `{attribute_item | field_declaration}*`:

- [`AttributeItem`]
- [`FieldDeclaration`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldDeclarationList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldDeclarationList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for FieldDeclarationList<'tree> {
    type Child = anon_unions::AttributeItem_FieldDeclaration<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldDeclarationList<'tree> {
    type WithLifetime<'a> = FieldDeclarationList<'a>;
    const KIND: &'static str = "field_declaration_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_declaration_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_expression`

This node has these fields:

- `field`: `{field_identifier | integer_literal}` ([`FieldIdentifier`] | [`IntegerLiteral`])
- `value`: `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldExpression<'tree> {
    /**Get the field `field`.

This child has type `{field_identifier | integer_literal}`:

- [`FieldIdentifier`]
- [`IntegerLiteral`]
*/
    #[inline]
    pub fn field(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::FieldIdentifier_IntegerLiteral<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("field")
            .map(
                <anon_unions::FieldIdentifier_IntegerLiteral<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldExpression<'tree> {
    type WithLifetime<'a> = FieldExpression<'a>;
    const KIND: &'static str = "field_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldIdentifier<'tree> {
    type WithLifetime<'a> = FieldIdentifier<'a>;
    const KIND: &'static str = "field_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_initializer`

This node has these fields:

- `field`: `{field_identifier | integer_literal}` ([`FieldIdentifier`] | [`IntegerLiteral`])
- `value`: `_expression` ([`Expression`])

And additional named children of type `attribute_item*` ([`AttributeItem`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldInitializer<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldInitializer<'tree> {
    /**Get the field `field`.

This child has type `{field_identifier | integer_literal}`:

- [`FieldIdentifier`]
- [`IntegerLiteral`]
*/
    #[inline]
    pub fn field(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::FieldIdentifier_IntegerLiteral<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("field")
            .map(
                <anon_unions::FieldIdentifier_IntegerLiteral<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `attribute_item*` ([`AttributeItem`])*/
    #[inline]
    pub fn attribute_items<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, AttributeItem<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(<AttributeItem<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldInitializer<'tree> {
    type WithLifetime<'a> = FieldInitializer<'a>;
    const KIND: &'static str = "field_initializer";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_initializer" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_initializer");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_initializer_list`

This node has named children of type `{base_field_initializer | field_initializer | shorthand_field_initializer}*`:

- [`BaseFieldInitializer`]
- [`FieldInitializer`]
- [`ShorthandFieldInitializer`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldInitializerList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldInitializerList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for FieldInitializerList<'tree> {
    type Child = anon_unions::BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldInitializerList<'tree> {
    type WithLifetime<'a> = FieldInitializerList<'a>;
    const KIND: &'static str = "field_initializer_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_initializer_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_initializer_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `field_pattern`

This node has these fields:

- `name`: `{field_identifier | shorthand_field_identifier}` ([`FieldIdentifier`] | [`ShorthandFieldIdentifier`])
- `pattern`: `_pattern?` ([`Pattern`])

And an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FieldPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FieldPattern<'tree> {
    /**Get the field `name`.

This child has type `{field_identifier | shorthand_field_identifier}`:

- [`FieldIdentifier`]
- [`ShorthandFieldIdentifier`]
*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::FieldIdentifier_ShorthandFieldIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(
                <anon_unions::FieldIdentifier_ShorthandFieldIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `pattern`.

This child has type `_pattern?` ([`Pattern`])*/
    #[inline]
    pub fn pattern(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Pattern<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `mutable_specifier?` ([`MutableSpecifier`])*/
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, MutableSpecifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <MutableSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FieldPattern<'tree> {
    type WithLifetime<'a> = FieldPattern<'a>;
    const KIND: &'static str = "field_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "field_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "field_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `float_literal`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FloatLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FloatLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FloatLiteral<'tree> {
    type WithLifetime<'a> = FloatLiteral<'a>;
    const KIND: &'static str = "float_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "float_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "float_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `for_expression`

This node has these fields:

- `body`: `block` ([`Block`])
- `pattern`: `_pattern` ([`Pattern`])
- `value`: `_expression` ([`Expression`])

And an optional additional named child of type `label?` ([`Label`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ForExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ForExpression<'tree> {
    /**Get the field `body`.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `pattern`.

This child has type `_pattern` ([`Pattern`])*/
    #[inline]
    pub fn pattern(&self) -> ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `label?` ([`Label`])*/
    #[inline]
    pub fn label(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Label<'tree>>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ForExpression<'tree> {
    type WithLifetime<'a> = ForExpression<'a>;
    const KIND: &'static str = "for_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "for_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "for_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `for_lifetimes`

This node has named children of type `lifetime+` ([`Lifetime`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ForLifetimes<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ForLifetimes<'tree> {
    /**Get the node's not-extra named children.

These children have type `lifetime+` ([`Lifetime`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn lifetimes<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Lifetime<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Lifetime<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ForLifetimes<'tree> {
    type Child = Lifetime<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ForLifetimes<'tree> {
    type WithLifetime<'a> = ForLifetimes<'a>;
    const KIND: &'static str = "for_lifetimes";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "for_lifetimes" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "for_lifetimes");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `foreign_mod_item`

This node has these fields:

- `body`: `declaration_list?` ([`DeclarationList`])

And additional named children of type `{extern_modifier | visibility_modifier}+`:

- [`ExternModifier`]
- [`VisibilityModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ForeignModItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ForeignModItem<'tree> {
    /**Get the optional field `body`.

This child has type `declaration_list?` ([`DeclarationList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, DeclarationList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <DeclarationList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{extern_modifier | visibility_modifier}+`:

- [`ExternModifier`]
- [`VisibilityModifier`]
*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::ExternModifier_VisibilityModifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::ExternModifier_VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ForeignModItem<'tree> {
    type WithLifetime<'a> = ForeignModItem<'a>;
    const KIND: &'static str = "foreign_mod_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "foreign_mod_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "foreign_mod_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `fragment_specifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FragmentSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FragmentSpecifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FragmentSpecifier<'tree> {
    type WithLifetime<'a> = FragmentSpecifier<'a>;
    const KIND: &'static str = "fragment_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "fragment_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "fragment_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `function_item`

This node has these fields:

- `body`: `block` ([`Block`])
- `name`: `{identifier | metavariable}` ([`Identifier`] | [`Metavariable`])
- `parameters`: `parameters` ([`Parameters`])
- `return_type`: `_type?` ([`Type`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And additional named children of type `{function_modifiers | visibility_modifier | where_clause}*`:

- [`FunctionModifiers`]
- [`VisibilityModifier`]
- [`WhereClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionItem<'tree> {
    /**Get the field `body`.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `name`.

This child has type `{identifier | metavariable}`:

- [`Identifier`]
- [`Metavariable`]
*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Identifier_Metavariable<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(
                <anon_unions::Identifier_Metavariable<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `parameters`.

This child has type `parameters` ([`Parameters`])*/
    #[inline]
    pub fn parameters(&self) -> ::type_sitter_lib::NodeResult<'tree, Parameters<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<Parameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `return_type`.

This child has type `_type?` ([`Type`])*/
    #[inline]
    pub fn return_type(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Type<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{function_modifiers | visibility_modifier | where_clause}*`:

- [`FunctionModifiers`]
- [`VisibilityModifier`]
- [`WhereClause`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::FunctionModifiers_VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::FunctionModifiers_VisibilityModifier_WhereClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FunctionItem<'tree> {
    type WithLifetime<'a> = FunctionItem<'a>;
    const KIND: &'static str = "function_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "function_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `function_modifiers`

This node has named children of type `extern_modifier*` ([`ExternModifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionModifiers<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionModifiers<'tree> {
    /**Get the node's not-extra named children.

These children have type `extern_modifier*` ([`ExternModifier`])*/
    #[inline]
    pub fn extern_modifiers<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, ExternModifier<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<ExternModifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for FunctionModifiers<'tree> {
    type Child = ExternModifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FunctionModifiers<'tree> {
    type WithLifetime<'a> = FunctionModifiers<'a>;
    const KIND: &'static str = "function_modifiers";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "function_modifiers" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_modifiers");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `function_signature_item`

This node has these fields:

- `name`: `{identifier | metavariable}` ([`Identifier`] | [`Metavariable`])
- `parameters`: `parameters` ([`Parameters`])
- `return_type`: `_type?` ([`Type`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And additional named children of type `{function_modifiers | visibility_modifier | where_clause}*`:

- [`FunctionModifiers`]
- [`VisibilityModifier`]
- [`WhereClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionSignatureItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionSignatureItem<'tree> {
    /**Get the field `name`.

This child has type `{identifier | metavariable}`:

- [`Identifier`]
- [`Metavariable`]
*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Identifier_Metavariable<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(
                <anon_unions::Identifier_Metavariable<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `parameters`.

This child has type `parameters` ([`Parameters`])*/
    #[inline]
    pub fn parameters(&self) -> ::type_sitter_lib::NodeResult<'tree, Parameters<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<Parameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `return_type`.

This child has type `_type?` ([`Type`])*/
    #[inline]
    pub fn return_type(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Type<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{function_modifiers | visibility_modifier | where_clause}*`:

- [`FunctionModifiers`]
- [`VisibilityModifier`]
- [`WhereClause`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::FunctionModifiers_VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::FunctionModifiers_VisibilityModifier_WhereClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FunctionSignatureItem<'tree> {
    type WithLifetime<'a> = FunctionSignatureItem<'a>;
    const KIND: &'static str = "function_signature_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "function_signature_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_signature_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `function_type`

This node has these fields:

- `parameters`: `parameters` ([`Parameters`])
- `return_type`: `_type?` ([`Type`])
- `trait`: `{scoped_type_identifier | type_identifier}?` ([`ScopedTypeIdentifier`] | [`TypeIdentifier`])

And additional named children of type `{for_lifetimes | function_modifiers}*`:

- [`ForLifetimes`]
- [`FunctionModifiers`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct FunctionType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> FunctionType<'tree> {
    /**Get the field `parameters`.

This child has type `parameters` ([`Parameters`])*/
    #[inline]
    pub fn parameters(&self) -> ::type_sitter_lib::NodeResult<'tree, Parameters<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("parameters")
            .map(<Parameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `return_type`.

This child has type `_type?` ([`Type`])*/
    #[inline]
    pub fn return_type(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Type<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("return_type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `trait`.

This child has type `{scoped_type_identifier | type_identifier}?`:

- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#trait(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::ScopedTypeIdentifier_TypeIdentifier<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("trait")
            .map(
                <anon_unions::ScopedTypeIdentifier_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{for_lifetimes | function_modifiers}*`:

- [`ForLifetimes`]
- [`FunctionModifiers`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::ForLifetimes_FunctionModifiers<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::ForLifetimes_FunctionModifiers<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for FunctionType<'tree> {
    type WithLifetime<'a> = FunctionType<'a>;
    const KIND: &'static str = "function_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "function_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "function_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `gen_block`

This node has a named child of type `block` ([`Block`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenBlock<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenBlock<'tree> {
    /**Get the node's only not-extra named child.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn block(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for GenBlock<'tree> {
    type Child = Block<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GenBlock<'tree> {
    type WithLifetime<'a> = GenBlock<'a>;
    const KIND: &'static str = "gen_block";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "gen_block" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "gen_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `generic_function`

This node has these fields:

- `function`: `{field_expression | identifier | scoped_identifier}` ([`FieldExpression`] | [`Identifier`] | [`ScopedIdentifier`])
- `type_arguments`: `type_arguments` ([`TypeArguments`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenericFunction<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenericFunction<'tree> {
    /**Get the field `function`.

This child has type `{field_expression | identifier | scoped_identifier}`:

- [`FieldExpression`]
- [`Identifier`]
- [`ScopedIdentifier`]
*/
    #[inline]
    pub fn function(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::FieldExpression_Identifier_ScopedIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("function")
            .map(
                <anon_unions::FieldExpression_Identifier_ScopedIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type_arguments`.

This child has type `type_arguments` ([`TypeArguments`])*/
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GenericFunction<'tree> {
    type WithLifetime<'a> = GenericFunction<'a>;
    const KIND: &'static str = "generic_function";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "generic_function" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "generic_function");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `generic_type`

This node has these fields:

- `type`: `{identifier | scoped_identifier | scoped_type_identifier | type_identifier}` ([`Identifier`] | [`ScopedIdentifier`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])
- `type_arguments`: `type_arguments` ([`TypeArguments`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenericType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenericType<'tree> {
    /**Get the field `type`.

This child has type `{identifier | scoped_identifier | scoped_type_identifier | type_identifier}`:

- [`Identifier`]
- [`ScopedIdentifier`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(
                <anon_unions::Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type_arguments`.

This child has type `type_arguments` ([`TypeArguments`])*/
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GenericType<'tree> {
    type WithLifetime<'a> = GenericType<'a>;
    const KIND: &'static str = "generic_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "generic_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "generic_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `generic_type_with_turbofish`

This node has these fields:

- `type`: `{scoped_identifier | type_identifier}` ([`ScopedIdentifier`] | [`TypeIdentifier`])
- `type_arguments`: `type_arguments` ([`TypeArguments`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct GenericTypeWithTurbofish<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> GenericTypeWithTurbofish<'tree> {
    /**Get the field `type`.

This child has type `{scoped_identifier | type_identifier}`:

- [`ScopedIdentifier`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ScopedIdentifier_TypeIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(
                <anon_unions::ScopedIdentifier_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type_arguments`.

This child has type `type_arguments` ([`TypeArguments`])*/
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for GenericTypeWithTurbofish<'tree> {
    type WithLifetime<'a> = GenericTypeWithTurbofish<'a>;
    const KIND: &'static str = "generic_type_with_turbofish";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "generic_type_with_turbofish" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "generic_type_with_turbofish");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `higher_ranked_trait_bound`

This node has these fields:

- `type`: `_type` ([`Type`])
- `type_parameters`: `type_parameters` ([`TypeParameters`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct HigherRankedTraitBound<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> HigherRankedTraitBound<'tree> {
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type_parameters`.

This child has type `type_parameters` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for HigherRankedTraitBound<'tree> {
    type WithLifetime<'a> = HigherRankedTraitBound<'a>;
    const KIND: &'static str = "higher_ranked_trait_bound";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "higher_ranked_trait_bound" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "higher_ranked_trait_bound");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Identifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Identifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Identifier<'tree> {
    type WithLifetime<'a> = Identifier<'a>;
    const KIND: &'static str = "identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `if_expression`

This node has these fields:

- `alternative`: `else_clause?` ([`ElseClause`])
- `condition`: `{_expression | let_chain | let_condition}` ([`Expression`] | [`LetChain`] | [`LetCondition`])
- `consequence`: `block` ([`Block`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct IfExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> IfExpression<'tree> {
    /**Get the optional field `alternative`.

This child has type `else_clause?` ([`ElseClause`])*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, ElseClause<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(<ElseClause<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `condition`.

This child has type `{_expression | let_chain | let_condition}`:

- [`Expression`]
- [`LetChain`]
- [`LetCondition`]
*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_LetChain_LetCondition<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::Expression_LetChain_LetCondition<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `consequence`.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn consequence(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("consequence")
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for IfExpression<'tree> {
    type WithLifetime<'a> = IfExpression<'a>;
    const KIND: &'static str = "if_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "if_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "if_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `impl_item`

This node has these fields:

- `body`: `declaration_list?` ([`DeclarationList`])
- `trait`: `{generic_type | scoped_type_identifier | type_identifier}?` ([`GenericType`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])
- `type`: `_type` ([`Type`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And an optional additional named child of type `where_clause?` ([`WhereClause`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ImplItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ImplItem<'tree> {
    /**Get the optional field `body`.

This child has type `declaration_list?` ([`DeclarationList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, DeclarationList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <DeclarationList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `trait`.

This child has type `{generic_type | scoped_type_identifier | type_identifier}?`:

- [`GenericType`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#trait(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("trait")
            .map(
                <anon_unions::GenericType_ScopedTypeIdentifier_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `where_clause?` ([`WhereClause`])*/
    #[inline]
    pub fn where_clause(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, WhereClause<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<WhereClause<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ImplItem<'tree> {
    type WithLifetime<'a> = ImplItem<'a>;
    const KIND: &'static str = "impl_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "impl_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "impl_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `index_expression`

This node has named children of type `_expression+` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct IndexExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> IndexExpression<'tree> {
    /**Get the node's not-extra named children.

These children have type `_expression+` ([`Expression`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn expressions<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Expression<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for IndexExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for IndexExpression<'tree> {
    type WithLifetime<'a> = IndexExpression<'a>;
    const KIND: &'static str = "index_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "index_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "index_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `inner_attribute_item`

This node has a named child of type `attribute` ([`Attribute`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct InnerAttributeItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> InnerAttributeItem<'tree> {
    /**Get the node's only not-extra named child.

This child has type `attribute` ([`Attribute`])*/
    #[inline]
    pub fn attribute(&self) -> ::type_sitter_lib::NodeResult<'tree, Attribute<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Attribute<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for InnerAttributeItem<'tree> {
    type Child = Attribute<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for InnerAttributeItem<'tree> {
    type WithLifetime<'a> = InnerAttributeItem<'a>;
    const KIND: &'static str = "inner_attribute_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "inner_attribute_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "inner_attribute_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `inner_doc_comment_marker`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct InnerDocCommentMarker<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> InnerDocCommentMarker<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for InnerDocCommentMarker<'tree> {
    type WithLifetime<'a> = InnerDocCommentMarker<'a>;
    const KIND: &'static str = "inner_doc_comment_marker";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "inner_doc_comment_marker" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "inner_doc_comment_marker");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `integer_literal`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct IntegerLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> IntegerLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for IntegerLiteral<'tree> {
    type WithLifetime<'a> = IntegerLiteral<'a>;
    const KIND: &'static str = "integer_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "integer_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "integer_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `label`

This node has a named child of type `identifier` ([`Identifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Label<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Label<'tree> {
    /**Get the node's only not-extra named child.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn identifier(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for Label<'tree> {
    type Child = Identifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Label<'tree> {
    type WithLifetime<'a> = Label<'a>;
    const KIND: &'static str = "label";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "label" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "label");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `let_chain`

This node has named children of type `{_expression | let_condition}+`:

- [`Expression`]
- [`LetCondition`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LetChain<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LetChain<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for LetChain<'tree> {
    type Child = anon_unions::Expression_LetCondition<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LetChain<'tree> {
    type WithLifetime<'a> = LetChain<'a>;
    const KIND: &'static str = "let_chain";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "let_chain" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "let_chain");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `let_condition`

This node has these fields:

- `pattern`: `_pattern` ([`Pattern`])
- `value`: `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LetCondition<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LetCondition<'tree> {
    /**Get the field `pattern`.

This child has type `_pattern` ([`Pattern`])*/
    #[inline]
    pub fn pattern(&self) -> ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LetCondition<'tree> {
    type WithLifetime<'a> = LetCondition<'a>;
    const KIND: &'static str = "let_condition";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "let_condition" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "let_condition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `let_declaration`

This node has these fields:

- `alternative`: `block?` ([`Block`])
- `pattern`: `_pattern` ([`Pattern`])
- `type`: `_type?` ([`Type`])
- `value`: `_expression?` ([`Expression`])

And an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LetDeclaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LetDeclaration<'tree> {
    /**Get the optional field `alternative`.

This child has type `block?` ([`Block`])*/
    #[inline]
    pub fn alternative(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Block<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alternative")
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `pattern`.

This child has type `_pattern` ([`Pattern`])*/
    #[inline]
    pub fn pattern(&self) -> ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type`.

This child has type `_type?` ([`Type`])*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Type<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `value`.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `mutable_specifier?` ([`MutableSpecifier`])*/
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, MutableSpecifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <MutableSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LetDeclaration<'tree> {
    type WithLifetime<'a> = LetDeclaration<'a>;
    const KIND: &'static str = "let_declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "let_declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "let_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `lifetime`

This node has a named child of type `identifier` ([`Identifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Lifetime<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Lifetime<'tree> {
    /**Get the node's only not-extra named child.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn identifier(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for Lifetime<'tree> {
    type Child = Identifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Lifetime<'tree> {
    type WithLifetime<'a> = Lifetime<'a>;
    const KIND: &'static str = "lifetime";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "lifetime" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "lifetime");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `line_comment`

This node has these fields:

- `doc`: `doc_comment?` ([`DocComment`])
- `inner`: `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])
- `outer`: `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LineComment<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LineComment<'tree> {
    /**Get the optional field `doc`.

This child has type `doc_comment?` ([`DocComment`])*/
    #[inline]
    pub fn doc(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, DocComment<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("doc")
            .map(<DocComment<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the optional field `inner`.

This child has type `inner_doc_comment_marker?` ([`InnerDocCommentMarker`])*/
    #[inline]
    pub fn inner(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, InnerDocCommentMarker<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("inner")
            .map(
                <InnerDocCommentMarker<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the optional field `outer`.

This child has type `outer_doc_comment_marker?` ([`OuterDocCommentMarker`])*/
    #[inline]
    pub fn outer(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, OuterDocCommentMarker<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("outer")
            .map(
                <OuterDocCommentMarker<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LineComment<'tree> {
    type WithLifetime<'a> = LineComment<'a>;
    const KIND: &'static str = "line_comment";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "line_comment" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "line_comment");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `loop_expression`

This node has these fields:

- `body`: `block` ([`Block`])

And an optional additional named child of type `label?` ([`Label`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct LoopExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> LoopExpression<'tree> {
    /**Get the field `body`.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `label?` ([`Label`])*/
    #[inline]
    pub fn label(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Label<'tree>>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for LoopExpression<'tree> {
    type WithLifetime<'a> = LoopExpression<'a>;
    const KIND: &'static str = "loop_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "loop_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "loop_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `macro_definition`

This node has these fields:

- `name`: `identifier` ([`Identifier`])

And additional named children of type `macro_rule*` ([`MacroRule`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MacroDefinition<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MacroDefinition<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `macro_rule*` ([`MacroRule`])*/
    #[inline]
    pub fn macro_rules<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, MacroRule<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(<MacroRule<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MacroDefinition<'tree> {
    type WithLifetime<'a> = MacroDefinition<'a>;
    const KIND: &'static str = "macro_definition";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "macro_definition" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "macro_definition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `macro_invocation`

This node has these fields:

- `macro`: `{identifier | scoped_identifier}` ([`Identifier`] | [`ScopedIdentifier`])

And an additional named child of type `token_tree` ([`TokenTree`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MacroInvocation<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MacroInvocation<'tree> {
    /**Get the field `macro`.

This child has type `{identifier | scoped_identifier}`:

- [`Identifier`]
- [`ScopedIdentifier`]
*/
    #[inline]
    pub fn r#macro(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Identifier_ScopedIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("macro")
            .map(
                <anon_unions::Identifier_ScopedIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child.

This child has type `token_tree` ([`TokenTree`])*/
    #[inline]
    pub fn token_tree(&self) -> ::type_sitter_lib::NodeResult<'tree, TokenTree<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<TokenTree<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MacroInvocation<'tree> {
    type WithLifetime<'a> = MacroInvocation<'a>;
    const KIND: &'static str = "macro_invocation";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "macro_invocation" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "macro_invocation");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `macro_rule`

This node has these fields:

- `left`: `token_tree_pattern` ([`TokenTreePattern`])
- `right`: `token_tree` ([`TokenTree`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MacroRule<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MacroRule<'tree> {
    /**Get the field `left`.

This child has type `token_tree_pattern` ([`TokenTreePattern`])*/
    #[inline]
    pub fn left(&self) -> ::type_sitter_lib::NodeResult<'tree, TokenTreePattern<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(
                <TokenTreePattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `right`.

This child has type `token_tree` ([`TokenTree`])*/
    #[inline]
    pub fn right(&self) -> ::type_sitter_lib::NodeResult<'tree, TokenTree<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("right")
            .map(<TokenTree<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MacroRule<'tree> {
    type WithLifetime<'a> = MacroRule<'a>;
    const KIND: &'static str = "macro_rule";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "macro_rule" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "macro_rule");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `match_arm`

This node has these fields:

- `pattern`: `match_pattern` ([`MatchPattern`])
- `value`: `_expression` ([`Expression`])

And additional named children of type `{attribute_item | inner_attribute_item}*`:

- [`AttributeItem`]
- [`InnerAttributeItem`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchArm<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchArm<'tree> {
    /**Get the field `pattern`.

This child has type `match_pattern` ([`MatchPattern`])*/
    #[inline]
    pub fn pattern(&self) -> ::type_sitter_lib::NodeResult<'tree, MatchPattern<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<MatchPattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_item | inner_attribute_item}*`:

- [`AttributeItem`]
- [`InnerAttributeItem`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeItem_InnerAttributeItem<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeItem_InnerAttributeItem<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MatchArm<'tree> {
    type WithLifetime<'a> = MatchArm<'a>;
    const KIND: &'static str = "match_arm";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "match_arm" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_arm");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `match_block`

This node has named children of type `match_arm*` ([`MatchArm`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchBlock<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchBlock<'tree> {
    /**Get the node's not-extra named children.

These children have type `match_arm*` ([`MatchArm`])*/
    #[inline]
    pub fn match_arms<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, MatchArm<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<MatchArm<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for MatchBlock<'tree> {
    type Child = MatchArm<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MatchBlock<'tree> {
    type WithLifetime<'a> = MatchBlock<'a>;
    const KIND: &'static str = "match_block";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "match_block" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `match_expression`

This node has these fields:

- `body`: `match_block` ([`MatchBlock`])
- `value`: `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchExpression<'tree> {
    /**Get the field `body`.

This child has type `match_block` ([`MatchBlock`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, MatchBlock<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<MatchBlock<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MatchExpression<'tree> {
    type WithLifetime<'a> = MatchExpression<'a>;
    const KIND: &'static str = "match_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "match_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `match_pattern`

This node has these fields:

- `condition`: `{_expression | let_chain | let_condition}?` ([`Expression`] | [`LetChain`] | [`LetCondition`])

And an additional named child of type `_pattern` ([`Pattern`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MatchPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MatchPattern<'tree> {
    /**Get the optional field `condition`.

This child has type `{_expression | let_chain | let_condition}?`:

- [`Expression`]
- [`LetChain`]
- [`LetCondition`]
*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Expression_LetChain_LetCondition<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::Expression_LetChain_LetCondition<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the node's only non-field not-extra named child.

This child has type `_pattern` ([`Pattern`])*/
    #[inline]
    pub fn pattern(&self) -> ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MatchPattern<'tree> {
    type WithLifetime<'a> = MatchPattern<'a>;
    const KIND: &'static str = "match_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "match_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "match_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `metavariable`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Metavariable<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Metavariable<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Metavariable<'tree> {
    type WithLifetime<'a> = Metavariable<'a>;
    const KIND: &'static str = "metavariable";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "metavariable" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "metavariable");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `mod_item`

This node has these fields:

- `body`: `declaration_list?` ([`DeclarationList`])
- `name`: `identifier` ([`Identifier`])

And an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ModItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ModItem<'tree> {
    /**Get the optional field `body`.

This child has type `declaration_list?` ([`DeclarationList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, DeclarationList<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <DeclarationList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `visibility_modifier?` ([`VisibilityModifier`])*/
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, VisibilityModifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ModItem<'tree> {
    type WithLifetime<'a> = ModItem<'a>;
    const KIND: &'static str = "mod_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "mod_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "mod_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `mut_pattern`

This node has named children of type `{_pattern | mutable_specifier}+`:

- [`Pattern`]
- [`MutableSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MutPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MutPattern<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for MutPattern<'tree> {
    type Child = anon_unions::Pattern_MutableSpecifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MutPattern<'tree> {
    type WithLifetime<'a> = MutPattern<'a>;
    const KIND: &'static str = "mut_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "mut_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "mut_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `mutable_specifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct MutableSpecifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> MutableSpecifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for MutableSpecifier<'tree> {
    type WithLifetime<'a> = MutableSpecifier<'a>;
    const KIND: &'static str = "mutable_specifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "mutable_specifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "mutable_specifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `negative_literal`

This node has a named child of type `{float_literal | integer_literal}`:

- [`FloatLiteral`]
- [`IntegerLiteral`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct NegativeLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> NegativeLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for NegativeLiteral<'tree> {
    type Child = anon_unions::FloatLiteral_IntegerLiteral<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for NegativeLiteral<'tree> {
    type WithLifetime<'a> = NegativeLiteral<'a>;
    const KIND: &'static str = "negative_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "negative_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "negative_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `never_type`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct NeverType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> NeverType<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for NeverType<'tree> {
    type WithLifetime<'a> = NeverType<'a>;
    const KIND: &'static str = "never_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "never_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "never_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `optional_type_parameter`

This node has these fields:

- `default_type`: `_type` ([`Type`])
- `name`: `{constrained_type_parameter | type_identifier}` ([`ConstrainedTypeParameter`] | [`TypeIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OptionalTypeParameter<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OptionalTypeParameter<'tree> {
    /**Get the field `default_type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn default_type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("default_type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `name`.

This child has type `{constrained_type_parameter | type_identifier}`:

- [`ConstrainedTypeParameter`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ConstrainedTypeParameter_TypeIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(
                <anon_unions::ConstrainedTypeParameter_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for OptionalTypeParameter<'tree> {
    type WithLifetime<'a> = OptionalTypeParameter<'a>;
    const KIND: &'static str = "optional_type_parameter";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "optional_type_parameter" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "optional_type_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `or_pattern`

This node has named children of type `_pattern+` ([`Pattern`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OrPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OrPattern<'tree> {
    /**Get the node's not-extra named children.

These children have type `_pattern+` ([`Pattern`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for OrPattern<'tree> {
    type Child = Pattern<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for OrPattern<'tree> {
    type WithLifetime<'a> = OrPattern<'a>;
    const KIND: &'static str = "or_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "or_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "or_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ordered_field_declaration_list`

This node has these fields:

- `type`: `_type*` ([`Type`])

And additional named children of type `{attribute_item | visibility_modifier}*`:

- [`AttributeItem`]
- [`VisibilityModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OrderedFieldDeclarationList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OrderedFieldDeclarationList<'tree> {
    /**Get the children of field `type`.

These children have type `_type*` ([`Type`])*/
    #[inline]
    pub fn types<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Type<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .children_by_field_name("type", &mut c.0)
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{attribute_item | visibility_modifier}*`:

- [`AttributeItem`]
- [`VisibilityModifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::AttributeItem_VisibilityModifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::AttributeItem_VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for OrderedFieldDeclarationList<'tree> {
    type WithLifetime<'a> = OrderedFieldDeclarationList<'a>;
    const KIND: &'static str = "ordered_field_declaration_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ordered_field_declaration_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ordered_field_declaration_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `outer_doc_comment_marker`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct OuterDocCommentMarker<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> OuterDocCommentMarker<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for OuterDocCommentMarker<'tree> {
    type WithLifetime<'a> = OuterDocCommentMarker<'a>;
    const KIND: &'static str = "outer_doc_comment_marker";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "outer_doc_comment_marker" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "outer_doc_comment_marker");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `parameter`

This node has these fields:

- `pattern`: `{_pattern | self}` ([`Pattern`] | [`Self_`])
- `type`: `_type` ([`Type`])

And an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Parameter<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Parameter<'tree> {
    /**Get the field `pattern`.

This child has type `{_pattern | self}`:

- [`Pattern`]
- [`Self_`]
*/
    #[inline]
    pub fn pattern(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, anon_unions::Pattern_Self_<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("pattern")
            .map(
                <anon_unions::Pattern_Self_<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `mutable_specifier?` ([`MutableSpecifier`])*/
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, MutableSpecifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <MutableSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Parameter<'tree> {
    type WithLifetime<'a> = Parameter<'a>;
    const KIND: &'static str = "parameter";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "parameter" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `parameters`

This node has named children of type `{_type | attribute_item | parameter | self_parameter | variadic_parameter}*`:

- [`Type`]
- [`AttributeItem`]
- [`Parameter`]
- [`SelfParameter`]
- [`VariadicParameter`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Parameters<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Parameters<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for Parameters<'tree> {
    type Child = anon_unions::Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Parameters<'tree> {
    type WithLifetime<'a> = Parameters<'a>;
    const KIND: &'static str = "parameters";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "parameters" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parameters");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `parenthesized_expression`

This node has a named child of type `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ParenthesizedExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ParenthesizedExpression<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for ParenthesizedExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ParenthesizedExpression<'tree> {
    type WithLifetime<'a> = ParenthesizedExpression<'a>;
    const KIND: &'static str = "parenthesized_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "parenthesized_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "parenthesized_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `pointer_type`

This node has these fields:

- `type`: `_type` ([`Type`])

And an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PointerType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PointerType<'tree> {
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `mutable_specifier?` ([`MutableSpecifier`])*/
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, MutableSpecifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <MutableSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PointerType<'tree> {
    type WithLifetime<'a> = PointerType<'a>;
    const KIND: &'static str = "pointer_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "pointer_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "pointer_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `primitive_type`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct PrimitiveType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> PrimitiveType<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for PrimitiveType<'tree> {
    type WithLifetime<'a> = PrimitiveType<'a>;
    const KIND: &'static str = "primitive_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "primitive_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "primitive_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `qualified_type`

This node has these fields:

- `alias`: `_type` ([`Type`])
- `type`: `_type` ([`Type`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct QualifiedType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> QualifiedType<'tree> {
    /**Get the field `alias`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn alias(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alias")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for QualifiedType<'tree> {
    type WithLifetime<'a> = QualifiedType<'a>;
    const KIND: &'static str = "qualified_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "qualified_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "qualified_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `range_expression`

This node has named children of type `_expression*` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RangeExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RangeExpression<'tree> {
    /**Get the node's not-extra named children.

These children have type `_expression*` ([`Expression`])*/
    #[inline]
    pub fn expressions<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Expression<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for RangeExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for RangeExpression<'tree> {
    type WithLifetime<'a> = RangeExpression<'a>;
    const KIND: &'static str = "range_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "range_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "range_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `range_pattern`

This node has named children of type `{_literal_pattern | crate | identifier | metavariable | scoped_identifier | self | super}+`:

- [`LiteralPattern`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RangePattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RangePattern<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for RangePattern<'tree> {
    type Child = anon_unions::LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for RangePattern<'tree> {
    type WithLifetime<'a> = RangePattern<'a>;
    const KIND: &'static str = "range_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "range_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "range_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `raw_string_literal`

This node has a named child of type `string_content` ([`StringContent`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RawStringLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RawStringLiteral<'tree> {
    /**Get the node's only not-extra named child.

This child has type `string_content` ([`StringContent`])*/
    #[inline]
    pub fn string_content(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, StringContent<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<StringContent<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for RawStringLiteral<'tree> {
    type Child = StringContent<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for RawStringLiteral<'tree> {
    type WithLifetime<'a> = RawStringLiteral<'a>;
    const KIND: &'static str = "raw_string_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "raw_string_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "raw_string_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `ref_pattern`

This node has a named child of type `_pattern` ([`Pattern`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RefPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RefPattern<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_pattern` ([`Pattern`])*/
    #[inline]
    pub fn pattern(&self) -> ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for RefPattern<'tree> {
    type Child = Pattern<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for RefPattern<'tree> {
    type WithLifetime<'a> = RefPattern<'a>;
    const KIND: &'static str = "ref_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "ref_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "ref_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `reference_expression`

This node has these fields:

- `value`: `_expression` ([`Expression`])

And an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReferenceExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReferenceExpression<'tree> {
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `mutable_specifier?` ([`MutableSpecifier`])*/
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, MutableSpecifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <MutableSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ReferenceExpression<'tree> {
    type WithLifetime<'a> = ReferenceExpression<'a>;
    const KIND: &'static str = "reference_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "reference_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "reference_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `reference_pattern`

This node has named children of type `{_pattern | mutable_specifier}+`:

- [`Pattern`]
- [`MutableSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReferencePattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReferencePattern<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ReferencePattern<'tree> {
    type Child = anon_unions::Pattern_MutableSpecifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ReferencePattern<'tree> {
    type WithLifetime<'a> = ReferencePattern<'a>;
    const KIND: &'static str = "reference_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "reference_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "reference_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `reference_type`

This node has these fields:

- `type`: `_type` ([`Type`])

And additional named children of type `{lifetime | mutable_specifier}*`:

- [`Lifetime`]
- [`MutableSpecifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReferenceType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReferenceType<'tree> {
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{lifetime | mutable_specifier}*`:

- [`Lifetime`]
- [`MutableSpecifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Lifetime_MutableSpecifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::Lifetime_MutableSpecifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ReferenceType<'tree> {
    type WithLifetime<'a> = ReferenceType<'a>;
    const KIND: &'static str = "reference_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "reference_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "reference_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `remaining_field_pattern`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RemainingFieldPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RemainingFieldPattern<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for RemainingFieldPattern<'tree> {
    type WithLifetime<'a> = RemainingFieldPattern<'a>;
    const KIND: &'static str = "remaining_field_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "remaining_field_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "remaining_field_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `removed_trait_bound`

This node has a named child of type `_type` ([`Type`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct RemovedTraitBound<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> RemovedTraitBound<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for RemovedTraitBound<'tree> {
    type Child = Type<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for RemovedTraitBound<'tree> {
    type WithLifetime<'a> = RemovedTraitBound<'a>;
    const KIND: &'static str = "removed_trait_bound";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "removed_trait_bound" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "removed_trait_bound");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `return_expression`

This node has an optional named child of type `_expression?` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ReturnExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ReturnExpression<'tree> {
    /**Get the node's only not-extra named child, if it has one.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn expression(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for ReturnExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ReturnExpression<'tree> {
    type WithLifetime<'a> = ReturnExpression<'a>;
    const KIND: &'static str = "return_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "return_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "return_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `scoped_identifier`

This node has these fields:

- `name`: `{identifier | super}` ([`Identifier`] | [`Super`])
- `path`: `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?` ([`BracketedType`] | [`Crate`] | [`GenericType`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ScopedIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ScopedIdentifier<'tree> {
    /**Get the field `name`.

This child has type `{identifier | super}`:

- [`Identifier`]
- [`Super`]
*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, anon_unions::Identifier_Super<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(
                <anon_unions::Identifier_Super<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `path`.

This child has type `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?`:

- [`BracketedType`]
- [`Crate`]
- [`GenericType`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]
*/
    #[inline]
    pub fn path(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                'tree,
            >,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("path")
            .map(
                <anon_unions::BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ScopedIdentifier<'tree> {
    type WithLifetime<'a> = ScopedIdentifier<'a>;
    const KIND: &'static str = "scoped_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "scoped_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "scoped_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `scoped_type_identifier`

This node has these fields:

- `name`: `type_identifier` ([`TypeIdentifier`])
- `path`: `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?` ([`BracketedType`] | [`Crate`] | [`GenericType`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ScopedTypeIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ScopedTypeIdentifier<'tree> {
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `path`.

This child has type `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}?`:

- [`BracketedType`]
- [`Crate`]
- [`GenericType`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]
*/
    #[inline]
    pub fn path(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                'tree,
            >,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("path")
            .map(
                <anon_unions::BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ScopedTypeIdentifier<'tree> {
    type WithLifetime<'a> = ScopedTypeIdentifier<'a>;
    const KIND: &'static str = "scoped_type_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "scoped_type_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "scoped_type_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `scoped_use_list`

This node has these fields:

- `list`: `use_list` ([`UseList`])
- `path`: `{crate | identifier | metavariable | scoped_identifier | self | super}?` ([`Crate`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ScopedUseList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ScopedUseList<'tree> {
    /**Get the field `list`.

This child has type `use_list` ([`UseList`])*/
    #[inline]
    pub fn list(&self) -> ::type_sitter_lib::NodeResult<'tree, UseList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("list")
            .map(<UseList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `path`.

This child has type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]
*/
    #[inline]
    pub fn path(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                'tree,
            >,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("path")
            .map(
                <anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ScopedUseList<'tree> {
    type WithLifetime<'a> = ScopedUseList<'a>;
    const KIND: &'static str = "scoped_use_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "scoped_use_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "scoped_use_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `self`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Self_<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Self_<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Self_<'tree> {
    type WithLifetime<'a> = Self_<'a>;
    const KIND: &'static str = "self";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "self" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "self");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `self_parameter`

This node has named children of type `{lifetime | mutable_specifier | self}+`:

- [`Lifetime`]
- [`MutableSpecifier`]
- [`Self_`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SelfParameter<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SelfParameter<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for SelfParameter<'tree> {
    type Child = anon_unions::Lifetime_MutableSpecifier_Self_<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SelfParameter<'tree> {
    type WithLifetime<'a> = SelfParameter<'a>;
    const KIND: &'static str = "self_parameter";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "self_parameter" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "self_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `shebang`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Shebang<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Shebang<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Shebang<'tree> {
    type WithLifetime<'a> = Shebang<'a>;
    const KIND: &'static str = "shebang";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "shebang" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "shebang");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `shorthand_field_identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ShorthandFieldIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ShorthandFieldIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ShorthandFieldIdentifier<'tree> {
    type WithLifetime<'a> = ShorthandFieldIdentifier<'a>;
    const KIND: &'static str = "shorthand_field_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "shorthand_field_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "shorthand_field_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `shorthand_field_initializer`

This node has named children of type `{attribute_item | identifier}+`:

- [`AttributeItem`]
- [`Identifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct ShorthandFieldInitializer<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> ShorthandFieldInitializer<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for ShorthandFieldInitializer<'tree> {
    type Child = anon_unions::AttributeItem_Identifier<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for ShorthandFieldInitializer<'tree> {
    type WithLifetime<'a> = ShorthandFieldInitializer<'a>;
    const KIND: &'static str = "shorthand_field_initializer";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "shorthand_field_initializer" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "shorthand_field_initializer");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `slice_pattern`

This node has named children of type `_pattern*` ([`Pattern`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SlicePattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SlicePattern<'tree> {
    /**Get the node's not-extra named children.

These children have type `_pattern*` ([`Pattern`])*/
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for SlicePattern<'tree> {
    type Child = Pattern<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SlicePattern<'tree> {
    type WithLifetime<'a> = SlicePattern<'a>;
    const KIND: &'static str = "slice_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "slice_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "slice_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `source_file`

This node has named children of type `{_declaration_statement | expression_statement | shebang}*`:

- [`DeclarationStatement`]
- [`ExpressionStatement`]
- [`Shebang`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct SourceFile<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> SourceFile<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for SourceFile<'tree> {
    type Child = anon_unions::DeclarationStatement_ExpressionStatement_Shebang<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for SourceFile<'tree> {
    type WithLifetime<'a> = SourceFile<'a>;
    const KIND: &'static str = "source_file";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "source_file" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "source_file");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `static_item`

This node has these fields:

- `name`: `identifier` ([`Identifier`])
- `type`: `_type` ([`Type`])
- `value`: `_expression?` ([`Expression`])

And additional named children of type `{mutable_specifier | visibility_modifier}*`:

- [`MutableSpecifier`]
- [`VisibilityModifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StaticItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StaticItem<'tree> {
    /**Get the field `name`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `value`.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn value(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{mutable_specifier | visibility_modifier}*`:

- [`MutableSpecifier`]
- [`VisibilityModifier`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::MutableSpecifier_VisibilityModifier<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::MutableSpecifier_VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StaticItem<'tree> {
    type WithLifetime<'a> = StaticItem<'a>;
    const KIND: &'static str = "static_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "static_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "static_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `string_content`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StringContent<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StringContent<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StringContent<'tree> {
    type WithLifetime<'a> = StringContent<'a>;
    const KIND: &'static str = "string_content";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "string_content" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "string_content");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `string_literal`

This node has named children of type `{escape_sequence | string_content}*`:

- [`EscapeSequence`]
- [`StringContent`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StringLiteral<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StringLiteral<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for StringLiteral<'tree> {
    type Child = anon_unions::EscapeSequence_StringContent<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StringLiteral<'tree> {
    type WithLifetime<'a> = StringLiteral<'a>;
    const KIND: &'static str = "string_literal";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "string_literal" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "string_literal");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `struct_expression`

This node has these fields:

- `body`: `field_initializer_list` ([`FieldInitializerList`])
- `name`: `{generic_type_with_turbofish | scoped_type_identifier | type_identifier}` ([`GenericTypeWithTurbofish`] | [`ScopedTypeIdentifier`] | [`TypeIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StructExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StructExpression<'tree> {
    /**Get the field `body`.

This child has type `field_initializer_list` ([`FieldInitializerList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, FieldInitializerList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <FieldInitializerList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `name`.

This child has type `{generic_type_with_turbofish | scoped_type_identifier | type_identifier}`:

- [`GenericTypeWithTurbofish`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn name(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(
                <anon_unions::GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StructExpression<'tree> {
    type WithLifetime<'a> = StructExpression<'a>;
    const KIND: &'static str = "struct_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "struct_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "struct_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `struct_item`

This node has these fields:

- `body`: `{field_declaration_list | ordered_field_declaration_list}?` ([`FieldDeclarationList`] | [`OrderedFieldDeclarationList`])
- `name`: `type_identifier` ([`TypeIdentifier`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And additional named children of type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StructItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StructItem<'tree> {
    /**Get the optional field `body`.

This child has type `{field_declaration_list | ordered_field_declaration_list}?`:

- [`FieldDeclarationList`]
- [`OrderedFieldDeclarationList`]
*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::FieldDeclarationList_OrderedFieldDeclarationList<'tree>,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <anon_unions::FieldDeclarationList_OrderedFieldDeclarationList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::VisibilityModifier_WhereClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StructItem<'tree> {
    type WithLifetime<'a> = StructItem<'a>;
    const KIND: &'static str = "struct_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "struct_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "struct_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `struct_pattern`

This node has these fields:

- `type`: `{scoped_type_identifier | type_identifier}` ([`ScopedTypeIdentifier`] | [`TypeIdentifier`])

And additional named children of type `{field_pattern | remaining_field_pattern}*`:

- [`FieldPattern`]
- [`RemainingFieldPattern`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct StructPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> StructPattern<'tree> {
    /**Get the field `type`.

This child has type `{scoped_type_identifier | type_identifier}`:

- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ScopedTypeIdentifier_TypeIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(
                <anon_unions::ScopedTypeIdentifier_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `{field_pattern | remaining_field_pattern}*`:

- [`FieldPattern`]
- [`RemainingFieldPattern`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::FieldPattern_RemainingFieldPattern<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::FieldPattern_RemainingFieldPattern<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for StructPattern<'tree> {
    type WithLifetime<'a> = StructPattern<'a>;
    const KIND: &'static str = "struct_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "struct_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "struct_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `super`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct Super<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> Super<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for Super<'tree> {
    type WithLifetime<'a> = Super<'a>;
    const KIND: &'static str = "super";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "super" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "super");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `token_binding_pattern`

This node has these fields:

- `name`: `metavariable` ([`Metavariable`])
- `type`: `fragment_specifier` ([`FragmentSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenBindingPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenBindingPattern<'tree> {
    /**Get the field `name`.

This child has type `metavariable` ([`Metavariable`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, Metavariable<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<Metavariable<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `fragment_specifier` ([`FragmentSpecifier`])*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, FragmentSpecifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(
                <FragmentSpecifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TokenBindingPattern<'tree> {
    type WithLifetime<'a> = TokenBindingPattern<'a>;
    const KIND: &'static str = "token_binding_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "token_binding_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_binding_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `token_repetition`

This node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}*`:

- [`Literal`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`MutableSpecifier`]
- [`PrimitiveType`]
- [`Self_`]
- [`Super`]
- [`TokenRepetition`]
- [`TokenTree`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenRepetition<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenRepetition<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TokenRepetition<'tree> {
    type Child = anon_unions::Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TokenRepetition<'tree> {
    type WithLifetime<'a> = TokenRepetition<'a>;
    const KIND: &'static str = "token_repetition";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "token_repetition" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_repetition");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `token_repetition_pattern`

This node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}*`:

- [`Literal`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`MutableSpecifier`]
- [`PrimitiveType`]
- [`Self_`]
- [`Super`]
- [`TokenBindingPattern`]
- [`TokenRepetitionPattern`]
- [`TokenTreePattern`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenRepetitionPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenRepetitionPattern<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TokenRepetitionPattern<'tree> {
    type Child = anon_unions::Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TokenRepetitionPattern<'tree> {
    type WithLifetime<'a> = TokenRepetitionPattern<'a>;
    const KIND: &'static str = "token_repetition_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "token_repetition_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_repetition_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `token_tree`

This node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}*`:

- [`Literal`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`MutableSpecifier`]
- [`PrimitiveType`]
- [`Self_`]
- [`Super`]
- [`TokenRepetition`]
- [`TokenTree`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenTree<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenTree<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TokenTree<'tree> {
    type Child = anon_unions::Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TokenTree<'tree> {
    type WithLifetime<'a> = TokenTree<'a>;
    const KIND: &'static str = "token_tree";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "token_tree" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_tree");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `token_tree_pattern`

This node has named children of type `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}*`:

- [`Literal`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`MutableSpecifier`]
- [`PrimitiveType`]
- [`Self_`]
- [`Super`]
- [`TokenBindingPattern`]
- [`TokenRepetitionPattern`]
- [`TokenTreePattern`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TokenTreePattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TokenTreePattern<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TokenTreePattern<'tree> {
    type Child = anon_unions::Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TokenTreePattern<'tree> {
    type WithLifetime<'a> = TokenTreePattern<'a>;
    const KIND: &'static str = "token_tree_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "token_tree_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "token_tree_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `trait_bounds`

This node has named children of type `{_type | higher_ranked_trait_bound | lifetime}+`:

- [`Type`]
- [`HigherRankedTraitBound`]
- [`Lifetime`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TraitBounds<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TraitBounds<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TraitBounds<'tree> {
    type Child = anon_unions::Type_HigherRankedTraitBound_Lifetime<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TraitBounds<'tree> {
    type WithLifetime<'a> = TraitBounds<'a>;
    const KIND: &'static str = "trait_bounds";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "trait_bounds" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "trait_bounds");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `trait_item`

This node has these fields:

- `body`: `declaration_list` ([`DeclarationList`])
- `bounds`: `trait_bounds?` ([`TraitBounds`])
- `name`: `type_identifier` ([`TypeIdentifier`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And additional named children of type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TraitItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TraitItem<'tree> {
    /**Get the field `body`.

This child has type `declaration_list` ([`DeclarationList`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, DeclarationList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <DeclarationList<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `bounds`.

This child has type `trait_bounds?` ([`TraitBounds`])*/
    #[inline]
    pub fn bounds(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TraitBounds<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::VisibilityModifier_WhereClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TraitItem<'tree> {
    type WithLifetime<'a> = TraitItem<'a>;
    const KIND: &'static str = "trait_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "trait_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "trait_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `try_block`

This node has a named child of type `block` ([`Block`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TryBlock<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TryBlock<'tree> {
    /**Get the node's only not-extra named child.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn block(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for TryBlock<'tree> {
    type Child = Block<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TryBlock<'tree> {
    type WithLifetime<'a> = TryBlock<'a>;
    const KIND: &'static str = "try_block";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "try_block" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "try_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `try_expression`

This node has a named child of type `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TryExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TryExpression<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for TryExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TryExpression<'tree> {
    type WithLifetime<'a> = TryExpression<'a>;
    const KIND: &'static str = "try_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "try_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "try_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `tuple_expression`

This node has named children of type `{_expression | attribute_item}+`:

- [`Expression`]
- [`AttributeItem`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TupleExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TupleExpression<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TupleExpression<'tree> {
    type Child = anon_unions::Expression_AttributeItem<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TupleExpression<'tree> {
    type WithLifetime<'a> = TupleExpression<'a>;
    const KIND: &'static str = "tuple_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "tuple_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `tuple_pattern`

This node has named children of type `{_pattern | closure_expression}*`:

- [`Pattern`]
- [`ClosureExpression`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TuplePattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TuplePattern<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TuplePattern<'tree> {
    type Child = anon_unions::Pattern_ClosureExpression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TuplePattern<'tree> {
    type WithLifetime<'a> = TuplePattern<'a>;
    const KIND: &'static str = "tuple_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "tuple_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `tuple_struct_pattern`

This node has these fields:

- `type`: `{generic_type | identifier | scoped_identifier}` ([`GenericType`] | [`Identifier`] | [`ScopedIdentifier`])

And additional named children of type `_pattern*` ([`Pattern`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TupleStructPattern<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TupleStructPattern<'tree> {
    /**Get the field `type`.

This child has type `{generic_type | identifier | scoped_identifier}`:

- [`GenericType`]
- [`Identifier`]
- [`ScopedIdentifier`]
*/
    #[inline]
    pub fn r#type(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::GenericType_Identifier_ScopedIdentifier<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(
                <anon_unions::GenericType_Identifier_ScopedIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's non-field not-extra named children.

These children have type `_pattern*` ([`Pattern`])*/
    #[inline]
    pub fn patterns<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Pattern<'tree>>,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TupleStructPattern<'tree> {
    type WithLifetime<'a> = TupleStructPattern<'a>;
    const KIND: &'static str = "tuple_struct_pattern";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "tuple_struct_pattern" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_struct_pattern");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `tuple_type`

This node has named children of type `_type+` ([`Type`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TupleType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TupleType<'tree> {
    /**Get the node's not-extra named children.

These children have type `_type+` ([`Type`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn types<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, Type<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TupleType<'tree> {
    type Child = Type<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TupleType<'tree> {
    type WithLifetime<'a> = TupleType<'a>;
    const KIND: &'static str = "tuple_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "tuple_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "tuple_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_arguments`

This node has named children of type `{_literal | _type | block | lifetime | trait_bounds | type_binding}+`:

- [`Literal`]
- [`Type`]
- [`Block`]
- [`Lifetime`]
- [`TraitBounds`]
- [`TypeBinding`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeArguments<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeArguments<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TypeArguments<'tree> {
    type Child = anon_unions::Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeArguments<'tree> {
    type WithLifetime<'a> = TypeArguments<'a>;
    const KIND: &'static str = "type_arguments";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_arguments" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_arguments");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_binding`

This node has these fields:

- `name`: `type_identifier` ([`TypeIdentifier`])
- `type`: `_type` ([`Type`])
- `type_arguments`: `type_arguments?` ([`TypeArguments`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeBinding<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeBinding<'tree> {
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_arguments`.

This child has type `type_arguments?` ([`TypeArguments`])*/
    #[inline]
    pub fn type_arguments(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeArguments<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_arguments")
            .map(<TypeArguments<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeBinding<'tree> {
    type WithLifetime<'a> = TypeBinding<'a>;
    const KIND: &'static str = "type_binding";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_binding" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_binding");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_cast_expression`

This node has these fields:

- `type`: `_type` ([`Type`])
- `value`: `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeCastExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeCastExpression<'tree> {
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `value`.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn value(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("value")
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeCastExpression<'tree> {
    type WithLifetime<'a> = TypeCastExpression<'a>;
    const KIND: &'static str = "type_cast_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_cast_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_cast_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_identifier`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeIdentifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeIdentifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeIdentifier<'tree> {
    type WithLifetime<'a> = TypeIdentifier<'a>;
    const KIND: &'static str = "type_identifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_identifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_identifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_item`

This node has these fields:

- `name`: `type_identifier` ([`TypeIdentifier`])
- `type`: `_type` ([`Type`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And additional named children of type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeItem<'tree> {
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `type`.

This child has type `_type` ([`Type`])*/
    #[inline]
    pub fn r#type(&self) -> ::type_sitter_lib::NodeResult<'tree, Type<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type")
            .map(<Type<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::VisibilityModifier_WhereClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeItem<'tree> {
    type WithLifetime<'a> = TypeItem<'a>;
    const KIND: &'static str = "type_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `type_parameters`

This node has named children of type `{attribute_item | const_parameter | constrained_type_parameter | lifetime | metavariable | optional_type_parameter | type_identifier}+`:

- [`AttributeItem`]
- [`ConstParameter`]
- [`ConstrainedTypeParameter`]
- [`Lifetime`]
- [`Metavariable`]
- [`OptionalTypeParameter`]
- [`TypeIdentifier`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct TypeParameters<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> TypeParameters<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for TypeParameters<'tree> {
    type Child = anon_unions::AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for TypeParameters<'tree> {
    type WithLifetime<'a> = TypeParameters<'a>;
    const KIND: &'static str = "type_parameters";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "type_parameters" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "type_parameters");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `unary_expression`

This node has a named child of type `_expression` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnaryExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnaryExpression<'tree> {
    /**Get the node's only not-extra named child.

This child has type `_expression` ([`Expression`])*/
    #[inline]
    pub fn expression(&self) -> ::type_sitter_lib::NodeResult<'tree, Expression<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for UnaryExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UnaryExpression<'tree> {
    type WithLifetime<'a> = UnaryExpression<'a>;
    const KIND: &'static str = "unary_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "unary_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unary_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `union_item`

This node has these fields:

- `body`: `field_declaration_list` ([`FieldDeclarationList`])
- `name`: `type_identifier` ([`TypeIdentifier`])
- `type_parameters`: `type_parameters?` ([`TypeParameters`])

And additional named children of type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnionItem<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnionItem<'tree> {
    /**Get the field `body`.

This child has type `field_declaration_list` ([`FieldDeclarationList`])*/
    #[inline]
    pub fn body(
        &self,
    ) -> ::type_sitter_lib::NodeResult<'tree, FieldDeclarationList<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(
                <FieldDeclarationList<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `name`.

This child has type `type_identifier` ([`TypeIdentifier`])*/
    #[inline]
    pub fn name(&self) -> ::type_sitter_lib::NodeResult<'tree, TypeIdentifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("name")
            .map(<TypeIdentifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the optional field `type_parameters`.

This child has type `type_parameters?` ([`TypeParameters`])*/
    #[inline]
    pub fn type_parameters(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, TypeParameters<'tree>>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("type_parameters")
            .map(<TypeParameters<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's non-field not-extra named children.

These children have type `{visibility_modifier | where_clause}*`:

- [`VisibilityModifier`]
- [`WhereClause`]
*/
    #[inline]
    pub fn others<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<
            'tree,
            anon_unions::VisibilityModifier_WhereClause<'tree>,
        >,
    > + 'a {
        {
            let me = *::type_sitter_lib::Node::raw(self);
            ::type_sitter_lib::Node::raw(self)
                .named_children(&mut c.0)
                .enumerate()
                .filter(move |(i, n)| {
                    !n.is_extra() && me.field_name_for_named_child(*i as _).is_none()
                })
                .map(|(_, n)| n)
        }
            .map(
                <anon_unions::VisibilityModifier_WhereClause<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UnionItem<'tree> {
    type WithLifetime<'a> = UnionItem<'a>;
    const KIND: &'static str = "union_item";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "union_item" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "union_item");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `unit_expression`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnitExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnitExpression<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UnitExpression<'tree> {
    type WithLifetime<'a> = UnitExpression<'a>;
    const KIND: &'static str = "unit_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "unit_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unit_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `unit_type`

This node has no named children
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnitType<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnitType<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UnitType<'tree> {
    type WithLifetime<'a> = UnitType<'a>;
    const KIND: &'static str = "unit_type";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "unit_type" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unit_type");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `unsafe_block`

This node has a named child of type `block` ([`Block`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UnsafeBlock<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UnsafeBlock<'tree> {
    /**Get the node's only not-extra named child.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn block(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChild<'tree> for UnsafeBlock<'tree> {
    type Child = Block<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UnsafeBlock<'tree> {
    type WithLifetime<'a> = UnsafeBlock<'a>;
    const KIND: &'static str = "unsafe_block";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "unsafe_block" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "unsafe_block");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `use_as_clause`

This node has these fields:

- `alias`: `identifier` ([`Identifier`])
- `path`: `{crate | identifier | metavariable | scoped_identifier | self | super}` ([`Crate`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`Self_`] | [`Super`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseAsClause<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseAsClause<'tree> {
    /**Get the field `alias`.

This child has type `identifier` ([`Identifier`])*/
    #[inline]
    pub fn alias(&self) -> ::type_sitter_lib::NodeResult<'tree, Identifier<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("alias")
            .map(<Identifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `path`.

This child has type `{crate | identifier | metavariable | scoped_identifier | self | super}`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]
*/
    #[inline]
    pub fn path(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("path")
            .map(
                <anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UseAsClause<'tree> {
    type WithLifetime<'a> = UseAsClause<'a>;
    const KIND: &'static str = "use_as_clause";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "use_as_clause" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_as_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `use_declaration`

This node has these fields:

- `argument`: `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}` ([`Crate`] | [`Identifier`] | [`Metavariable`] | [`ScopedIdentifier`] | [`ScopedUseList`] | [`Self_`] | [`Super`] | [`UseAsClause`] | [`UseList`] | [`UseWildcard`])

And an optional additional named child of type `visibility_modifier?` ([`VisibilityModifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseDeclaration<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseDeclaration<'tree> {
    /**Get the field `argument`.

This child has type `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`ScopedUseList`]
- [`Self_`]
- [`Super`]
- [`UseAsClause`]
- [`UseList`]
- [`UseWildcard`]
*/
    #[inline]
    pub fn argument(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("argument")
            .map(
                <anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `visibility_modifier?` ([`VisibilityModifier`])*/
    #[inline]
    pub fn visibility_modifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, VisibilityModifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <VisibilityModifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UseDeclaration<'tree> {
    type WithLifetime<'a> = UseDeclaration<'a>;
    const KIND: &'static str = "use_declaration";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "use_declaration" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_declaration");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `use_list`

This node has named children of type `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}*`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`ScopedUseList`]
- [`Self_`]
- [`Super`]
- [`UseAsClause`]
- [`UseList`]
- [`UseWildcard`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseList<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseList<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for UseList<'tree> {
    type Child = anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UseList<'tree> {
    type WithLifetime<'a> = UseList<'a>;
    const KIND: &'static str = "use_list";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "use_list" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_list");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `use_wildcard`

This node has an optional named child of type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct UseWildcard<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> UseWildcard<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for UseWildcard<'tree> {
    type Child = anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for UseWildcard<'tree> {
    type WithLifetime<'a> = UseWildcard<'a>;
    const KIND: &'static str = "use_wildcard";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "use_wildcard" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "use_wildcard");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `variadic_parameter`

This node has these fields:

- `pattern`: `_pattern?` ([`Pattern`])

And an optional additional named child of type `mutable_specifier?` ([`MutableSpecifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct VariadicParameter<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> VariadicParameter<'tree> {
    /**Get the optional field `pattern`.

This child has type `_pattern?` ([`Pattern`])*/
    #[inline]
    pub fn pattern(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Pattern<'tree>>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("pattern")
            .map(<Pattern<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `mutable_specifier?` ([`MutableSpecifier`])*/
    #[inline]
    pub fn mutable_specifier(
        &self,
    ) -> ::std::option::Option<
        ::type_sitter_lib::NodeResult<'tree, MutableSpecifier<'tree>>,
    > {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(
                <MutableSpecifier<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for VariadicParameter<'tree> {
    type WithLifetime<'a> = VariadicParameter<'a>;
    const KIND: &'static str = "variadic_parameter";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "variadic_parameter" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "variadic_parameter");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `visibility_modifier`

This node has an optional named child of type `{crate | identifier | metavariable | scoped_identifier | self | super}?`:

- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]

*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct VisibilityModifier<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> VisibilityModifier<'tree> {}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for VisibilityModifier<'tree> {
    type Child = anon_unions::Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    >;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for VisibilityModifier<'tree> {
    type WithLifetime<'a> = VisibilityModifier<'a>;
    const KIND: &'static str = "visibility_modifier";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "visibility_modifier" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "visibility_modifier");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `where_clause`

This node has named children of type `where_predicate+` ([`WherePredicate`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct WhereClause<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> WhereClause<'tree> {
    /**Get the node's not-extra named children.

These children have type `where_predicate+` ([`WherePredicate`])*/
    /**

This is guaranteed to return at least one child.*/
    #[inline]
    pub fn where_predicates<'a>(
        &self,
        c: &'a mut ::type_sitter_lib::TreeCursor<'tree>,
    ) -> impl ::std::iter::Iterator<
        Item = ::type_sitter_lib::NodeResult<'tree, WherePredicate<'tree>>,
    > + 'a {
        ::type_sitter_lib::Node::raw(self)
            .named_children(&mut c.0)
            .filter(|n| !n.is_extra())
            .map(<WherePredicate<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasChildren<'tree> for WhereClause<'tree> {
    type Child = WherePredicate<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for WhereClause<'tree> {
    type WithLifetime<'a> = WhereClause<'a>;
    const KIND: &'static str = "where_clause";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "where_clause" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "where_clause");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `where_predicate`

This node has these fields:

- `bounds`: `trait_bounds` ([`TraitBounds`])
- `left`: `{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}` ([`ArrayType`] | [`GenericType`] | [`HigherRankedTraitBound`] | [`Lifetime`] | [`PointerType`] | [`PrimitiveType`] | [`ReferenceType`] | [`ScopedTypeIdentifier`] | [`TupleType`] | [`TypeIdentifier`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct WherePredicate<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> WherePredicate<'tree> {
    /**Get the field `bounds`.

This child has type `trait_bounds` ([`TraitBounds`])*/
    #[inline]
    pub fn bounds(&self) -> ::type_sitter_lib::NodeResult<'tree, TraitBounds<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("bounds")
            .map(<TraitBounds<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `left`.

This child has type `{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}`:

- [`ArrayType`]
- [`GenericType`]
- [`HigherRankedTraitBound`]
- [`Lifetime`]
- [`PointerType`]
- [`PrimitiveType`]
- [`ReferenceType`]
- [`ScopedTypeIdentifier`]
- [`TupleType`]
- [`TypeIdentifier`]
*/
    #[inline]
    pub fn left(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier<
            'tree,
        >,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("left")
            .map(
                <anon_unions::ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for WherePredicate<'tree> {
    type WithLifetime<'a> = WherePredicate<'a>;
    const KIND: &'static str = "where_predicate";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "where_predicate" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "where_predicate");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `while_expression`

This node has these fields:

- `body`: `block` ([`Block`])
- `condition`: `{_expression | let_chain | let_condition}` ([`Expression`] | [`LetChain`] | [`LetCondition`])

And an optional additional named child of type `label?` ([`Label`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct WhileExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> WhileExpression<'tree> {
    /**Get the field `body`.

This child has type `block` ([`Block`])*/
    #[inline]
    pub fn body(&self) -> ::type_sitter_lib::NodeResult<'tree, Block<'tree>> {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("body")
            .map(<Block<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the field `condition`.

This child has type `{_expression | let_chain | let_condition}`:

- [`Expression`]
- [`LetChain`]
- [`LetCondition`]
*/
    #[inline]
    pub fn condition(
        &self,
    ) -> ::type_sitter_lib::NodeResult<
        'tree,
        anon_unions::Expression_LetChain_LetCondition<'tree>,
    > {
        ::type_sitter_lib::Node::raw(self)
            .child_by_field_name("condition")
            .map(
                <anon_unions::Expression_LetChain_LetCondition<
                    'tree,
                > as ::type_sitter_lib::Node<'tree>>::try_from_raw,
            )
            .expect(
                "required child not present, there should at least be a MISSING node in its place",
            )
    }
    /**Get the node's only non-field not-extra named child, if it has one.

This child has type `label?` ([`Label`])*/
    #[inline]
    pub fn label(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Label<'tree>>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .filter(|i| {
                ::type_sitter_lib::Node::raw(self)
                    .field_name_for_named_child(*i as _)
                    .is_none()
            })
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Label<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for WhileExpression<'tree> {
    type WithLifetime<'a> = WhileExpression<'a>;
    const KIND: &'static str = "while_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "while_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "while_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
/**Typed node `yield_expression`

This node has an optional named child of type `_expression?` ([`Expression`])
*/
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
#[allow(non_camel_case_types)]
pub struct YieldExpression<'tree>(::yak_sitter::Node<'tree>);
#[automatically_derived]
#[allow(unused)]
impl<'tree> YieldExpression<'tree> {
    /**Get the node's only not-extra named child, if it has one.

This child has type `_expression?` ([`Expression`])*/
    #[inline]
    pub fn expression(
        &self,
    ) -> ::std::option::Option<::type_sitter_lib::NodeResult<'tree, Expression<'tree>>> {
        (0..::type_sitter_lib::Node::raw(self).named_child_count())
            .map(|i| ::type_sitter_lib::Node::raw(self).named_child(i).unwrap())
            .filter(|n| !n.is_extra())
            .next()
            .map(<Expression<'tree> as ::type_sitter_lib::Node<'tree>>::try_from_raw)
    }
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::HasOptionalChild<'tree> for YieldExpression<'tree> {
    type Child = Expression<'tree>;
}
#[automatically_derived]
impl<'tree> ::type_sitter_lib::Node<'tree> for YieldExpression<'tree> {
    type WithLifetime<'a> = YieldExpression<'a>;
    const KIND: &'static str = "yield_expression";
    #[inline]
    fn try_from_raw(
        node: ::yak_sitter::Node<'tree>,
    ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
        if node.kind() == "yield_expression" {
            Ok(Self(node))
        } else {
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
    }
    #[inline]
    unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
        debug_assert_eq!(node.kind(), "yield_expression");
        Self(node)
    }
    #[inline]
    fn raw(&self) -> &::yak_sitter::Node<'tree> {
        &self.0
    }
    #[inline]
    fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
        &mut self.0
    }
    #[inline]
    fn into_raw(self) -> ::yak_sitter::Node<'tree> {
        self.0
    }
}
pub mod unnamed {
    #[allow(unused_imports)]
    use super::*;
    /**Typed node `as`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct As<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> As<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for As<'tree> {
        type WithLifetime<'a> = As<'a>;
        const KIND: &'static str = "as";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "as" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "as");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `async`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Async<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Async<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Async<'tree> {
        type WithLifetime<'a> = Async<'a>;
        const KIND: &'static str = "async";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "async" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "async");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `await`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Await<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Await<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Await<'tree> {
        type WithLifetime<'a> = Await<'a>;
        const KIND: &'static str = "await";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "await" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "await");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `block`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Block<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Block<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Block<'tree> {
        type WithLifetime<'a> = Block<'a>;
        const KIND: &'static str = "block";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "block" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "block");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `break`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Break<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Break<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Break<'tree> {
        type WithLifetime<'a> = Break<'a>;
        const KIND: &'static str = "break";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "break" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "break");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `const`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Const<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Const<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Const<'tree> {
        type WithLifetime<'a> = Const<'a>;
        const KIND: &'static str = "const";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "const" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "const");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `continue`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Continue<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Continue<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Continue<'tree> {
        type WithLifetime<'a> = Continue<'a>;
        const KIND: &'static str = "continue";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "continue" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "continue");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `default`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Default<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Default<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Default<'tree> {
        type WithLifetime<'a> = Default<'a>;
        const KIND: &'static str = "default";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "default" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "default");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `dyn`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Dyn<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Dyn<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Dyn<'tree> {
        type WithLifetime<'a> = Dyn<'a>;
        const KIND: &'static str = "dyn";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "dyn" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "dyn");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `else`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Else<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Else<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Else<'tree> {
        type WithLifetime<'a> = Else<'a>;
        const KIND: &'static str = "else";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "else" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "else");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `enum`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Enum<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Enum<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Enum<'tree> {
        type WithLifetime<'a> = Enum<'a>;
        const KIND: &'static str = "enum";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "enum" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "enum");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `expr`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Expr<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expr<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Expr<'tree> {
        type WithLifetime<'a> = Expr<'a>;
        const KIND: &'static str = "expr";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "expr" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "expr");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `extern`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Extern<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Extern<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Extern<'tree> {
        type WithLifetime<'a> = Extern<'a>;
        const KIND: &'static str = "extern";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "extern" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "extern");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `false`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct False<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> False<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for False<'tree> {
        type WithLifetime<'a> = False<'a>;
        const KIND: &'static str = "false";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "false" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "false");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `fn`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Fn<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Fn<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Fn<'tree> {
        type WithLifetime<'a> = Fn<'a>;
        const KIND: &'static str = "fn";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "fn" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "fn");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `for`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct For<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> For<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for For<'tree> {
        type WithLifetime<'a> = For<'a>;
        const KIND: &'static str = "for";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "for" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "for");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `gen`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Gen<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Gen<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Gen<'tree> {
        type WithLifetime<'a> = Gen<'a>;
        const KIND: &'static str = "gen";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "gen" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "gen");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `ident`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Ident<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Ident<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Ident<'tree> {
        type WithLifetime<'a> = Ident<'a>;
        const KIND: &'static str = "ident";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "ident" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "ident");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `if`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct If<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> If<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for If<'tree> {
        type WithLifetime<'a> = If<'a>;
        const KIND: &'static str = "if";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "if" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "if");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `impl`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Impl<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Impl<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Impl<'tree> {
        type WithLifetime<'a> = Impl<'a>;
        const KIND: &'static str = "impl";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "impl" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "impl");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `in`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct In<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> In<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for In<'tree> {
        type WithLifetime<'a> = In<'a>;
        const KIND: &'static str = "in";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "in" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "in");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `item`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Item<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Item<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Item<'tree> {
        type WithLifetime<'a> = Item<'a>;
        const KIND: &'static str = "item";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "item" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "item");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `let`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Let<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Let<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Let<'tree> {
        type WithLifetime<'a> = Let<'a>;
        const KIND: &'static str = "let";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "let" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "let");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `lifetime`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Lifetime<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Lifetime<'tree> {
        type WithLifetime<'a> = Lifetime<'a>;
        const KIND: &'static str = "lifetime";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "lifetime" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "lifetime");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `literal`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Literal<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Literal<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Literal<'tree> {
        type WithLifetime<'a> = Literal<'a>;
        const KIND: &'static str = "literal";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "literal" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "literal");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `loop`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Loop<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Loop<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Loop<'tree> {
        type WithLifetime<'a> = Loop<'a>;
        const KIND: &'static str = "loop";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "loop" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "loop");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `match`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Match<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Match<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Match<'tree> {
        type WithLifetime<'a> = Match<'a>;
        const KIND: &'static str = "match";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "match" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "match");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `meta`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Meta<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Meta<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Meta<'tree> {
        type WithLifetime<'a> = Meta<'a>;
        const KIND: &'static str = "meta";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "meta" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "meta");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `mod`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mod<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mod<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Mod<'tree> {
        type WithLifetime<'a> = Mod<'a>;
        const KIND: &'static str = "mod";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "mod" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "mod");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `move`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Move<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Move<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Move<'tree> {
        type WithLifetime<'a> = Move<'a>;
        const KIND: &'static str = "move";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "move" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "move");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `pat`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Pat<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pat<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Pat<'tree> {
        type WithLifetime<'a> = Pat<'a>;
        const KIND: &'static str = "pat";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "pat" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "pat");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `path`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Path<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Path<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Path<'tree> {
        type WithLifetime<'a> = Path<'a>;
        const KIND: &'static str = "path";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "path" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "path");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `pub`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Pub<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pub<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Pub<'tree> {
        type WithLifetime<'a> = Pub<'a>;
        const KIND: &'static str = "pub";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "pub" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "pub");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `raw`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Raw<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Raw<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Raw<'tree> {
        type WithLifetime<'a> = Raw<'a>;
        const KIND: &'static str = "raw";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "raw" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "raw");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `ref`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Ref<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Ref<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Ref<'tree> {
        type WithLifetime<'a> = Ref<'a>;
        const KIND: &'static str = "ref";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "ref" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "ref");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `return`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Return<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Return<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Return<'tree> {
        type WithLifetime<'a> = Return<'a>;
        const KIND: &'static str = "return";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "return" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "return");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `static`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Static<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Static<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Static<'tree> {
        type WithLifetime<'a> = Static<'a>;
        const KIND: &'static str = "static";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "static" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "static");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `stmt`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Stmt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Stmt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Stmt<'tree> {
        type WithLifetime<'a> = Stmt<'a>;
        const KIND: &'static str = "stmt";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "stmt" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "stmt");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `struct`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Struct<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Struct<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Struct<'tree> {
        type WithLifetime<'a> = Struct<'a>;
        const KIND: &'static str = "struct";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "struct" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "struct");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `trait`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Trait<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Trait<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Trait<'tree> {
        type WithLifetime<'a> = Trait<'a>;
        const KIND: &'static str = "trait";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "trait" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "trait");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `true`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct True<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> True<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for True<'tree> {
        type WithLifetime<'a> = True<'a>;
        const KIND: &'static str = "true";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "true" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "true");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `try`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Try<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Try<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Try<'tree> {
        type WithLifetime<'a> = Try<'a>;
        const KIND: &'static str = "try";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "try" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "try");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `tt`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Tt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Tt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Tt<'tree> {
        type WithLifetime<'a> = Tt<'a>;
        const KIND: &'static str = "tt";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "tt" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "tt");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `ty`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Ty<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Ty<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Ty<'tree> {
        type WithLifetime<'a> = Ty<'a>;
        const KIND: &'static str = "ty";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "ty" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "ty");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `type`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Type<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Type<'tree> {
        type WithLifetime<'a> = Type<'a>;
        const KIND: &'static str = "type";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "type" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "type");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `union`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Union<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Union<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Union<'tree> {
        type WithLifetime<'a> = Union<'a>;
        const KIND: &'static str = "union";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "union" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "union");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `unsafe`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Unsafe<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Unsafe<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Unsafe<'tree> {
        type WithLifetime<'a> = Unsafe<'a>;
        const KIND: &'static str = "unsafe";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "unsafe" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "unsafe");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `use`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Use<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Use<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Use<'tree> {
        type WithLifetime<'a> = Use<'a>;
        const KIND: &'static str = "use";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "use" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "use");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `vis`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Vis<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Vis<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Vis<'tree> {
        type WithLifetime<'a> = Vis<'a>;
        const KIND: &'static str = "vis";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "vis" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "vis");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `where`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Where<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Where<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Where<'tree> {
        type WithLifetime<'a> = Where<'a>;
        const KIND: &'static str = "where";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "where" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "where");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `while`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct While<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> While<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for While<'tree> {
        type WithLifetime<'a> = While<'a>;
        const KIND: &'static str = "while";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "while" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "while");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `yield`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Yield<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Yield<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Yield<'tree> {
        type WithLifetime<'a> = Yield<'a>;
        const KIND: &'static str = "yield";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "yield" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "yield");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
}
pub mod symbols {
    #[allow(unused_imports)]
    use super::*;
    /**Typed node `!`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Not<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Not<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Not<'tree> {
        type WithLifetime<'a> = Not<'a>;
        const KIND: &'static str = "!";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "!" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "!");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `!=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct NotEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> NotEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for NotEq<'tree> {
        type WithLifetime<'a> = NotEq<'a>;
        const KIND: &'static str = "!=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "!=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "!=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `"`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DoubleQuote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DoubleQuote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DoubleQuote<'tree> {
        type WithLifetime<'a> = DoubleQuote<'a>;
        const KIND: &'static str = "\"";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "\"" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "\"");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `#`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Hash<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Hash<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Hash<'tree> {
        type WithLifetime<'a> = Hash<'a>;
        const KIND: &'static str = "#";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "#" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "#");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `$`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Dollar<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Dollar<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Dollar<'tree> {
        type WithLifetime<'a> = Dollar<'a>;
        const KIND: &'static str = "$";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "$" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "$");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `%`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mod<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mod<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Mod<'tree> {
        type WithLifetime<'a> = Mod<'a>;
        const KIND: &'static str = "%";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "%" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "%");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `%=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct ModEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ModEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for ModEq<'tree> {
        type WithLifetime<'a> = ModEq<'a>;
        const KIND: &'static str = "%=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "%=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "%=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `&`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct And<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> And<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for And<'tree> {
        type WithLifetime<'a> = And<'a>;
        const KIND: &'static str = "&";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "&" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `&&`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AndAnd<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AndAnd<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AndAnd<'tree> {
        type WithLifetime<'a> = AndAnd<'a>;
        const KIND: &'static str = "&&";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "&&" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&&");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `&=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AndEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AndEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AndEq<'tree> {
        type WithLifetime<'a> = AndEq<'a>;
        const KIND: &'static str = "&=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "&=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "&=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `'`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Quote<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Quote<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Quote<'tree> {
        type WithLifetime<'a> = Quote<'a>;
        const KIND: &'static str = "'";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "'" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "'");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `(`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LParen<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LParen<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LParen<'tree> {
        type WithLifetime<'a> = LParen<'a>;
        const KIND: &'static str = "(";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "(" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "(");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `)`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RParen<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RParen<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for RParen<'tree> {
        type WithLifetime<'a> = RParen<'a>;
        const KIND: &'static str = ")";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ")" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ")");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `*`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Mul<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Mul<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Mul<'tree> {
        type WithLifetime<'a> = Mul<'a>;
        const KIND: &'static str = "*";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "*" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `*/`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct MulDiv<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MulDiv<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for MulDiv<'tree> {
        type WithLifetime<'a> = MulDiv<'a>;
        const KIND: &'static str = "*/";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "*/" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*/");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `*=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct MulEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MulEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for MulEq<'tree> {
        type WithLifetime<'a> = MulEq<'a>;
        const KIND: &'static str = "*=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "*=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "*=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `+`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Add<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Add<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Add<'tree> {
        type WithLifetime<'a> = Add<'a>;
        const KIND: &'static str = "+";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "+" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "+");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `+=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct AddEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AddEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AddEq<'tree> {
        type WithLifetime<'a> = AddEq<'a>;
        const KIND: &'static str = "+=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "+=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "+=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `,`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Comma<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Comma<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Comma<'tree> {
        type WithLifetime<'a> = Comma<'a>;
        const KIND: &'static str = ",";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "," {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ",");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `-`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Sub<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Sub<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Sub<'tree> {
        type WithLifetime<'a> = Sub<'a>;
        const KIND: &'static str = "-";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "-" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "-");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `-=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct SubEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for SubEq<'tree> {
        type WithLifetime<'a> = SubEq<'a>;
        const KIND: &'static str = "-=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "-=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "-=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `->`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct SubGt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> SubGt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for SubGt<'tree> {
        type WithLifetime<'a> = SubGt<'a>;
        const KIND: &'static str = "->";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "->" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "->");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `.`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Dot<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Dot<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Dot<'tree> {
        type WithLifetime<'a> = Dot<'a>;
        const KIND: &'static str = ".";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "." {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ".");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `..`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DotDot<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DotDot<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DotDot<'tree> {
        type WithLifetime<'a> = DotDot<'a>;
        const KIND: &'static str = "..";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ".." {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "..");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `...`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DotDotDot<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DotDotDot<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DotDotDot<'tree> {
        type WithLifetime<'a> = DotDotDot<'a>;
        const KIND: &'static str = "...";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "..." {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "...");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `..=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DotDotEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DotDotEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DotDotEq<'tree> {
        type WithLifetime<'a> = DotDotEq<'a>;
        const KIND: &'static str = "..=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "..=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "..=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `/`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Div<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Div<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Div<'tree> {
        type WithLifetime<'a> = Div<'a>;
        const KIND: &'static str = "/";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "/" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    #[doc = "Typed node `/*`\n\nThis node has no named children\n"]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DivMul<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DivMul<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DivMul<'tree> {
        type WithLifetime<'a> = DivMul<'a>;
        const KIND: &'static str = "/*";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "/*" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/*");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `//`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DivDiv<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DivDiv<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DivDiv<'tree> {
        type WithLifetime<'a> = DivDiv<'a>;
        const KIND: &'static str = "//";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "//" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "//");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `/=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct DivEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DivEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for DivEq<'tree> {
        type WithLifetime<'a> = DivEq<'a>;
        const KIND: &'static str = "/=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "/=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "/=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `:`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Colon<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Colon<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Colon<'tree> {
        type WithLifetime<'a> = Colon<'a>;
        const KIND: &'static str = ":";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ":" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ":");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `::`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct ColonColon<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ColonColon<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for ColonColon<'tree> {
        type WithLifetime<'a> = ColonColon<'a>;
        const KIND: &'static str = "::";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "::" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "::");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `;`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Semicolon<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Semicolon<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Semicolon<'tree> {
        type WithLifetime<'a> = Semicolon<'a>;
        const KIND: &'static str = ";";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ";" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ";");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Lt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Lt<'tree> {
        type WithLifetime<'a> = Lt<'a>;
        const KIND: &'static str = "<";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<<`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtLt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtLt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LtLt<'tree> {
        type WithLifetime<'a> = LtLt<'a>;
        const KIND: &'static str = "<<";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<<" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<<");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<<=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtLtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtLtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LtLtEq<'tree> {
        type WithLifetime<'a> = LtLtEq<'a>;
        const KIND: &'static str = "<<=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<<=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<<=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `<=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LtEq<'tree> {
        type WithLifetime<'a> = LtEq<'a>;
        const KIND: &'static str = "<=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "<=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "<=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Eq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Eq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Eq<'tree> {
        type WithLifetime<'a> = Eq<'a>;
        const KIND: &'static str = "=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `==`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct EqEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EqEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for EqEq<'tree> {
        type WithLifetime<'a> = EqEq<'a>;
        const KIND: &'static str = "==";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "==" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "==");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `=>`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct EqGt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EqGt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for EqGt<'tree> {
        type WithLifetime<'a> = EqGt<'a>;
        const KIND: &'static str = "=>";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "=>" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "=>");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Gt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Gt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Gt<'tree> {
        type WithLifetime<'a> = Gt<'a>;
        const KIND: &'static str = ">";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for GtEq<'tree> {
        type WithLifetime<'a> = GtEq<'a>;
        const KIND: &'static str = ">=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>>`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtGt<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtGt<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for GtGt<'tree> {
        type WithLifetime<'a> = GtGt<'a>;
        const KIND: &'static str = ">>";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">>" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">>");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `>>=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct GtGtEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GtGtEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for GtGtEq<'tree> {
        type WithLifetime<'a> = GtGtEq<'a>;
        const KIND: &'static str = ">>=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == ">>=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), ">>=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `?`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Question<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Question<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Question<'tree> {
        type WithLifetime<'a> = Question<'a>;
        const KIND: &'static str = "?";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "?" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "?");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `@`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct At<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> At<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for At<'tree> {
        type WithLifetime<'a> = At<'a>;
        const KIND: &'static str = "@";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "@" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "@");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `[`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LBracket<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LBracket<'tree> {
        type WithLifetime<'a> = LBracket<'a>;
        const KIND: &'static str = "[";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "[" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "[");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `]`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RBracket<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RBracket<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for RBracket<'tree> {
        type WithLifetime<'a> = RBracket<'a>;
        const KIND: &'static str = "]";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "]" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "]");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `^`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct BitXor<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BitXor<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for BitXor<'tree> {
        type WithLifetime<'a> = BitXor<'a>;
        const KIND: &'static str = "^";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "^" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "^");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `^=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct BitXorEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BitXorEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for BitXorEq<'tree> {
        type WithLifetime<'a> = BitXorEq<'a>;
        const KIND: &'static str = "^=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "^=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "^=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `_`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct __<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> __<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for __<'tree> {
        type WithLifetime<'a> = __<'a>;
        const KIND: &'static str = "_";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "_" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "_");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `macro_rules!`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct MacroRulesNot<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MacroRulesNot<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for MacroRulesNot<'tree> {
        type WithLifetime<'a> = MacroRulesNot<'a>;
        const KIND: &'static str = "macro_rules!";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "macro_rules!" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "macro_rules!");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `{`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct LBrace<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> LBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for LBrace<'tree> {
        type WithLifetime<'a> = LBrace<'a>;
        const KIND: &'static str = "{";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "{" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "{");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `|`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct Or<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Or<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Or<'tree> {
        type WithLifetime<'a> = Or<'a>;
        const KIND: &'static str = "|";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "|" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "|");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `|=`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct OrEq<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> OrEq<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for OrEq<'tree> {
        type WithLifetime<'a> = OrEq<'a>;
        const KIND: &'static str = "|=";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "|=" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "|=");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `||`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct OrOr<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> OrOr<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for OrOr<'tree> {
        type WithLifetime<'a> = OrOr<'a>;
        const KIND: &'static str = "||";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "||" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "||");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
    /**Typed node `}`

This node has no named children
*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    #[allow(non_camel_case_types)]
    pub struct RBrace<'tree>(::yak_sitter::Node<'tree>);
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> RBrace<'tree> {}
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for RBrace<'tree> {
        type WithLifetime<'a> = RBrace<'a>;
        const KIND: &'static str = "}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if node.kind() == "}" {
                Ok(Self(node))
            } else {
                Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
            }
        }
        #[inline]
        unsafe fn from_raw_unchecked(node: ::yak_sitter::Node<'tree>) -> Self {
            debug_assert_eq!(node.kind(), "}");
            Self(node)
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            &self.0
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            &mut self.0
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            self.0
        }
    }
}
pub mod anon_unions {
    #[allow(unused_imports)]
    use super::*;
    /**One of `{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}`:
- [`ArrayType`]
- [`GenericType`]
- [`HigherRankedTraitBound`]
- [`Lifetime`]
- [`PointerType`]
- [`PrimitiveType`]
- [`ReferenceType`]
- [`ScopedTypeIdentifier`]
- [`TupleType`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        ArrayType(ArrayType<'tree>),
        GenericType(GenericType<'tree>),
        HigherRankedTraitBound(HigherRankedTraitBound<'tree>),
        Lifetime(Lifetime<'tree>),
        PointerType(PointerType<'tree>),
        PrimitiveType(PrimitiveType<'tree>),
        ReferenceType(ReferenceType<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TupleType(TupleType<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        ///Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`
        #[inline]
        pub fn as_array_type(self) -> ::std::option::Option<ArrayType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ArrayType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `higher_ranked_trait_bound` ([`HigherRankedTraitBound`]), otherwise returns `None`
        #[inline]
        pub fn as_higher_ranked_trait_bound(
            self,
        ) -> ::std::option::Option<HigherRankedTraitBound<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::HigherRankedTraitBound(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`
        #[inline]
        pub fn as_pointer_type(self) -> ::std::option::Option<PointerType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PointerType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PrimitiveType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`
        #[inline]
        pub fn as_reference_type(self) -> ::std::option::Option<ReferenceType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ReferenceType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`
        #[inline]
        pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TupleType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        type WithLifetime<'a> = ArrayType_GenericType_HigherRankedTraitBound_Lifetime_PointerType_PrimitiveType_ReferenceType_ScopedTypeIdentifier_TupleType_TypeIdentifier<
            'a,
        >;
        const KIND: &'static str = "{array_type | generic_type | higher_ranked_trait_bound | lifetime | pointer_type | primitive_type | reference_type | scoped_type_identifier | tuple_type | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <ArrayType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ArrayType(this));
            }
            if let Ok(this) = <GenericType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericType(this));
            }
            if let Ok(this) = <HigherRankedTraitBound<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::HigherRankedTraitBound(this));
            }
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            if let Ok(this) = <PointerType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PointerType(this));
            }
            if let Ok(this) = <PrimitiveType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PrimitiveType(this));
            }
            if let Ok(this) = <ReferenceType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ReferenceType(this));
            }
            if let Ok(this) = <ScopedTypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedTypeIdentifier(this));
            }
            if let Ok(this) = <TupleType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TupleType(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ArrayType(x) => ::type_sitter_lib::Node::raw(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw(x),
                Self::HigherRankedTraitBound(x) => ::type_sitter_lib::Node::raw(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
                Self::PointerType(x) => ::type_sitter_lib::Node::raw(x),
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw(x),
                Self::ReferenceType(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TupleType(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ArrayType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::HigherRankedTraitBound(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PointerType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ReferenceType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TupleType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ArrayType(x) => x.into_raw(),
                Self::GenericType(x) => x.into_raw(),
                Self::HigherRankedTraitBound(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
                Self::PointerType(x) => x.into_raw(),
                Self::PrimitiveType(x) => x.into_raw(),
                Self::ReferenceType(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TupleType(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_item | const_parameter | constrained_type_parameter | lifetime | metavariable | optional_type_parameter | type_identifier}`:
- [`AttributeItem`]
- [`ConstParameter`]
- [`ConstrainedTypeParameter`]
- [`Lifetime`]
- [`Metavariable`]
- [`OptionalTypeParameter`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier<
        'tree,
    > {
        AttributeItem(AttributeItem<'tree>),
        ConstParameter(ConstParameter<'tree>),
        ConstrainedTypeParameter(ConstrainedTypeParameter<'tree>),
        Lifetime(Lifetime<'tree>),
        Metavariable(Metavariable<'tree>),
        OptionalTypeParameter(OptionalTypeParameter<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier<
        'tree,
    > {
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `const_parameter` ([`ConstParameter`]), otherwise returns `None`
        #[inline]
        pub fn as_const_parameter(self) -> ::std::option::Option<ConstParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ConstParameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `constrained_type_parameter` ([`ConstrainedTypeParameter`]), otherwise returns `None`
        #[inline]
        pub fn as_constrained_type_parameter(
            self,
        ) -> ::std::option::Option<ConstrainedTypeParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ConstrainedTypeParameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `optional_type_parameter` ([`OptionalTypeParameter`]), otherwise returns `None`
        #[inline]
        pub fn as_optional_type_parameter(
            self,
        ) -> ::std::option::Option<OptionalTypeParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OptionalTypeParameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier<
        'tree,
    > {
        type WithLifetime<'a> = AttributeItem_ConstParameter_ConstrainedTypeParameter_Lifetime_Metavariable_OptionalTypeParameter_TypeIdentifier<
            'a,
        >;
        const KIND: &'static str = "{attribute_item | const_parameter | constrained_type_parameter | lifetime | metavariable | optional_type_parameter | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <ConstParameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ConstParameter(this));
            }
            if let Ok(this) = <ConstrainedTypeParameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ConstrainedTypeParameter(this));
            }
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <OptionalTypeParameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::OptionalTypeParameter(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
                Self::ConstParameter(x) => ::type_sitter_lib::Node::raw(x),
                Self::ConstrainedTypeParameter(x) => ::type_sitter_lib::Node::raw(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::OptionalTypeParameter(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ConstParameter(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ConstrainedTypeParameter(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::OptionalTypeParameter(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::ConstParameter(x) => x.into_raw(),
                Self::ConstrainedTypeParameter(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::OptionalTypeParameter(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_item | enum_variant}`:
- [`AttributeItem`]
- [`EnumVariant`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_EnumVariant<'tree> {
        AttributeItem(AttributeItem<'tree>),
        EnumVariant(EnumVariant<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_EnumVariant<'tree> {
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `enum_variant` ([`EnumVariant`]), otherwise returns `None`
        #[inline]
        pub fn as_enum_variant(self) -> ::std::option::Option<EnumVariant<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EnumVariant(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AttributeItem_EnumVariant<'tree> {
        type WithLifetime<'a> = AttributeItem_EnumVariant<'a>;
        const KIND: &'static str = "{attribute_item | enum_variant}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <EnumVariant<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::EnumVariant(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
                Self::EnumVariant(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::EnumVariant(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::EnumVariant(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_item | field_declaration}`:
- [`AttributeItem`]
- [`FieldDeclaration`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_FieldDeclaration<'tree> {
        AttributeItem(AttributeItem<'tree>),
        FieldDeclaration(FieldDeclaration<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_FieldDeclaration<'tree> {
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `field_declaration` ([`FieldDeclaration`]), otherwise returns `None`
        #[inline]
        pub fn as_field_declaration(
            self,
        ) -> ::std::option::Option<FieldDeclaration<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclaration(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeItem_FieldDeclaration<'tree> {
        type WithLifetime<'a> = AttributeItem_FieldDeclaration<'a>;
        const KIND: &'static str = "{attribute_item | field_declaration}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <FieldDeclaration<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldDeclaration(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldDeclaration(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldDeclaration(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::FieldDeclaration(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_item | identifier}`:
- [`AttributeItem`]
- [`Identifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_Identifier<'tree> {
        AttributeItem(AttributeItem<'tree>),
        Identifier(Identifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_Identifier<'tree> {
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for AttributeItem_Identifier<'tree> {
        type WithLifetime<'a> = AttributeItem_Identifier<'a>;
        const KIND: &'static str = "{attribute_item | identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_item | inner_attribute_item}`:
- [`AttributeItem`]
- [`InnerAttributeItem`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_InnerAttributeItem<'tree> {
        AttributeItem(AttributeItem<'tree>),
        InnerAttributeItem(InnerAttributeItem<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_InnerAttributeItem<'tree> {
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_inner_attribute_item(
            self,
        ) -> ::std::option::Option<InnerAttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::InnerAttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeItem_InnerAttributeItem<'tree> {
        type WithLifetime<'a> = AttributeItem_InnerAttributeItem<'a>;
        const KIND: &'static str = "{attribute_item | inner_attribute_item}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <InnerAttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::InnerAttributeItem(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
                Self::InnerAttributeItem(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::InnerAttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::InnerAttributeItem(x) => x.into_raw(),
            }
        }
    }
    /**One of `{attribute_item | visibility_modifier}`:
- [`AttributeItem`]
- [`VisibilityModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum AttributeItem_VisibilityModifier<'tree> {
        AttributeItem(AttributeItem<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> AttributeItem_VisibilityModifier<'tree> {
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_visibility_modifier(
            self,
        ) -> ::std::option::Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for AttributeItem_VisibilityModifier<'tree> {
        type WithLifetime<'a> = AttributeItem_VisibilityModifier<'a>;
        const KIND: &'static str = "{attribute_item | visibility_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <VisibilityModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::VisibilityModifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::AttributeItem(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{base_field_initializer | field_initializer | shorthand_field_initializer}`:
- [`BaseFieldInitializer`]
- [`FieldInitializer`]
- [`ShorthandFieldInitializer`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'tree> {
        BaseFieldInitializer(BaseFieldInitializer<'tree>),
        FieldInitializer(FieldInitializer<'tree>),
        ShorthandFieldInitializer(ShorthandFieldInitializer<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'tree> {
        ///Returns the node if it is of type `base_field_initializer` ([`BaseFieldInitializer`]), otherwise returns `None`
        #[inline]
        pub fn as_base_field_initializer(
            self,
        ) -> ::std::option::Option<BaseFieldInitializer<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BaseFieldInitializer(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `field_initializer` ([`FieldInitializer`]), otherwise returns `None`
        #[inline]
        pub fn as_field_initializer(
            self,
        ) -> ::std::option::Option<FieldInitializer<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldInitializer(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `shorthand_field_initializer` ([`ShorthandFieldInitializer`]), otherwise returns `None`
        #[inline]
        pub fn as_shorthand_field_initializer(
            self,
        ) -> ::std::option::Option<ShorthandFieldInitializer<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ShorthandFieldInitializer(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<'tree> {
        type WithLifetime<'a> = BaseFieldInitializer_FieldInitializer_ShorthandFieldInitializer<
            'a,
        >;
        const KIND: &'static str = "{base_field_initializer | field_initializer | shorthand_field_initializer}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <BaseFieldInitializer<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::BaseFieldInitializer(this));
            }
            if let Ok(this) = <FieldInitializer<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldInitializer(this));
            }
            if let Ok(this) = <ShorthandFieldInitializer<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ShorthandFieldInitializer(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::BaseFieldInitializer(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldInitializer(x) => ::type_sitter_lib::Node::raw(x),
                Self::ShorthandFieldInitializer(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::BaseFieldInitializer(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldInitializer(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ShorthandFieldInitializer(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::BaseFieldInitializer(x) => x.into_raw(),
                Self::FieldInitializer(x) => x.into_raw(),
                Self::ShorthandFieldInitializer(x) => x.into_raw(),
            }
        }
    }
    /**One of `{block | if_expression}`:
- [`Block`]
- [`IfExpression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Block_IfExpression<'tree> {
        Block(Block<'tree>),
        IfExpression(IfExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Block_IfExpression<'tree> {
        ///Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Block(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IfExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Block_IfExpression<'tree> {
        type WithLifetime<'a> = Block_IfExpression<'a>;
        const KIND: &'static str = "{block | if_expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Block<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Block(this));
            }
            if let Ok(this) = <IfExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::IfExpression(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Block(x) => ::type_sitter_lib::Node::raw(x),
                Self::IfExpression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Block(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::IfExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Block(x) => x.into_raw(),
                Self::IfExpression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}`:
- [`BracketedType`]
- [`Crate`]
- [`GenericType`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    > {
        BracketedType(BracketedType<'tree>),
        Crate(Crate<'tree>),
        GenericType(GenericType<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    > {
        ///Returns the node if it is of type `bracketed_type` ([`BracketedType`]), otherwise returns `None`
        #[inline]
        pub fn as_bracketed_type(self) -> ::std::option::Option<BracketedType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BracketedType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`
        #[inline]
        pub fn as_crate(self) -> ::std::option::Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`
        #[inline]
        pub fn as_super(self) -> ::std::option::Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    > {
        type WithLifetime<'a> = BracketedType_Crate_GenericType_Identifier_Metavariable_ScopedIdentifier_Self__Super<
            'a,
        >;
        const KIND: &'static str = "{bracketed_type | crate | generic_type | identifier | metavariable | scoped_identifier | self | super}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <BracketedType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::BracketedType(this));
            }
            if let Ok(this) = <Crate<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <GenericType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericType(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <Super<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::BracketedType(x) => ::type_sitter_lib::Node::raw(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::BracketedType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::BracketedType(x) => x.into_raw(),
                Self::Crate(x) => x.into_raw(),
                Self::GenericType(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    /**One of `{constrained_type_parameter | type_identifier}`:
- [`ConstrainedTypeParameter`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ConstrainedTypeParameter_TypeIdentifier<'tree> {
        ConstrainedTypeParameter(ConstrainedTypeParameter<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ConstrainedTypeParameter_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `constrained_type_parameter` ([`ConstrainedTypeParameter`]), otherwise returns `None`
        #[inline]
        pub fn as_constrained_type_parameter(
            self,
        ) -> ::std::option::Option<ConstrainedTypeParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ConstrainedTypeParameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ConstrainedTypeParameter_TypeIdentifier<'tree> {
        type WithLifetime<'a> = ConstrainedTypeParameter_TypeIdentifier<'a>;
        const KIND: &'static str = "{constrained_type_parameter | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <ConstrainedTypeParameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ConstrainedTypeParameter(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ConstrainedTypeParameter(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ConstrainedTypeParameter(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ConstrainedTypeParameter(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}`:
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`ScopedUseList`]
- [`Self_`]
- [`Super`]
- [`UseAsClause`]
- [`UseList`]
- [`UseWildcard`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
        'tree,
    > {
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        ScopedUseList(ScopedUseList<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
        UseAsClause(UseAsClause<'tree>),
        UseList(UseList<'tree>),
        UseWildcard(UseWildcard<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
        'tree,
    > {
        ///Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`
        #[inline]
        pub fn as_crate(self) -> ::std::option::Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_use_list` ([`ScopedUseList`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_use_list(self) -> ::std::option::Option<ScopedUseList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedUseList(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`
        #[inline]
        pub fn as_super(self) -> ::std::option::Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `use_as_clause` ([`UseAsClause`]), otherwise returns `None`
        #[inline]
        pub fn as_use_as_clause(self) -> ::std::option::Option<UseAsClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::UseAsClause(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `use_list` ([`UseList`]), otherwise returns `None`
        #[inline]
        pub fn as_use_list(self) -> ::std::option::Option<UseList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::UseList(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `use_wildcard` ([`UseWildcard`]), otherwise returns `None`
        #[inline]
        pub fn as_use_wildcard(self) -> ::std::option::Option<UseWildcard<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::UseWildcard(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
        'tree,
    > {
        type WithLifetime<'a> = Crate_Identifier_Metavariable_ScopedIdentifier_ScopedUseList_Self__Super_UseAsClause_UseList_UseWildcard<
            'a,
        >;
        const KIND: &'static str = "{crate | identifier | metavariable | scoped_identifier | scoped_use_list | self | super | use_as_clause | use_list | use_wildcard}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Crate<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <ScopedUseList<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedUseList(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <Super<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            if let Ok(this) = <UseAsClause<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::UseAsClause(this));
            }
            if let Ok(this) = <UseList<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::UseList(this));
            }
            if let Ok(this) = <UseWildcard<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::UseWildcard(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedUseList(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw(x),
                Self::UseAsClause(x) => ::type_sitter_lib::Node::raw(x),
                Self::UseList(x) => ::type_sitter_lib::Node::raw(x),
                Self::UseWildcard(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedUseList(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::UseAsClause(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::UseList(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::UseWildcard(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::ScopedUseList(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
                Self::UseAsClause(x) => x.into_raw(),
                Self::UseList(x) => x.into_raw(),
                Self::UseWildcard(x) => x.into_raw(),
            }
        }
    }
    /**One of `{crate | identifier | metavariable | scoped_identifier | self | super}`:
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        ///Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`
        #[inline]
        pub fn as_crate(self) -> ::std::option::Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`
        #[inline]
        pub fn as_super(self) -> ::std::option::Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        type WithLifetime<'a> = Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
            'a,
        >;
        const KIND: &'static str = "{crate | identifier | metavariable | scoped_identifier | self | super}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Crate<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <Super<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    /**One of `{crate | visibility_modifier}`:
- [`Crate`]
- [`VisibilityModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Crate_VisibilityModifier<'tree> {
        Crate(Crate<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Crate_VisibilityModifier<'tree> {
        ///Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`
        #[inline]
        pub fn as_crate(self) -> ::std::option::Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_visibility_modifier(
            self,
        ) -> ::std::option::Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Crate_VisibilityModifier<'tree> {
        type WithLifetime<'a> = Crate_VisibilityModifier<'a>;
        const KIND: &'static str = "{crate | visibility_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Crate<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <VisibilityModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::VisibilityModifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => ::type_sitter_lib::Node::raw(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Crate(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_declaration_statement | expression_statement | shebang}`:
- [`DeclarationStatement`]
- [`ExpressionStatement`]
- [`Shebang`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum DeclarationStatement_ExpressionStatement_Shebang<'tree> {
        DeclarationStatement(DeclarationStatement<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
        Shebang(Shebang<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DeclarationStatement_ExpressionStatement_Shebang<'tree> {
        ///Returns the node if it is of type `_declaration_statement` ([`DeclarationStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration_statement(
            self,
        ) -> ::std::option::Option<DeclarationStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DeclarationStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExpressionStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `shebang` ([`Shebang`]), otherwise returns `None`
        #[inline]
        pub fn as_shebang(self) -> ::std::option::Option<Shebang<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Shebang(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `associated_type` ([`AssociatedType`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_associated_type(self) -> ::std::option::Option<AssociatedType<'tree>> {
            self.as_declaration_statement()?.as_associated_type()
        }
        /**Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            self.as_declaration_statement()?.as_attribute_item()
        }
        /**Returns the node if it is of type `const_item` ([`ConstItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_const_item(self) -> ::std::option::Option<ConstItem<'tree>> {
            self.as_declaration_statement()?.as_const_item()
        }
        /**Returns the node if it is of type `empty_statement` ([`EmptyStatement`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_empty_statement(self) -> ::std::option::Option<EmptyStatement<'tree>> {
            self.as_declaration_statement()?.as_empty_statement()
        }
        /**Returns the node if it is of type `enum_item` ([`EnumItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_enum_item(self) -> ::std::option::Option<EnumItem<'tree>> {
            self.as_declaration_statement()?.as_enum_item()
        }
        /**Returns the node if it is of type `extern_crate_declaration` ([`ExternCrateDeclaration`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_extern_crate_declaration(
            self,
        ) -> ::std::option::Option<ExternCrateDeclaration<'tree>> {
            self.as_declaration_statement()?.as_extern_crate_declaration()
        }
        /**Returns the node if it is of type `foreign_mod_item` ([`ForeignModItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_foreign_mod_item(
            self,
        ) -> ::std::option::Option<ForeignModItem<'tree>> {
            self.as_declaration_statement()?.as_foreign_mod_item()
        }
        /**Returns the node if it is of type `function_item` ([`FunctionItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_function_item(self) -> ::std::option::Option<FunctionItem<'tree>> {
            self.as_declaration_statement()?.as_function_item()
        }
        /**Returns the node if it is of type `function_signature_item` ([`FunctionSignatureItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_function_signature_item(
            self,
        ) -> ::std::option::Option<FunctionSignatureItem<'tree>> {
            self.as_declaration_statement()?.as_function_signature_item()
        }
        /**Returns the node if it is of type `impl_item` ([`ImplItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_impl_item(self) -> ::std::option::Option<ImplItem<'tree>> {
            self.as_declaration_statement()?.as_impl_item()
        }
        /**Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_inner_attribute_item(
            self,
        ) -> ::std::option::Option<InnerAttributeItem<'tree>> {
            self.as_declaration_statement()?.as_inner_attribute_item()
        }
        /**Returns the node if it is of type `let_declaration` ([`LetDeclaration`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_let_declaration(self) -> ::std::option::Option<LetDeclaration<'tree>> {
            self.as_declaration_statement()?.as_let_declaration()
        }
        /**Returns the node if it is of type `macro_definition` ([`MacroDefinition`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_macro_definition(
            self,
        ) -> ::std::option::Option<MacroDefinition<'tree>> {
            self.as_declaration_statement()?.as_macro_definition()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_declaration_statement()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `mod_item` ([`ModItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_mod_item(self) -> ::std::option::Option<ModItem<'tree>> {
            self.as_declaration_statement()?.as_mod_item()
        }
        /**Returns the node if it is of type `static_item` ([`StaticItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_static_item(self) -> ::std::option::Option<StaticItem<'tree>> {
            self.as_declaration_statement()?.as_static_item()
        }
        /**Returns the node if it is of type `struct_item` ([`StructItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_struct_item(self) -> ::std::option::Option<StructItem<'tree>> {
            self.as_declaration_statement()?.as_struct_item()
        }
        /**Returns the node if it is of type `trait_item` ([`TraitItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_trait_item(self) -> ::std::option::Option<TraitItem<'tree>> {
            self.as_declaration_statement()?.as_trait_item()
        }
        /**Returns the node if it is of type `type_item` ([`TypeItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_type_item(self) -> ::std::option::Option<TypeItem<'tree>> {
            self.as_declaration_statement()?.as_type_item()
        }
        /**Returns the node if it is of type `union_item` ([`UnionItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_union_item(self) -> ::std::option::Option<UnionItem<'tree>> {
            self.as_declaration_statement()?.as_union_item()
        }
        /**Returns the node if it is of type `use_declaration` ([`UseDeclaration`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_use_declaration(self) -> ::std::option::Option<UseDeclaration<'tree>> {
            self.as_declaration_statement()?.as_use_declaration()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for DeclarationStatement_ExpressionStatement_Shebang<'tree> {
        type WithLifetime<'a> = DeclarationStatement_ExpressionStatement_Shebang<'a>;
        const KIND: &'static str = "{_declaration_statement | expression_statement | shebang}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <DeclarationStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::DeclarationStatement(this));
            }
            if let Ok(this) = <ExpressionStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ExpressionStatement(this));
            }
            if let Ok(this) = <Shebang<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Shebang(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Shebang(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Shebang(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => x.into_raw(),
                Self::ExpressionStatement(x) => x.into_raw(),
                Self::Shebang(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_declaration_statement | _expression | expression_statement | label}`:
- [`DeclarationStatement`]
- [`Expression`]
- [`ExpressionStatement`]
- [`Label`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum DeclarationStatement_Expression_ExpressionStatement_Label<'tree> {
        DeclarationStatement(DeclarationStatement<'tree>),
        Expression(Expression<'tree>),
        ExpressionStatement(ExpressionStatement<'tree>),
        Label(Label<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> DeclarationStatement_Expression_ExpressionStatement_Label<'tree> {
        ///Returns the node if it is of type `_declaration_statement` ([`DeclarationStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_declaration_statement(
            self,
        ) -> ::std::option::Option<DeclarationStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DeclarationStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `expression_statement` ([`ExpressionStatement`]), otherwise returns `None`
        #[inline]
        pub fn as_expression_statement(
            self,
        ) -> ::std::option::Option<ExpressionStatement<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExpressionStatement(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `label` ([`Label`]), otherwise returns `None`
        #[inline]
        pub fn as_label(self) -> ::std::option::Option<Label<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Label(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `associated_type` ([`AssociatedType`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_associated_type(self) -> ::std::option::Option<AssociatedType<'tree>> {
            self.as_declaration_statement()?.as_associated_type()
        }
        /**Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            self.as_declaration_statement()?.as_attribute_item()
        }
        /**Returns the node if it is of type `const_item` ([`ConstItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_const_item(self) -> ::std::option::Option<ConstItem<'tree>> {
            self.as_declaration_statement()?.as_const_item()
        }
        /**Returns the node if it is of type `empty_statement` ([`EmptyStatement`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_empty_statement(self) -> ::std::option::Option<EmptyStatement<'tree>> {
            self.as_declaration_statement()?.as_empty_statement()
        }
        /**Returns the node if it is of type `enum_item` ([`EnumItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_enum_item(self) -> ::std::option::Option<EnumItem<'tree>> {
            self.as_declaration_statement()?.as_enum_item()
        }
        /**Returns the node if it is of type `extern_crate_declaration` ([`ExternCrateDeclaration`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_extern_crate_declaration(
            self,
        ) -> ::std::option::Option<ExternCrateDeclaration<'tree>> {
            self.as_declaration_statement()?.as_extern_crate_declaration()
        }
        /**Returns the node if it is of type `foreign_mod_item` ([`ForeignModItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_foreign_mod_item(
            self,
        ) -> ::std::option::Option<ForeignModItem<'tree>> {
            self.as_declaration_statement()?.as_foreign_mod_item()
        }
        /**Returns the node if it is of type `function_item` ([`FunctionItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_function_item(self) -> ::std::option::Option<FunctionItem<'tree>> {
            self.as_declaration_statement()?.as_function_item()
        }
        /**Returns the node if it is of type `function_signature_item` ([`FunctionSignatureItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_function_signature_item(
            self,
        ) -> ::std::option::Option<FunctionSignatureItem<'tree>> {
            self.as_declaration_statement()?.as_function_signature_item()
        }
        /**Returns the node if it is of type `impl_item` ([`ImplItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_impl_item(self) -> ::std::option::Option<ImplItem<'tree>> {
            self.as_declaration_statement()?.as_impl_item()
        }
        /**Returns the node if it is of type `inner_attribute_item` ([`InnerAttributeItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_inner_attribute_item(
            self,
        ) -> ::std::option::Option<InnerAttributeItem<'tree>> {
            self.as_declaration_statement()?.as_inner_attribute_item()
        }
        /**Returns the node if it is of type `let_declaration` ([`LetDeclaration`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_let_declaration(self) -> ::std::option::Option<LetDeclaration<'tree>> {
            self.as_declaration_statement()?.as_let_declaration()
        }
        /**Returns the node if it is of type `macro_definition` ([`MacroDefinition`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_macro_definition(
            self,
        ) -> ::std::option::Option<MacroDefinition<'tree>> {
            self.as_declaration_statement()?.as_macro_definition()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_declaration_statement()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `mod_item` ([`ModItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_mod_item(self) -> ::std::option::Option<ModItem<'tree>> {
            self.as_declaration_statement()?.as_mod_item()
        }
        /**Returns the node if it is of type `static_item` ([`StaticItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_static_item(self) -> ::std::option::Option<StaticItem<'tree>> {
            self.as_declaration_statement()?.as_static_item()
        }
        /**Returns the node if it is of type `struct_item` ([`StructItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_struct_item(self) -> ::std::option::Option<StructItem<'tree>> {
            self.as_declaration_statement()?.as_struct_item()
        }
        /**Returns the node if it is of type `trait_item` ([`TraitItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_trait_item(self) -> ::std::option::Option<TraitItem<'tree>> {
            self.as_declaration_statement()?.as_trait_item()
        }
        /**Returns the node if it is of type `type_item` ([`TypeItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_type_item(self) -> ::std::option::Option<TypeItem<'tree>> {
            self.as_declaration_statement()?.as_type_item()
        }
        /**Returns the node if it is of type `union_item` ([`UnionItem`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_union_item(self) -> ::std::option::Option<UnionItem<'tree>> {
            self.as_declaration_statement()?.as_union_item()
        }
        /**Returns the node if it is of type `use_declaration` ([`UseDeclaration`]), otherwise returns `None`.

Follows the following chain:
- `_declaration_statement` ([`DeclarationStatement < 'tree >`], from [`as_declaration_statement`](Self::as_declaration_statement))*/
        #[inline]
        pub fn as_use_declaration(self) -> ::std::option::Option<UseDeclaration<'tree>> {
            self.as_declaration_statement()?.as_use_declaration()
        }
        /**Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        /**Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_array_expression(
            self,
        ) -> ::std::option::Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        /**Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_await_expression(
            self,
        ) -> ::std::option::Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        /**Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_break_expression(
            self,
        ) -> ::std::option::Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        /**Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_assignment_expr(
            self,
        ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        /**Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_continue_expression(
            self,
        ) -> ::std::option::Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        /**Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
            self.as_expression()?.as_gen_block()
        }
        /**Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_function(
            self,
        ) -> ::std::option::Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        /**Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_index_expression(
            self,
        ) -> ::std::option::Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        /**Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_macro_invocation_(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_match_expression(
            self,
        ) -> ::std::option::Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_range_expression(
            self,
        ) -> ::std::option::Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        /**Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_reference_expression(
            self,
        ) -> ::std::option::Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        /**Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_return_expression(
            self,
        ) -> ::std::option::Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        /**Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_struct_expression(
            self,
        ) -> ::std::option::Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        /**Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        /**Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        /**Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_tuple_expression(
            self,
        ) -> ::std::option::Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        /**Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_type_cast_expression(
            self,
        ) -> ::std::option::Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        /**Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        /**Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_while_expression(
            self,
        ) -> ::std::option::Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        /**Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_yield_expression(
            self,
        ) -> ::std::option::Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for DeclarationStatement_Expression_ExpressionStatement_Label<'tree> {
        type WithLifetime<'a> = DeclarationStatement_Expression_ExpressionStatement_Label<
            'a,
        >;
        const KIND: &'static str = "{_declaration_statement | _expression | expression_statement | label}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <DeclarationStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::DeclarationStatement(this));
            }
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <ExpressionStatement<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ExpressionStatement(this));
            }
            if let Ok(this) = <Label<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Label(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw(x),
                Self::Label(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ExpressionStatement(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Label(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::DeclarationStatement(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
                Self::ExpressionStatement(x) => x.into_raw(),
                Self::Label(x) => x.into_raw(),
            }
        }
    }
    /**One of `{escape_sequence | string_content}`:
- [`EscapeSequence`]
- [`StringContent`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum EscapeSequence_StringContent<'tree> {
        EscapeSequence(EscapeSequence<'tree>),
        StringContent(StringContent<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> EscapeSequence_StringContent<'tree> {
        ///Returns the node if it is of type `escape_sequence` ([`EscapeSequence`]), otherwise returns `None`
        #[inline]
        pub fn as_escape_sequence(self) -> ::std::option::Option<EscapeSequence<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EscapeSequence(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `string_content` ([`StringContent`]), otherwise returns `None`
        #[inline]
        pub fn as_string_content(self) -> ::std::option::Option<StringContent<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StringContent(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for EscapeSequence_StringContent<'tree> {
        type WithLifetime<'a> = EscapeSequence_StringContent<'a>;
        const KIND: &'static str = "{escape_sequence | string_content}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <EscapeSequence<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::EscapeSequence(this));
            }
            if let Ok(this) = <StringContent<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::StringContent(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => ::type_sitter_lib::Node::raw(x),
                Self::StringContent(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StringContent(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::EscapeSequence(x) => x.into_raw(),
                Self::StringContent(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_expression | attribute_item}`:
- [`Expression`]
- [`AttributeItem`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_AttributeItem<'tree> {
        Expression(Expression<'tree>),
        AttributeItem(AttributeItem<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_AttributeItem<'tree> {
        ///Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        /**Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_array_expression(
            self,
        ) -> ::std::option::Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        /**Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_await_expression(
            self,
        ) -> ::std::option::Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        /**Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_break_expression(
            self,
        ) -> ::std::option::Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        /**Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_assignment_expr(
            self,
        ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        /**Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_continue_expression(
            self,
        ) -> ::std::option::Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        /**Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
            self.as_expression()?.as_gen_block()
        }
        /**Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_function(
            self,
        ) -> ::std::option::Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        /**Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_index_expression(
            self,
        ) -> ::std::option::Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        /**Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_match_expression(
            self,
        ) -> ::std::option::Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_range_expression(
            self,
        ) -> ::std::option::Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        /**Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_reference_expression(
            self,
        ) -> ::std::option::Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        /**Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_return_expression(
            self,
        ) -> ::std::option::Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        /**Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_struct_expression(
            self,
        ) -> ::std::option::Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        /**Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        /**Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        /**Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_tuple_expression(
            self,
        ) -> ::std::option::Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        /**Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_type_cast_expression(
            self,
        ) -> ::std::option::Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        /**Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        /**Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_while_expression(
            self,
        ) -> ::std::option::Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        /**Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_yield_expression(
            self,
        ) -> ::std::option::Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Expression_AttributeItem<'tree> {
        type WithLifetime<'a> = Expression_AttributeItem<'a>;
        const KIND: &'static str = "{_expression | attribute_item}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::AttributeItem(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_expression | label}`:
- [`Expression`]
- [`Label`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_Label<'tree> {
        Expression(Expression<'tree>),
        Label(Label<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_Label<'tree> {
        ///Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `label` ([`Label`]), otherwise returns `None`
        #[inline]
        pub fn as_label(self) -> ::std::option::Option<Label<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Label(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        /**Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_array_expression(
            self,
        ) -> ::std::option::Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        /**Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_await_expression(
            self,
        ) -> ::std::option::Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        /**Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_break_expression(
            self,
        ) -> ::std::option::Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        /**Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_assignment_expr(
            self,
        ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        /**Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_continue_expression(
            self,
        ) -> ::std::option::Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        /**Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
            self.as_expression()?.as_gen_block()
        }
        /**Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_function(
            self,
        ) -> ::std::option::Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        /**Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_index_expression(
            self,
        ) -> ::std::option::Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        /**Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_match_expression(
            self,
        ) -> ::std::option::Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_range_expression(
            self,
        ) -> ::std::option::Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        /**Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_reference_expression(
            self,
        ) -> ::std::option::Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        /**Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_return_expression(
            self,
        ) -> ::std::option::Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        /**Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_struct_expression(
            self,
        ) -> ::std::option::Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        /**Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        /**Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        /**Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_tuple_expression(
            self,
        ) -> ::std::option::Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        /**Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_type_cast_expression(
            self,
        ) -> ::std::option::Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        /**Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        /**Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_while_expression(
            self,
        ) -> ::std::option::Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        /**Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_yield_expression(
            self,
        ) -> ::std::option::Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Expression_Label<'tree> {
        type WithLifetime<'a> = Expression_Label<'a>;
        const KIND: &'static str = "{_expression | label}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <Label<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Label(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Label(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Label(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::Label(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_expression | let_chain | let_condition}`:
- [`Expression`]
- [`LetChain`]
- [`LetCondition`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_LetChain_LetCondition<'tree> {
        Expression(Expression<'tree>),
        LetChain(LetChain<'tree>),
        LetCondition(LetCondition<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_LetChain_LetCondition<'tree> {
        ///Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `let_chain` ([`LetChain`]), otherwise returns `None`
        #[inline]
        pub fn as_let_chain(self) -> ::std::option::Option<LetChain<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LetChain(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `let_condition` ([`LetCondition`]), otherwise returns `None`
        #[inline]
        pub fn as_let_condition(self) -> ::std::option::Option<LetCondition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LetCondition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        /**Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_array_expression(
            self,
        ) -> ::std::option::Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        /**Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_await_expression(
            self,
        ) -> ::std::option::Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        /**Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_break_expression(
            self,
        ) -> ::std::option::Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        /**Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_assignment_expr(
            self,
        ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        /**Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_continue_expression(
            self,
        ) -> ::std::option::Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        /**Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
            self.as_expression()?.as_gen_block()
        }
        /**Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_function(
            self,
        ) -> ::std::option::Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        /**Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_index_expression(
            self,
        ) -> ::std::option::Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        /**Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_match_expression(
            self,
        ) -> ::std::option::Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_range_expression(
            self,
        ) -> ::std::option::Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        /**Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_reference_expression(
            self,
        ) -> ::std::option::Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        /**Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_return_expression(
            self,
        ) -> ::std::option::Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        /**Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_struct_expression(
            self,
        ) -> ::std::option::Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        /**Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        /**Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        /**Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_tuple_expression(
            self,
        ) -> ::std::option::Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        /**Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_type_cast_expression(
            self,
        ) -> ::std::option::Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        /**Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        /**Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_while_expression(
            self,
        ) -> ::std::option::Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        /**Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_yield_expression(
            self,
        ) -> ::std::option::Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Expression_LetChain_LetCondition<'tree> {
        type WithLifetime<'a> = Expression_LetChain_LetCondition<'a>;
        const KIND: &'static str = "{_expression | let_chain | let_condition}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <LetChain<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LetChain(this));
            }
            if let Ok(this) = <LetCondition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LetCondition(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::LetChain(x) => ::type_sitter_lib::Node::raw(x),
                Self::LetCondition(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LetChain(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LetCondition(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::LetChain(x) => x.into_raw(),
                Self::LetCondition(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_expression | let_condition}`:
- [`Expression`]
- [`LetCondition`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Expression_LetCondition<'tree> {
        Expression(Expression<'tree>),
        LetCondition(LetCondition<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Expression_LetCondition<'tree> {
        ///Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `let_condition` ([`LetCondition`]), otherwise returns `None`
        #[inline]
        pub fn as_let_condition(self) -> ::std::option::Option<LetCondition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LetCondition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        /**Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_array_expression(
            self,
        ) -> ::std::option::Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        /**Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_await_expression(
            self,
        ) -> ::std::option::Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        /**Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_break_expression(
            self,
        ) -> ::std::option::Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        /**Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_assignment_expr(
            self,
        ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        /**Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_continue_expression(
            self,
        ) -> ::std::option::Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        /**Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
            self.as_expression()?.as_gen_block()
        }
        /**Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_function(
            self,
        ) -> ::std::option::Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        /**Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_index_expression(
            self,
        ) -> ::std::option::Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        /**Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_match_expression(
            self,
        ) -> ::std::option::Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_range_expression(
            self,
        ) -> ::std::option::Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        /**Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_reference_expression(
            self,
        ) -> ::std::option::Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        /**Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_return_expression(
            self,
        ) -> ::std::option::Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        /**Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_struct_expression(
            self,
        ) -> ::std::option::Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        /**Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        /**Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        /**Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_tuple_expression(
            self,
        ) -> ::std::option::Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        /**Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_type_cast_expression(
            self,
        ) -> ::std::option::Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        /**Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        /**Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_while_expression(
            self,
        ) -> ::std::option::Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        /**Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_yield_expression(
            self,
        ) -> ::std::option::Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Expression_LetCondition<'tree> {
        type WithLifetime<'a> = Expression_LetCondition<'a>;
        const KIND: &'static str = "{_expression | let_condition}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            if let Ok(this) = <LetCondition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LetCondition(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
                Self::LetCondition(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LetCondition(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Expression(x) => x.into_raw(),
                Self::LetCondition(x) => x.into_raw(),
            }
        }
    }
    /**One of `{extern_modifier | visibility_modifier}`:
- [`ExternModifier`]
- [`VisibilityModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ExternModifier_VisibilityModifier<'tree> {
        ExternModifier(ExternModifier<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ExternModifier_VisibilityModifier<'tree> {
        ///Returns the node if it is of type `extern_modifier` ([`ExternModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_extern_modifier(self) -> ::std::option::Option<ExternModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ExternModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_visibility_modifier(
            self,
        ) -> ::std::option::Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ExternModifier_VisibilityModifier<'tree> {
        type WithLifetime<'a> = ExternModifier_VisibilityModifier<'a>;
        const KIND: &'static str = "{extern_modifier | visibility_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <ExternModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ExternModifier(this));
            }
            if let Ok(this) = <VisibilityModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::VisibilityModifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ExternModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ExternModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ExternModifier(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{field_declaration_list | ordered_field_declaration_list}`:
- [`FieldDeclarationList`]
- [`OrderedFieldDeclarationList`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldDeclarationList_OrderedFieldDeclarationList<'tree> {
        FieldDeclarationList(FieldDeclarationList<'tree>),
        OrderedFieldDeclarationList(OrderedFieldDeclarationList<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldDeclarationList_OrderedFieldDeclarationList<'tree> {
        ///Returns the node if it is of type `field_declaration_list` ([`FieldDeclarationList`]), otherwise returns `None`
        #[inline]
        pub fn as_field_declaration_list(
            self,
        ) -> ::std::option::Option<FieldDeclarationList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldDeclarationList(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `ordered_field_declaration_list` ([`OrderedFieldDeclarationList`]), otherwise returns `None`
        #[inline]
        pub fn as_ordered_field_declaration_list(
            self,
        ) -> ::std::option::Option<OrderedFieldDeclarationList<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrderedFieldDeclarationList(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FieldDeclarationList_OrderedFieldDeclarationList<'tree> {
        type WithLifetime<'a> = FieldDeclarationList_OrderedFieldDeclarationList<'a>;
        const KIND: &'static str = "{field_declaration_list | ordered_field_declaration_list}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FieldDeclarationList<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldDeclarationList(this));
            }
            if let Ok(this) = <OrderedFieldDeclarationList<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::OrderedFieldDeclarationList(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDeclarationList(x) => ::type_sitter_lib::Node::raw(x),
                Self::OrderedFieldDeclarationList(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDeclarationList(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::OrderedFieldDeclarationList(x) => {
                    ::type_sitter_lib::Node::raw_mut(x)
                }
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldDeclarationList(x) => x.into_raw(),
                Self::OrderedFieldDeclarationList(x) => x.into_raw(),
            }
        }
    }
    /**One of `{field_expression | identifier | scoped_identifier}`:
- [`FieldExpression`]
- [`Identifier`]
- [`ScopedIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldExpression_Identifier_ScopedIdentifier<'tree> {
        FieldExpression(FieldExpression<'tree>),
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldExpression_Identifier_ScopedIdentifier<'tree> {
        ///Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FieldExpression_Identifier_ScopedIdentifier<'tree> {
        type WithLifetime<'a> = FieldExpression_Identifier_ScopedIdentifier<'a>;
        const KIND: &'static str = "{field_expression | identifier | scoped_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FieldExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldExpression(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FieldExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldExpression(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{field_identifier | integer_literal}`:
- [`FieldIdentifier`]
- [`IntegerLiteral`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldIdentifier_IntegerLiteral<'tree> {
        FieldIdentifier(FieldIdentifier<'tree>),
        IntegerLiteral(IntegerLiteral<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldIdentifier_IntegerLiteral<'tree> {
        ///Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_field_identifier(
            self,
        ) -> ::std::option::Option<FieldIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IntegerLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FieldIdentifier_IntegerLiteral<'tree> {
        type WithLifetime<'a> = FieldIdentifier_IntegerLiteral<'a>;
        const KIND: &'static str = "{field_identifier | integer_literal}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FieldIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldIdentifier(this));
            }
            if let Ok(this) = <IntegerLiteral<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::IntegerLiteral(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => x.into_raw(),
                Self::IntegerLiteral(x) => x.into_raw(),
            }
        }
    }
    /**One of `{field_identifier | shorthand_field_identifier}`:
- [`FieldIdentifier`]
- [`ShorthandFieldIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldIdentifier_ShorthandFieldIdentifier<'tree> {
        FieldIdentifier(FieldIdentifier<'tree>),
        ShorthandFieldIdentifier(ShorthandFieldIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldIdentifier_ShorthandFieldIdentifier<'tree> {
        ///Returns the node if it is of type `field_identifier` ([`FieldIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_field_identifier(
            self,
        ) -> ::std::option::Option<FieldIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `shorthand_field_identifier` ([`ShorthandFieldIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_shorthand_field_identifier(
            self,
        ) -> ::std::option::Option<ShorthandFieldIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ShorthandFieldIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FieldIdentifier_ShorthandFieldIdentifier<'tree> {
        type WithLifetime<'a> = FieldIdentifier_ShorthandFieldIdentifier<'a>;
        const KIND: &'static str = "{field_identifier | shorthand_field_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FieldIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldIdentifier(this));
            }
            if let Ok(this) = <ShorthandFieldIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ShorthandFieldIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ShorthandFieldIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ShorthandFieldIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldIdentifier(x) => x.into_raw(),
                Self::ShorthandFieldIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{field_pattern | remaining_field_pattern}`:
- [`FieldPattern`]
- [`RemainingFieldPattern`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FieldPattern_RemainingFieldPattern<'tree> {
        FieldPattern(FieldPattern<'tree>),
        RemainingFieldPattern(RemainingFieldPattern<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FieldPattern_RemainingFieldPattern<'tree> {
        ///Returns the node if it is of type `field_pattern` ([`FieldPattern`]), otherwise returns `None`
        #[inline]
        pub fn as_field_pattern(self) -> ::std::option::Option<FieldPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldPattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`
        #[inline]
        pub fn as_remaining_field_pattern(
            self,
        ) -> ::std::option::Option<RemainingFieldPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::RemainingFieldPattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FieldPattern_RemainingFieldPattern<'tree> {
        type WithLifetime<'a> = FieldPattern_RemainingFieldPattern<'a>;
        const KIND: &'static str = "{field_pattern | remaining_field_pattern}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FieldPattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldPattern(this));
            }
            if let Ok(this) = <RemainingFieldPattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::RemainingFieldPattern(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FieldPattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::RemainingFieldPattern(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::RemainingFieldPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FieldPattern(x) => x.into_raw(),
                Self::RemainingFieldPattern(x) => x.into_raw(),
            }
        }
    }
    /**One of `{float_literal | integer_literal}`:
- [`FloatLiteral`]
- [`IntegerLiteral`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FloatLiteral_IntegerLiteral<'tree> {
        FloatLiteral(FloatLiteral<'tree>),
        IntegerLiteral(IntegerLiteral<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FloatLiteral_IntegerLiteral<'tree> {
        ///Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FloatLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IntegerLiteral(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for FloatLiteral_IntegerLiteral<'tree> {
        type WithLifetime<'a> = FloatLiteral_IntegerLiteral<'a>;
        const KIND: &'static str = "{float_literal | integer_literal}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FloatLiteral<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FloatLiteral(this));
            }
            if let Ok(this) = <IntegerLiteral<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::IntegerLiteral(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FloatLiteral(x) => ::type_sitter_lib::Node::raw(x),
                Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FloatLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::IntegerLiteral(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FloatLiteral(x) => x.into_raw(),
                Self::IntegerLiteral(x) => x.into_raw(),
            }
        }
    }
    /**One of `{for_lifetimes | function_modifiers}`:
- [`ForLifetimes`]
- [`FunctionModifiers`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ForLifetimes_FunctionModifiers<'tree> {
        ForLifetimes(ForLifetimes<'tree>),
        FunctionModifiers(FunctionModifiers<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ForLifetimes_FunctionModifiers<'tree> {
        ///Returns the node if it is of type `for_lifetimes` ([`ForLifetimes`]), otherwise returns `None`
        #[inline]
        pub fn as_for_lifetimes(self) -> ::std::option::Option<ForLifetimes<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ForLifetimes(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `function_modifiers` ([`FunctionModifiers`]), otherwise returns `None`
        #[inline]
        pub fn as_function_modifiers(
            self,
        ) -> ::std::option::Option<FunctionModifiers<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionModifiers(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ForLifetimes_FunctionModifiers<'tree> {
        type WithLifetime<'a> = ForLifetimes_FunctionModifiers<'a>;
        const KIND: &'static str = "{for_lifetimes | function_modifiers}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <ForLifetimes<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ForLifetimes(this));
            }
            if let Ok(this) = <FunctionModifiers<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FunctionModifiers(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ForLifetimes(x) => ::type_sitter_lib::Node::raw(x),
                Self::FunctionModifiers(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ForLifetimes(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FunctionModifiers(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ForLifetimes(x) => x.into_raw(),
                Self::FunctionModifiers(x) => x.into_raw(),
            }
        }
    }
    /**One of `{function_modifiers | visibility_modifier | where_clause}`:
- [`FunctionModifiers`]
- [`VisibilityModifier`]
- [`WhereClause`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FunctionModifiers_VisibilityModifier_WhereClause<'tree> {
        FunctionModifiers(FunctionModifiers<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
        WhereClause(WhereClause<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> FunctionModifiers_VisibilityModifier_WhereClause<'tree> {
        ///Returns the node if it is of type `function_modifiers` ([`FunctionModifiers`]), otherwise returns `None`
        #[inline]
        pub fn as_function_modifiers(
            self,
        ) -> ::std::option::Option<FunctionModifiers<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionModifiers(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_visibility_modifier(
            self,
        ) -> ::std::option::Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `where_clause` ([`WhereClause`]), otherwise returns `None`
        #[inline]
        pub fn as_where_clause(self) -> ::std::option::Option<WhereClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::WhereClause(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FunctionModifiers_VisibilityModifier_WhereClause<'tree> {
        type WithLifetime<'a> = FunctionModifiers_VisibilityModifier_WhereClause<'a>;
        const KIND: &'static str = "{function_modifiers | visibility_modifier | where_clause}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FunctionModifiers<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FunctionModifiers(this));
            }
            if let Ok(this) = <VisibilityModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::VisibilityModifier(this));
            }
            if let Ok(this) = <WhereClause<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::WhereClause(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionModifiers(x) => ::type_sitter_lib::Node::raw(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::WhereClause(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionModifiers(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::WhereClause(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionModifiers(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
                Self::WhereClause(x) => x.into_raw(),
            }
        }
    }
    /**One of `{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}`:
- [`FunctionType`]
- [`GenericType`]
- [`HigherRankedTraitBound`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
        'tree,
    > {
        FunctionType(FunctionType<'tree>),
        GenericType(GenericType<'tree>),
        HigherRankedTraitBound(HigherRankedTraitBound<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
        'tree,
    > {
        ///Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`
        #[inline]
        pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `higher_ranked_trait_bound` ([`HigherRankedTraitBound`]), otherwise returns `None`
        #[inline]
        pub fn as_higher_ranked_trait_bound(
            self,
        ) -> ::std::option::Option<HigherRankedTraitBound<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::HigherRankedTraitBound(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
        'tree,
    > {
        type WithLifetime<'a> = FunctionType_GenericType_HigherRankedTraitBound_ScopedTypeIdentifier_TypeIdentifier<
            'a,
        >;
        const KIND: &'static str = "{function_type | generic_type | higher_ranked_trait_bound | scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FunctionType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FunctionType(this));
            }
            if let Ok(this) = <GenericType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericType(this));
            }
            if let Ok(this) = <HigherRankedTraitBound<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::HigherRankedTraitBound(this));
            }
            if let Ok(this) = <ScopedTypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedTypeIdentifier(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionType(x) => ::type_sitter_lib::Node::raw(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw(x),
                Self::HigherRankedTraitBound(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::HigherRankedTraitBound(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionType(x) => x.into_raw(),
                Self::GenericType(x) => x.into_raw(),
                Self::HigherRankedTraitBound(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}`:
- [`FunctionType`]
- [`GenericType`]
- [`RemovedTraitBound`]
- [`ScopedTypeIdentifier`]
- [`TupleType`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        FunctionType(FunctionType<'tree>),
        GenericType(GenericType<'tree>),
        RemovedTraitBound(RemovedTraitBound<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TupleType(TupleType<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        ///Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`
        #[inline]
        pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FunctionType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`
        #[inline]
        pub fn as_removed_trait_bound(
            self,
        ) -> ::std::option::Option<RemovedTraitBound<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::RemovedTraitBound(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`
        #[inline]
        pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TupleType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
        'tree,
    > {
        type WithLifetime<'a> = FunctionType_GenericType_RemovedTraitBound_ScopedTypeIdentifier_TupleType_TypeIdentifier<
            'a,
        >;
        const KIND: &'static str = "{function_type | generic_type | removed_trait_bound | scoped_type_identifier | tuple_type | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <FunctionType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FunctionType(this));
            }
            if let Ok(this) = <GenericType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericType(this));
            }
            if let Ok(this) = <RemovedTraitBound<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::RemovedTraitBound(this));
            }
            if let Ok(this) = <ScopedTypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedTypeIdentifier(this));
            }
            if let Ok(this) = <TupleType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TupleType(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionType(x) => ::type_sitter_lib::Node::raw(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw(x),
                Self::RemovedTraitBound(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TupleType(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GenericType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::RemovedTraitBound(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TupleType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::FunctionType(x) => x.into_raw(),
                Self::GenericType(x) => x.into_raw(),
                Self::RemovedTraitBound(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TupleType(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{generic_type_with_turbofish | scoped_type_identifier | type_identifier}`:
- [`GenericTypeWithTurbofish`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        GenericTypeWithTurbofish(GenericTypeWithTurbofish<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `generic_type_with_turbofish` ([`GenericTypeWithTurbofish`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_type_with_turbofish(
            self,
        ) -> ::std::option::Option<GenericTypeWithTurbofish<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericTypeWithTurbofish(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = GenericTypeWithTurbofish_ScopedTypeIdentifier_TypeIdentifier<
            'a,
        >;
        const KIND: &'static str = "{generic_type_with_turbofish | scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <GenericTypeWithTurbofish<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericTypeWithTurbofish(this));
            }
            if let Ok(this) = <ScopedTypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedTypeIdentifier(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::GenericTypeWithTurbofish(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::GenericTypeWithTurbofish(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::GenericTypeWithTurbofish(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{generic_type | identifier | scoped_identifier}`:
- [`GenericType`]
- [`Identifier`]
- [`ScopedIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum GenericType_Identifier_ScopedIdentifier<'tree> {
        GenericType(GenericType<'tree>),
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GenericType_Identifier_ScopedIdentifier<'tree> {
        ///Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for GenericType_Identifier_ScopedIdentifier<'tree> {
        type WithLifetime<'a> = GenericType_Identifier_ScopedIdentifier<'a>;
        const KIND: &'static str = "{generic_type | identifier | scoped_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <GenericType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericType(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{generic_type | scoped_type_identifier | type_identifier}`:
- [`GenericType`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        GenericType(GenericType<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for GenericType_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = GenericType_ScopedTypeIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str = "{generic_type | scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <GenericType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericType(this));
            }
            if let Ok(this) = <ScopedTypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedTypeIdentifier(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::GenericType(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{identifier | metavariable}`:
- [`Identifier`]
- [`Metavariable`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_Metavariable<'tree> {
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_Metavariable<'tree> {
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Identifier_Metavariable<'tree> {
        type WithLifetime<'a> = Identifier_Metavariable<'a>;
        const KIND: &'static str = "{identifier | metavariable}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
            }
        }
    }
    /**One of `{identifier | scoped_identifier}`:
- [`Identifier`]
- [`ScopedIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_ScopedIdentifier<'tree> {
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_ScopedIdentifier<'tree> {
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Identifier_ScopedIdentifier<'tree> {
        type WithLifetime<'a> = Identifier_ScopedIdentifier<'a>;
        const KIND: &'static str = "{identifier | scoped_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{identifier | scoped_identifier | scoped_type_identifier | type_identifier}`:
- [`Identifier`]
- [`ScopedIdentifier`]
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        Identifier(Identifier<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = Identifier_ScopedIdentifier_ScopedTypeIdentifier_TypeIdentifier<
            'a,
        >;
        const KIND: &'static str = "{identifier | scoped_identifier | scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <ScopedTypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedTypeIdentifier(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{identifier | super}`:
- [`Identifier`]
- [`Super`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Identifier_Super<'tree> {
        Identifier(Identifier<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Identifier_Super<'tree> {
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`
        #[inline]
        pub fn as_super(self) -> ::std::option::Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Identifier_Super<'tree> {
        type WithLifetime<'a> = Identifier_Super<'a>;
        const KIND: &'static str = "{identifier | super}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Super<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Identifier(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    /**One of `{lifetime | mutable_specifier}`:
- [`Lifetime`]
- [`MutableSpecifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Lifetime_MutableSpecifier<'tree> {
        Lifetime(Lifetime<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime_MutableSpecifier<'tree> {
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_mutable_specifier(
            self,
        ) -> ::std::option::Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Lifetime_MutableSpecifier<'tree> {
        type WithLifetime<'a> = Lifetime_MutableSpecifier<'a>;
        const KIND: &'static str = "{lifetime | mutable_specifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            if let Ok(this) = <MutableSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MutableSpecifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{lifetime | mutable_specifier | self}`:
- [`Lifetime`]
- [`MutableSpecifier`]
- [`Self_`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Lifetime_MutableSpecifier_Self_<'tree> {
        Lifetime(Lifetime<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
        Self_(Self_<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime_MutableSpecifier_Self_<'tree> {
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_mutable_specifier(
            self,
        ) -> ::std::option::Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Lifetime_MutableSpecifier_Self_<'tree> {
        type WithLifetime<'a> = Lifetime_MutableSpecifier_Self_<'a>;
        const KIND: &'static str = "{lifetime | mutable_specifier | self}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            if let Ok(this) = <MutableSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MutableSpecifier(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
            }
        }
    }
    /**One of `{lifetime | type_identifier}`:
- [`Lifetime`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Lifetime_TypeIdentifier<'tree> {
        Lifetime(Lifetime<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Lifetime_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Lifetime_TypeIdentifier<'tree> {
        type WithLifetime<'a> = Lifetime_TypeIdentifier<'a>;
        const KIND: &'static str = "{lifetime | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Lifetime(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_literal_pattern | crate | identifier | metavariable | scoped_identifier | self | super}`:
- [`LiteralPattern`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`Super`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    > {
        LiteralPattern(LiteralPattern<'tree>),
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<'tree> {
        ///Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`
        #[inline]
        pub fn as_literal_pattern(self) -> ::std::option::Option<LiteralPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LiteralPattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`
        #[inline]
        pub fn as_crate(self) -> ::std::option::Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`
        #[inline]
        pub fn as_super(self) -> ::std::option::Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_literal_pattern()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_literal_pattern()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_literal_pattern()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_literal_pattern()?.as_integer_literal()
        }
        /**Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
        #[inline]
        pub fn as_negative_literal(
            self,
        ) -> ::std::option::Option<NegativeLiteral<'tree>> {
            self.as_literal_pattern()?.as_negative_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_literal_pattern()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Self::as_literal_pattern))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
        'tree,
    > {
        type WithLifetime<'a> = LiteralPattern_Crate_Identifier_Metavariable_ScopedIdentifier_Self__Super<
            'a,
        >;
        const KIND: &'static str = "{_literal_pattern | crate | identifier | metavariable | scoped_identifier | self | super}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <LiteralPattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LiteralPattern(this));
            }
            if let Ok(this) = <Crate<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <Super<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::LiteralPattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::LiteralPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::LiteralPattern(x) => x.into_raw(),
                Self::Crate(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | gen_block | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}`:
- [`Literal`]
- [`ArrayExpression`]
- [`AssignmentExpression`]
- [`AsyncBlock`]
- [`AwaitExpression`]
- [`BinaryExpression`]
- [`Block`]
- [`BreakExpression`]
- [`CallExpression`]
- [`ClosureExpression`]
- [`CompoundAssignmentExpr`]
- [`ConstBlock`]
- [`ContinueExpression`]
- [`FieldExpression`]
- [`ForExpression`]
- [`GenBlock`]
- [`GenericFunction`]
- [`Identifier`]
- [`IfExpression`]
- [`IndexExpression`]
- [`LoopExpression`]
- [`MacroInvocation`]
- [`MatchExpression`]
- [`Metavariable`]
- [`ParenthesizedExpression`]
- [`ReferenceExpression`]
- [`ReturnExpression`]
- [`ScopedIdentifier`]
- [`Self_`]
- [`StructExpression`]
- [`TryBlock`]
- [`TryExpression`]
- [`TupleExpression`]
- [`TypeCastExpression`]
- [`UnaryExpression`]
- [`UnitExpression`]
- [`UnsafeBlock`]
- [`WhileExpression`]
- [`YieldExpression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenBlock_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression<
        'tree,
    > {
        Literal(Literal<'tree>),
        ArrayExpression(ArrayExpression<'tree>),
        AssignmentExpression(AssignmentExpression<'tree>),
        AsyncBlock(AsyncBlock<'tree>),
        AwaitExpression(AwaitExpression<'tree>),
        BinaryExpression(BinaryExpression<'tree>),
        Block(Block<'tree>),
        BreakExpression(BreakExpression<'tree>),
        CallExpression(CallExpression<'tree>),
        ClosureExpression(ClosureExpression<'tree>),
        CompoundAssignmentExpr(CompoundAssignmentExpr<'tree>),
        ConstBlock(ConstBlock<'tree>),
        ContinueExpression(ContinueExpression<'tree>),
        FieldExpression(FieldExpression<'tree>),
        ForExpression(ForExpression<'tree>),
        GenBlock(GenBlock<'tree>),
        GenericFunction(GenericFunction<'tree>),
        Identifier(Identifier<'tree>),
        IfExpression(IfExpression<'tree>),
        IndexExpression(IndexExpression<'tree>),
        LoopExpression(LoopExpression<'tree>),
        MacroInvocation(MacroInvocation<'tree>),
        MatchExpression(MatchExpression<'tree>),
        Metavariable(Metavariable<'tree>),
        ParenthesizedExpression(ParenthesizedExpression<'tree>),
        ReferenceExpression(ReferenceExpression<'tree>),
        ReturnExpression(ReturnExpression<'tree>),
        ScopedIdentifier(ScopedIdentifier<'tree>),
        Self_(Self_<'tree>),
        StructExpression(StructExpression<'tree>),
        TryBlock(TryBlock<'tree>),
        TryExpression(TryExpression<'tree>),
        TupleExpression(TupleExpression<'tree>),
        TypeCastExpression(TypeCastExpression<'tree>),
        UnaryExpression(UnaryExpression<'tree>),
        UnitExpression(UnitExpression<'tree>),
        UnsafeBlock(UnsafeBlock<'tree>),
        WhileExpression(WhileExpression<'tree>),
        YieldExpression(YieldExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenBlock_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression<
        'tree,
    > {
        ///Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Literal(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_array_expression(
            self,
        ) -> ::std::option::Option<ArrayExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ArrayExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AssignmentExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`
        #[inline]
        pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AsyncBlock(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_await_expression(
            self,
        ) -> ::std::option::Option<AwaitExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AwaitExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BinaryExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Block(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_break_expression(
            self,
        ) -> ::std::option::Option<BreakExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BreakExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CallExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ClosureExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`
        #[inline]
        pub fn as_compound_assignment_expr(
            self,
        ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::CompoundAssignmentExpr(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ConstBlock(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_continue_expression(
            self,
        ) -> ::std::option::Option<ContinueExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ContinueExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::FieldExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ForExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`
        #[inline]
        pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenBlock(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`
        #[inline]
        pub fn as_generic_function(
            self,
        ) -> ::std::option::Option<GenericFunction<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GenericFunction(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IfExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_index_expression(
            self,
        ) -> ::std::option::Option<IndexExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::IndexExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LoopExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MacroInvocation(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_match_expression(
            self,
        ) -> ::std::option::Option<MatchExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MatchExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ParenthesizedExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_reference_expression(
            self,
        ) -> ::std::option::Option<ReferenceExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ReferenceExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_return_expression(
            self,
        ) -> ::std::option::Option<ReturnExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ReturnExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_struct_expression(
            self,
        ) -> ::std::option::Option<StructExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::StructExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`
        #[inline]
        pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TryBlock(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TryExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_tuple_expression(
            self,
        ) -> ::std::option::Option<TupleExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TupleExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_type_cast_expression(
            self,
        ) -> ::std::option::Option<TypeCastExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeCastExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::UnaryExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::UnitExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`
        #[inline]
        pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::UnsafeBlock(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_while_expression(
            self,
        ) -> ::std::option::Option<WhileExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::WhileExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_yield_expression(
            self,
        ) -> ::std::option::Option<YieldExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::YieldExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenBlock_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression<
        'tree,
    > {
        type WithLifetime<'a> = Literal_ArrayExpression_AssignmentExpression_AsyncBlock_AwaitExpression_BinaryExpression_Block_BreakExpression_CallExpression_ClosureExpression_CompoundAssignmentExpr_ConstBlock_ContinueExpression_FieldExpression_ForExpression_GenBlock_GenericFunction_Identifier_IfExpression_IndexExpression_LoopExpression_MacroInvocation_MatchExpression_Metavariable_ParenthesizedExpression_ReferenceExpression_ReturnExpression_ScopedIdentifier_Self__StructExpression_TryBlock_TryExpression_TupleExpression_TypeCastExpression_UnaryExpression_UnitExpression_UnsafeBlock_WhileExpression_YieldExpression<
            'a,
        >;
        const KIND: &'static str = "{_literal | array_expression | assignment_expression | async_block | await_expression | binary_expression | block | break_expression | call_expression | closure_expression | compound_assignment_expr | const_block | continue_expression | field_expression | for_expression | gen_block | generic_function | identifier | if_expression | index_expression | loop_expression | macro_invocation | match_expression | metavariable | parenthesized_expression | reference_expression | return_expression | scoped_identifier | self | struct_expression | try_block | try_expression | tuple_expression | type_cast_expression | unary_expression | unit_expression | unsafe_block | while_expression | yield_expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Literal<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Literal(this));
            }
            if let Ok(this) = <ArrayExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ArrayExpression(this));
            }
            if let Ok(this) = <AssignmentExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AssignmentExpression(this));
            }
            if let Ok(this) = <AsyncBlock<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AsyncBlock(this));
            }
            if let Ok(this) = <AwaitExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AwaitExpression(this));
            }
            if let Ok(this) = <BinaryExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::BinaryExpression(this));
            }
            if let Ok(this) = <Block<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Block(this));
            }
            if let Ok(this) = <BreakExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::BreakExpression(this));
            }
            if let Ok(this) = <CallExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CallExpression(this));
            }
            if let Ok(this) = <ClosureExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ClosureExpression(this));
            }
            if let Ok(this) = <CompoundAssignmentExpr<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::CompoundAssignmentExpr(this));
            }
            if let Ok(this) = <ConstBlock<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ConstBlock(this));
            }
            if let Ok(this) = <ContinueExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ContinueExpression(this));
            }
            if let Ok(this) = <FieldExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::FieldExpression(this));
            }
            if let Ok(this) = <ForExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ForExpression(this));
            }
            if let Ok(this) = <GenBlock<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenBlock(this));
            }
            if let Ok(this) = <GenericFunction<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GenericFunction(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <IfExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::IfExpression(this));
            }
            if let Ok(this) = <IndexExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::IndexExpression(this));
            }
            if let Ok(this) = <LoopExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LoopExpression(this));
            }
            if let Ok(this) = <MacroInvocation<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MacroInvocation(this));
            }
            if let Ok(this) = <MatchExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MatchExpression(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <ParenthesizedExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ParenthesizedExpression(this));
            }
            if let Ok(this) = <ReferenceExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ReferenceExpression(this));
            }
            if let Ok(this) = <ReturnExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ReturnExpression(this));
            }
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <StructExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::StructExpression(this));
            }
            if let Ok(this) = <TryBlock<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TryBlock(this));
            }
            if let Ok(this) = <TryExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TryExpression(this));
            }
            if let Ok(this) = <TupleExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TupleExpression(this));
            }
            if let Ok(this) = <TypeCastExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeCastExpression(this));
            }
            if let Ok(this) = <UnaryExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::UnaryExpression(this));
            }
            if let Ok(this) = <UnitExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::UnitExpression(this));
            }
            if let Ok(this) = <UnsafeBlock<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::UnsafeBlock(this));
            }
            if let Ok(this) = <WhileExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::WhileExpression(this));
            }
            if let Ok(this) = <YieldExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::YieldExpression(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw(x),
                Self::ArrayExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::AssignmentExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::AsyncBlock(x) => ::type_sitter_lib::Node::raw(x),
                Self::AwaitExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Block(x) => ::type_sitter_lib::Node::raw(x),
                Self::BreakExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::ClosureExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::CompoundAssignmentExpr(x) => ::type_sitter_lib::Node::raw(x),
                Self::ConstBlock(x) => ::type_sitter_lib::Node::raw(x),
                Self::ContinueExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::FieldExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::ForExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::GenBlock(x) => ::type_sitter_lib::Node::raw(x),
                Self::GenericFunction(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::IfExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::IndexExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::LoopExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw(x),
                Self::MatchExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::ReferenceExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::ReturnExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
                Self::StructExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::TryBlock(x) => ::type_sitter_lib::Node::raw(x),
                Self::TryExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::TupleExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeCastExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::UnitExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::UnsafeBlock(x) => ::type_sitter_lib::Node::raw(x),
                Self::WhileExpression(x) => ::type_sitter_lib::Node::raw(x),
                Self::YieldExpression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ArrayExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AssignmentExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AsyncBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AwaitExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BinaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Block(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BreakExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CallExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ClosureExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::CompoundAssignmentExpr(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ConstBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ContinueExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::FieldExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ForExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GenBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GenericFunction(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::IfExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::IndexExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LoopExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MacroInvocation(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MatchExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ParenthesizedExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ReferenceExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ReturnExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::StructExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TryBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TupleExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeCastExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::UnaryExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::UnitExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::UnsafeBlock(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::WhileExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::YieldExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => x.into_raw(),
                Self::ArrayExpression(x) => x.into_raw(),
                Self::AssignmentExpression(x) => x.into_raw(),
                Self::AsyncBlock(x) => x.into_raw(),
                Self::AwaitExpression(x) => x.into_raw(),
                Self::BinaryExpression(x) => x.into_raw(),
                Self::Block(x) => x.into_raw(),
                Self::BreakExpression(x) => x.into_raw(),
                Self::CallExpression(x) => x.into_raw(),
                Self::ClosureExpression(x) => x.into_raw(),
                Self::CompoundAssignmentExpr(x) => x.into_raw(),
                Self::ConstBlock(x) => x.into_raw(),
                Self::ContinueExpression(x) => x.into_raw(),
                Self::FieldExpression(x) => x.into_raw(),
                Self::ForExpression(x) => x.into_raw(),
                Self::GenBlock(x) => x.into_raw(),
                Self::GenericFunction(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::IfExpression(x) => x.into_raw(),
                Self::IndexExpression(x) => x.into_raw(),
                Self::LoopExpression(x) => x.into_raw(),
                Self::MacroInvocation(x) => x.into_raw(),
                Self::MatchExpression(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::ParenthesizedExpression(x) => x.into_raw(),
                Self::ReferenceExpression(x) => x.into_raw(),
                Self::ReturnExpression(x) => x.into_raw(),
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::StructExpression(x) => x.into_raw(),
                Self::TryBlock(x) => x.into_raw(),
                Self::TryExpression(x) => x.into_raw(),
                Self::TupleExpression(x) => x.into_raw(),
                Self::TypeCastExpression(x) => x.into_raw(),
                Self::UnaryExpression(x) => x.into_raw(),
                Self::UnitExpression(x) => x.into_raw(),
                Self::UnsafeBlock(x) => x.into_raw(),
                Self::WhileExpression(x) => x.into_raw(),
                Self::YieldExpression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}`:
- [`Literal`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`MutableSpecifier`]
- [`PrimitiveType`]
- [`Self_`]
- [`Super`]
- [`TokenBindingPattern`]
- [`TokenRepetitionPattern`]
- [`TokenTreePattern`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern<
        'tree,
    > {
        Literal(Literal<'tree>),
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
        PrimitiveType(PrimitiveType<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
        TokenBindingPattern(TokenBindingPattern<'tree>),
        TokenRepetitionPattern(TokenRepetitionPattern<'tree>),
        TokenTreePattern(TokenTreePattern<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern<
        'tree,
    > {
        ///Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Literal(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`
        #[inline]
        pub fn as_crate(self) -> ::std::option::Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_mutable_specifier(
            self,
        ) -> ::std::option::Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PrimitiveType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`
        #[inline]
        pub fn as_super(self) -> ::std::option::Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `token_binding_pattern` ([`TokenBindingPattern`]), otherwise returns `None`
        #[inline]
        pub fn as_token_binding_pattern(
            self,
        ) -> ::std::option::Option<TokenBindingPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TokenBindingPattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `token_repetition_pattern` ([`TokenRepetitionPattern`]), otherwise returns `None`
        #[inline]
        pub fn as_token_repetition_pattern(
            self,
        ) -> ::std::option::Option<TokenRepetitionPattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TokenRepetitionPattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `token_tree_pattern` ([`TokenTreePattern`]), otherwise returns `None`
        #[inline]
        pub fn as_token_tree_pattern(
            self,
        ) -> ::std::option::Option<TokenTreePattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TokenTreePattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern<
        'tree,
    > {
        type WithLifetime<'a> = Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenBindingPattern_TokenRepetitionPattern_TokenTreePattern<
            'a,
        >;
        const KIND: &'static str = "{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_binding_pattern | token_repetition_pattern | token_tree_pattern}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Literal<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Literal(this));
            }
            if let Ok(this) = <Crate<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <MutableSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MutableSpecifier(this));
            }
            if let Ok(this) = <PrimitiveType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PrimitiveType(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <Super<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            if let Ok(this) = <TokenBindingPattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TokenBindingPattern(this));
            }
            if let Ok(this) = <TokenRepetitionPattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TokenRepetitionPattern(this));
            }
            if let Ok(this) = <TokenTreePattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TokenTreePattern(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw(x),
                Self::TokenBindingPattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::TokenRepetitionPattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::TokenTreePattern(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TokenBindingPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TokenRepetitionPattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TokenTreePattern(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => x.into_raw(),
                Self::Crate(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
                Self::PrimitiveType(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
                Self::TokenBindingPattern(x) => x.into_raw(),
                Self::TokenRepetitionPattern(x) => x.into_raw(),
                Self::TokenTreePattern(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}`:
- [`Literal`]
- [`Crate`]
- [`Identifier`]
- [`Metavariable`]
- [`MutableSpecifier`]
- [`PrimitiveType`]
- [`Self_`]
- [`Super`]
- [`TokenRepetition`]
- [`TokenTree`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree<
        'tree,
    > {
        Literal(Literal<'tree>),
        Crate(Crate<'tree>),
        Identifier(Identifier<'tree>),
        Metavariable(Metavariable<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
        PrimitiveType(PrimitiveType<'tree>),
        Self_(Self_<'tree>),
        Super(Super<'tree>),
        TokenRepetition(TokenRepetition<'tree>),
        TokenTree(TokenTree<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree<
        'tree,
    > {
        ///Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Literal(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `crate` ([`Crate`]), otherwise returns `None`
        #[inline]
        pub fn as_crate(self) -> ::std::option::Option<Crate<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Crate(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Identifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Metavariable(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_mutable_specifier(
            self,
        ) -> ::std::option::Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::PrimitiveType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `super` ([`Super`]), otherwise returns `None`
        #[inline]
        pub fn as_super(self) -> ::std::option::Option<Super<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Super(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `token_repetition` ([`TokenRepetition`]), otherwise returns `None`
        #[inline]
        pub fn as_token_repetition(
            self,
        ) -> ::std::option::Option<TokenRepetition<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TokenRepetition(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `token_tree` ([`TokenTree`]), otherwise returns `None`
        #[inline]
        pub fn as_token_tree(self) -> ::std::option::Option<TokenTree<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TokenTree(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree<
        'tree,
    > {
        type WithLifetime<'a> = Literal_Crate_Identifier_Metavariable_MutableSpecifier_PrimitiveType_Self__Super_TokenRepetition_TokenTree<
            'a,
        >;
        const KIND: &'static str = "{_literal | crate | identifier | metavariable | mutable_specifier | primitive_type | self | super | token_repetition | token_tree}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Literal<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Literal(this));
            }
            if let Ok(this) = <Crate<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Crate(this));
            }
            if let Ok(this) = <Identifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Identifier(this));
            }
            if let Ok(this) = <Metavariable<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Metavariable(this));
            }
            if let Ok(this) = <MutableSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MutableSpecifier(this));
            }
            if let Ok(this) = <PrimitiveType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::PrimitiveType(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            if let Ok(this) = <Super<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Super(this));
            }
            if let Ok(this) = <TokenRepetition<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TokenRepetition(this));
            }
            if let Ok(this) = <TokenTree<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TokenTree(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw(x),
                Self::TokenRepetition(x) => ::type_sitter_lib::Node::raw(x),
                Self::TokenTree(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Crate(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Identifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Metavariable(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::PrimitiveType(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Super(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TokenRepetition(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TokenTree(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => x.into_raw(),
                Self::Crate(x) => x.into_raw(),
                Self::Identifier(x) => x.into_raw(),
                Self::Metavariable(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
                Self::PrimitiveType(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
                Self::Super(x) => x.into_raw(),
                Self::TokenRepetition(x) => x.into_raw(),
                Self::TokenTree(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_literal | _type | block | lifetime | trait_bounds | type_binding}`:
- [`Literal`]
- [`Type`]
- [`Block`]
- [`Lifetime`]
- [`TraitBounds`]
- [`TypeBinding`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree> {
        Literal(Literal<'tree>),
        Type(Type<'tree>),
        Block(Block<'tree>),
        Lifetime(Lifetime<'tree>),
        TraitBounds(TraitBounds<'tree>),
        TypeBinding(TypeBinding<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree> {
        ///Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Literal(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`
        #[inline]
        pub fn as_type(self) -> ::std::option::Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Block(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `trait_bounds` ([`TraitBounds`]), otherwise returns `None`
        #[inline]
        pub fn as_trait_bounds(self) -> ::std::option::Option<TraitBounds<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TraitBounds(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_binding` ([`TypeBinding`]), otherwise returns `None`
        #[inline]
        pub fn as_type_binding(self) -> ::std::option::Option<TypeBinding<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeBinding(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Self::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_literal()?.as_string_literal()
        }
        /**Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_abstract_type(self) -> ::std::option::Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        /**Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_array_type(self) -> ::std::option::Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        /**Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_bounded_type(self) -> ::std::option::Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        /**Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_dynamic_type(self) -> ::std::option::Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        /**Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        /**Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        /**Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_never_type(self) -> ::std::option::Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        /**Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_pointer_type(self) -> ::std::option::Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        /**Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_reference_type(self) -> ::std::option::Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        /**Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_removed_trait_bound(
            self,
        ) -> ::std::option::Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        /**Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        /**Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        /**Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_unit_type(self) -> ::std::option::Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'tree> {
        type WithLifetime<'a> = Literal_Type_Block_Lifetime_TraitBounds_TypeBinding<'a>;
        const KIND: &'static str = "{_literal | _type | block | lifetime | trait_bounds | type_binding}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Literal<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Literal(this));
            }
            if let Ok(this) = <Type<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <Block<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Block(this));
            }
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            if let Ok(this) = <TraitBounds<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TraitBounds(this));
            }
            if let Ok(this) = <TypeBinding<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeBinding(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw(x),
                Self::Type(x) => ::type_sitter_lib::Node::raw(x),
                Self::Block(x) => ::type_sitter_lib::Node::raw(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
                Self::TraitBounds(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeBinding(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Type(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Block(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TraitBounds(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeBinding(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Literal(x) => x.into_raw(),
                Self::Type(x) => x.into_raw(),
                Self::Block(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
                Self::TraitBounds(x) => x.into_raw(),
                Self::TypeBinding(x) => x.into_raw(),
            }
        }
    }
    /**One of `{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}`:
- [`symbols::ModEq`]
- [`symbols::AndEq`]
- [`symbols::MulEq`]
- [`symbols::AddEq`]
- [`symbols::SubEq`]
- [`symbols::DivEq`]
- [`symbols::LtLtEq`]
- [`symbols::GtGtEq`]
- [`symbols::BitXorEq`]
- [`symbols::OrEq`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'tree> {
        ModEq(symbols::ModEq<'tree>),
        AndEq(symbols::AndEq<'tree>),
        MulEq(symbols::MulEq<'tree>),
        AddEq(symbols::AddEq<'tree>),
        SubEq(symbols::SubEq<'tree>),
        DivEq(symbols::DivEq<'tree>),
        LtLtEq(symbols::LtLtEq<'tree>),
        GtGtEq(symbols::GtGtEq<'tree>),
        BitXorEq(symbols::BitXorEq<'tree>),
        OrEq(symbols::OrEq<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'tree> {
        ///Returns the node if it is of type `%=` ([`symbols::ModEq`]), otherwise returns `None`
        #[inline]
        pub fn as_mod_eq(self) -> ::std::option::Option<symbols::ModEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ModEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `&=` ([`symbols::AndEq`]), otherwise returns `None`
        #[inline]
        pub fn as_and_eq(self) -> ::std::option::Option<symbols::AndEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AndEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `*=` ([`symbols::MulEq`]), otherwise returns `None`
        #[inline]
        pub fn as_mul_eq(self) -> ::std::option::Option<symbols::MulEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MulEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `+=` ([`symbols::AddEq`]), otherwise returns `None`
        #[inline]
        pub fn as_add_eq(self) -> ::std::option::Option<symbols::AddEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AddEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `-=` ([`symbols::SubEq`]), otherwise returns `None`
        #[inline]
        pub fn as_sub_eq(self) -> ::std::option::Option<symbols::SubEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SubEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `/=` ([`symbols::DivEq`]), otherwise returns `None`
        #[inline]
        pub fn as_div_eq(self) -> ::std::option::Option<symbols::DivEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::DivEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<<=` ([`symbols::LtLtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_lt_lt_eq(self) -> ::std::option::Option<symbols::LtLtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtLtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>>=` ([`symbols::GtGtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_gt_gt_eq(self) -> ::std::option::Option<symbols::GtGtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtGtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `^=` ([`symbols::BitXorEq`]), otherwise returns `None`
        #[inline]
        pub fn as_bit_xor_eq(self) -> ::std::option::Option<symbols::BitXorEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitXorEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `|=` ([`symbols::OrEq`]), otherwise returns `None`
        #[inline]
        pub fn as_or_eq(self) -> ::std::option::Option<symbols::OrEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<'tree> {
        type WithLifetime<'a> = ModEq_AndEq_MulEq_AddEq_SubEq_DivEq_LtLtEq_GtGtEq_BitXorEq_OrEq<
            'a,
        >;
        const KIND: &'static str = "{%= | &= | *= | += | -= | /= | <<= | >>= | ^= | |=}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <symbols::ModEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ModEq(this));
            }
            if let Ok(this) = <symbols::AndEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AndEq(this));
            }
            if let Ok(this) = <symbols::MulEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MulEq(this));
            }
            if let Ok(this) = <symbols::AddEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AddEq(this));
            }
            if let Ok(this) = <symbols::SubEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::SubEq(this));
            }
            if let Ok(this) = <symbols::DivEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::DivEq(this));
            }
            if let Ok(this) = <symbols::LtLtEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LtLtEq(this));
            }
            if let Ok(this) = <symbols::GtGtEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GtGtEq(this));
            }
            if let Ok(this) = <symbols::BitXorEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::BitXorEq(this));
            }
            if let Ok(this) = <symbols::OrEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::OrEq(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ModEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::AndEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::MulEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::AddEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::SubEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::DivEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::LtLtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::GtGtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::BitXorEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::OrEq(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ModEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AndEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MulEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AddEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SubEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::DivEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LtLtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GtGtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BitXorEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::OrEq(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ModEq(x) => x.into_raw(),
                Self::AndEq(x) => x.into_raw(),
                Self::MulEq(x) => x.into_raw(),
                Self::AddEq(x) => x.into_raw(),
                Self::SubEq(x) => x.into_raw(),
                Self::DivEq(x) => x.into_raw(),
                Self::LtLtEq(x) => x.into_raw(),
                Self::GtGtEq(x) => x.into_raw(),
                Self::BitXorEq(x) => x.into_raw(),
                Self::OrEq(x) => x.into_raw(),
            }
        }
    }
    /**One of `{mutable_specifier | visibility_modifier}`:
- [`MutableSpecifier`]
- [`VisibilityModifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum MutableSpecifier_VisibilityModifier<'tree> {
        MutableSpecifier(MutableSpecifier<'tree>),
        VisibilityModifier(VisibilityModifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> MutableSpecifier_VisibilityModifier<'tree> {
        ///Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_mutable_specifier(
            self,
        ) -> ::std::option::Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_visibility_modifier(
            self,
        ) -> ::std::option::Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for MutableSpecifier_VisibilityModifier<'tree> {
        type WithLifetime<'a> = MutableSpecifier_VisibilityModifier<'a>;
        const KIND: &'static str = "{mutable_specifier | visibility_modifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <MutableSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MutableSpecifier(this));
            }
            if let Ok(this) = <VisibilityModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::VisibilityModifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::MutableSpecifier(x) => x.into_raw(),
                Self::VisibilityModifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}`:
- [`symbols::NotEq`]
- [`symbols::Mod`]
- [`symbols::And`]
- [`symbols::AndAnd`]
- [`symbols::Mul`]
- [`symbols::Add`]
- [`symbols::Sub`]
- [`symbols::Div`]
- [`symbols::Lt`]
- [`symbols::LtLt`]
- [`symbols::LtEq`]
- [`symbols::EqEq`]
- [`symbols::Gt`]
- [`symbols::GtEq`]
- [`symbols::GtGt`]
- [`symbols::BitXor`]
- [`symbols::Or`]
- [`symbols::OrOr`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
        'tree,
    > {
        NotEq(symbols::NotEq<'tree>),
        Mod(symbols::Mod<'tree>),
        And(symbols::And<'tree>),
        AndAnd(symbols::AndAnd<'tree>),
        Mul(symbols::Mul<'tree>),
        Add(symbols::Add<'tree>),
        Sub(symbols::Sub<'tree>),
        Div(symbols::Div<'tree>),
        Lt(symbols::Lt<'tree>),
        LtLt(symbols::LtLt<'tree>),
        LtEq(symbols::LtEq<'tree>),
        EqEq(symbols::EqEq<'tree>),
        Gt(symbols::Gt<'tree>),
        GtEq(symbols::GtEq<'tree>),
        GtGt(symbols::GtGt<'tree>),
        BitXor(symbols::BitXor<'tree>),
        Or(symbols::Or<'tree>),
        OrOr(symbols::OrOr<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<
        'tree,
    > NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
        'tree,
    > {
        ///Returns the node if it is of type `!=` ([`symbols::NotEq`]), otherwise returns `None`
        #[inline]
        pub fn as_not_eq(self) -> ::std::option::Option<symbols::NotEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::NotEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `%` ([`symbols::Mod`]), otherwise returns `None`
        #[inline]
        pub fn as_mod(self) -> ::std::option::Option<symbols::Mod<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mod(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `&` ([`symbols::And`]), otherwise returns `None`
        #[inline]
        pub fn as_and(self) -> ::std::option::Option<symbols::And<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::And(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `&&` ([`symbols::AndAnd`]), otherwise returns `None`
        #[inline]
        pub fn as_and_and(self) -> ::std::option::Option<symbols::AndAnd<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AndAnd(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `*` ([`symbols::Mul`]), otherwise returns `None`
        #[inline]
        pub fn as_mul(self) -> ::std::option::Option<symbols::Mul<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Mul(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `+` ([`symbols::Add`]), otherwise returns `None`
        #[inline]
        pub fn as_add(self) -> ::std::option::Option<symbols::Add<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Add(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `-` ([`symbols::Sub`]), otherwise returns `None`
        #[inline]
        pub fn as_sub(self) -> ::std::option::Option<symbols::Sub<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Sub(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `/` ([`symbols::Div`]), otherwise returns `None`
        #[inline]
        pub fn as_div(self) -> ::std::option::Option<symbols::Div<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Div(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<` ([`symbols::Lt`]), otherwise returns `None`
        #[inline]
        pub fn as_lt(self) -> ::std::option::Option<symbols::Lt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<<` ([`symbols::LtLt`]), otherwise returns `None`
        #[inline]
        pub fn as_lt_lt(self) -> ::std::option::Option<symbols::LtLt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtLt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `<=` ([`symbols::LtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_lt_eq(self) -> ::std::option::Option<symbols::LtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::LtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `==` ([`symbols::EqEq`]), otherwise returns `None`
        #[inline]
        pub fn as_eq_eq(self) -> ::std::option::Option<symbols::EqEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::EqEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>` ([`symbols::Gt`]), otherwise returns `None`
        #[inline]
        pub fn as_gt(self) -> ::std::option::Option<symbols::Gt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Gt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>=` ([`symbols::GtEq`]), otherwise returns `None`
        #[inline]
        pub fn as_gt_eq(self) -> ::std::option::Option<symbols::GtEq<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtEq(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `>>` ([`symbols::GtGt`]), otherwise returns `None`
        #[inline]
        pub fn as_gt_gt(self) -> ::std::option::Option<symbols::GtGt<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::GtGt(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `^` ([`symbols::BitXor`]), otherwise returns `None`
        #[inline]
        pub fn as_bit_xor(self) -> ::std::option::Option<symbols::BitXor<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::BitXor(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `|` ([`symbols::Or`]), otherwise returns `None`
        #[inline]
        pub fn as_or(self) -> ::std::option::Option<symbols::Or<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Or(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `||` ([`symbols::OrOr`]), otherwise returns `None`
        #[inline]
        pub fn as_or_or(self) -> ::std::option::Option<symbols::OrOr<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::OrOr(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
        'tree,
    > {
        type WithLifetime<'a> = NotEq_Mod_And_AndAnd_Mul_Add_Sub_Div_Lt_LtLt_LtEq_EqEq_Gt_GtEq_GtGt_BitXor_Or_OrOr<
            'a,
        >;
        const KIND: &'static str = "{!= | % | & | && | * | + | - | / | < | << | <= | == | > | >= | >> | ^ | | | ||}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <symbols::NotEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::NotEq(this));
            }
            if let Ok(this) = <symbols::Mod<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Mod(this));
            }
            if let Ok(this) = <symbols::And<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::And(this));
            }
            if let Ok(this) = <symbols::AndAnd<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AndAnd(this));
            }
            if let Ok(this) = <symbols::Mul<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Mul(this));
            }
            if let Ok(this) = <symbols::Add<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Add(this));
            }
            if let Ok(this) = <symbols::Sub<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Sub(this));
            }
            if let Ok(this) = <symbols::Div<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Div(this));
            }
            if let Ok(this) = <symbols::Lt<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lt(this));
            }
            if let Ok(this) = <symbols::LtLt<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LtLt(this));
            }
            if let Ok(this) = <symbols::LtEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::LtEq(this));
            }
            if let Ok(this) = <symbols::EqEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::EqEq(this));
            }
            if let Ok(this) = <symbols::Gt<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Gt(this));
            }
            if let Ok(this) = <symbols::GtEq<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GtEq(this));
            }
            if let Ok(this) = <symbols::GtGt<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::GtGt(this));
            }
            if let Ok(this) = <symbols::BitXor<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::BitXor(this));
            }
            if let Ok(this) = <symbols::Or<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Or(this));
            }
            if let Ok(this) = <symbols::OrOr<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::OrOr(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::NotEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::Mod(x) => ::type_sitter_lib::Node::raw(x),
                Self::And(x) => ::type_sitter_lib::Node::raw(x),
                Self::AndAnd(x) => ::type_sitter_lib::Node::raw(x),
                Self::Mul(x) => ::type_sitter_lib::Node::raw(x),
                Self::Add(x) => ::type_sitter_lib::Node::raw(x),
                Self::Sub(x) => ::type_sitter_lib::Node::raw(x),
                Self::Div(x) => ::type_sitter_lib::Node::raw(x),
                Self::Lt(x) => ::type_sitter_lib::Node::raw(x),
                Self::LtLt(x) => ::type_sitter_lib::Node::raw(x),
                Self::LtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::EqEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::Gt(x) => ::type_sitter_lib::Node::raw(x),
                Self::GtEq(x) => ::type_sitter_lib::Node::raw(x),
                Self::GtGt(x) => ::type_sitter_lib::Node::raw(x),
                Self::BitXor(x) => ::type_sitter_lib::Node::raw(x),
                Self::Or(x) => ::type_sitter_lib::Node::raw(x),
                Self::OrOr(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::NotEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Mod(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::And(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AndAnd(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Mul(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Add(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Sub(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Div(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Lt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LtLt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::LtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::EqEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Gt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GtEq(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::GtGt(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::BitXor(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Or(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::OrOr(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::NotEq(x) => x.into_raw(),
                Self::Mod(x) => x.into_raw(),
                Self::And(x) => x.into_raw(),
                Self::AndAnd(x) => x.into_raw(),
                Self::Mul(x) => x.into_raw(),
                Self::Add(x) => x.into_raw(),
                Self::Sub(x) => x.into_raw(),
                Self::Div(x) => x.into_raw(),
                Self::Lt(x) => x.into_raw(),
                Self::LtLt(x) => x.into_raw(),
                Self::LtEq(x) => x.into_raw(),
                Self::EqEq(x) => x.into_raw(),
                Self::Gt(x) => x.into_raw(),
                Self::GtEq(x) => x.into_raw(),
                Self::GtGt(x) => x.into_raw(),
                Self::BitXor(x) => x.into_raw(),
                Self::Or(x) => x.into_raw(),
                Self::OrOr(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_pattern | closure_expression}`:
- [`Pattern`]
- [`ClosureExpression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_ClosureExpression<'tree> {
        Pattern(Pattern<'tree>),
        ClosureExpression(ClosureExpression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_ClosureExpression<'tree> {
        ///Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`
        #[inline]
        pub fn as_pattern(self) -> ::std::option::Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ClosureExpression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as___(self) -> ::std::option::Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        /**Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_literal_pattern(self) -> ::std::option::Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        /**Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_captured_pattern(
            self,
        ) -> ::std::option::Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_mut_pattern(self) -> ::std::option::Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        /**Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_or_pattern(self) -> ::std::option::Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        /**Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_range_pattern(self) -> ::std::option::Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        /**Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_ref_pattern(self) -> ::std::option::Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        /**Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_reference_pattern(
            self,
        ) -> ::std::option::Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        /**Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_remaining_field_pattern(
            self,
        ) -> ::std::option::Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_slice_pattern(self) -> ::std::option::Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        /**Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_struct_pattern(self) -> ::std::option::Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        /**Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_pattern(self) -> ::std::option::Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        /**Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_struct_pattern(
            self,
        ) -> ::std::option::Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_integer_literal()
        }
        /**Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_negative_literal(
            self,
        ) -> ::std::option::Option<NegativeLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_negative_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Pattern_ClosureExpression<'tree> {
        type WithLifetime<'a> = Pattern_ClosureExpression<'a>;
        const KIND: &'static str = "{_pattern | closure_expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Pattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) = <ClosureExpression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ClosureExpression(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::ClosureExpression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::ClosureExpression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::ClosureExpression(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_pattern | mutable_specifier}`:
- [`Pattern`]
- [`MutableSpecifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_MutableSpecifier<'tree> {
        Pattern(Pattern<'tree>),
        MutableSpecifier(MutableSpecifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_MutableSpecifier<'tree> {
        ///Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`
        #[inline]
        pub fn as_pattern(self) -> ::std::option::Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `mutable_specifier` ([`MutableSpecifier`]), otherwise returns `None`
        #[inline]
        pub fn as_mutable_specifier(
            self,
        ) -> ::std::option::Option<MutableSpecifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::MutableSpecifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as___(self) -> ::std::option::Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        /**Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_literal_pattern(self) -> ::std::option::Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        /**Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_captured_pattern(
            self,
        ) -> ::std::option::Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_mut_pattern(self) -> ::std::option::Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        /**Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_or_pattern(self) -> ::std::option::Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        /**Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_range_pattern(self) -> ::std::option::Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        /**Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_ref_pattern(self) -> ::std::option::Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        /**Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_reference_pattern(
            self,
        ) -> ::std::option::Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        /**Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_remaining_field_pattern(
            self,
        ) -> ::std::option::Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_slice_pattern(self) -> ::std::option::Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        /**Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_struct_pattern(self) -> ::std::option::Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        /**Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_pattern(self) -> ::std::option::Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        /**Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_struct_pattern(
            self,
        ) -> ::std::option::Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_integer_literal()
        }
        /**Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_negative_literal(
            self,
        ) -> ::std::option::Option<NegativeLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_negative_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Pattern_MutableSpecifier<'tree> {
        type WithLifetime<'a> = Pattern_MutableSpecifier<'a>;
        const KIND: &'static str = "{_pattern | mutable_specifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Pattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) = <MutableSpecifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::MutableSpecifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::MutableSpecifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::MutableSpecifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_pattern | parameter}`:
- [`Pattern`]
- [`Parameter`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_Parameter<'tree> {
        Pattern(Pattern<'tree>),
        Parameter(Parameter<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_Parameter<'tree> {
        ///Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`
        #[inline]
        pub fn as_pattern(self) -> ::std::option::Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `parameter` ([`Parameter`]), otherwise returns `None`
        #[inline]
        pub fn as_parameter(self) -> ::std::option::Option<Parameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Parameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as___(self) -> ::std::option::Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        /**Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_literal_pattern(self) -> ::std::option::Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        /**Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_captured_pattern(
            self,
        ) -> ::std::option::Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_mut_pattern(self) -> ::std::option::Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        /**Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_or_pattern(self) -> ::std::option::Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        /**Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_range_pattern(self) -> ::std::option::Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        /**Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_ref_pattern(self) -> ::std::option::Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        /**Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_reference_pattern(
            self,
        ) -> ::std::option::Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        /**Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_remaining_field_pattern(
            self,
        ) -> ::std::option::Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_slice_pattern(self) -> ::std::option::Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        /**Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_struct_pattern(self) -> ::std::option::Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        /**Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_pattern(self) -> ::std::option::Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        /**Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_struct_pattern(
            self,
        ) -> ::std::option::Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_integer_literal()
        }
        /**Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_negative_literal(
            self,
        ) -> ::std::option::Option<NegativeLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_negative_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Pattern_Parameter<'tree> {
        type WithLifetime<'a> = Pattern_Parameter<'a>;
        const KIND: &'static str = "{_pattern | parameter}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Pattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) = <Parameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Parameter(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::Parameter(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Parameter(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::Parameter(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_pattern | self}`:
- [`Pattern`]
- [`Self_`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Pattern_Self_<'tree> {
        Pattern(Pattern<'tree>),
        Self_(Self_<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Pattern_Self_<'tree> {
        ///Returns the node if it is of type `_pattern` ([`Pattern`]), otherwise returns `None`
        #[inline]
        pub fn as_pattern(self) -> ::std::option::Option<Pattern<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Pattern(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Self_(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as___(self) -> ::std::option::Option<symbols::__<'tree>> {
            self.as_pattern()?.as___()
        }
        /**Returns the node if it is of type `_literal_pattern` ([`LiteralPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_literal_pattern(self) -> ::std::option::Option<LiteralPattern<'tree>> {
            self.as_pattern()?.as_literal_pattern()
        }
        /**Returns the node if it is of type `captured_pattern` ([`CapturedPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_captured_pattern(
            self,
        ) -> ::std::option::Option<CapturedPattern<'tree>> {
            self.as_pattern()?.as_captured_pattern()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_pattern()?.as_const_block()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_pattern()?.as_identifier()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_pattern()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `mut_pattern` ([`MutPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_mut_pattern(self) -> ::std::option::Option<MutPattern<'tree>> {
            self.as_pattern()?.as_mut_pattern()
        }
        /**Returns the node if it is of type `or_pattern` ([`OrPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_or_pattern(self) -> ::std::option::Option<OrPattern<'tree>> {
            self.as_pattern()?.as_or_pattern()
        }
        /**Returns the node if it is of type `range_pattern` ([`RangePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_range_pattern(self) -> ::std::option::Option<RangePattern<'tree>> {
            self.as_pattern()?.as_range_pattern()
        }
        /**Returns the node if it is of type `ref_pattern` ([`RefPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_ref_pattern(self) -> ::std::option::Option<RefPattern<'tree>> {
            self.as_pattern()?.as_ref_pattern()
        }
        /**Returns the node if it is of type `reference_pattern` ([`ReferencePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_reference_pattern(
            self,
        ) -> ::std::option::Option<ReferencePattern<'tree>> {
            self.as_pattern()?.as_reference_pattern()
        }
        /**Returns the node if it is of type `remaining_field_pattern` ([`RemainingFieldPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_remaining_field_pattern(
            self,
        ) -> ::std::option::Option<RemainingFieldPattern<'tree>> {
            self.as_pattern()?.as_remaining_field_pattern()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_pattern()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `slice_pattern` ([`SlicePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_slice_pattern(self) -> ::std::option::Option<SlicePattern<'tree>> {
            self.as_pattern()?.as_slice_pattern()
        }
        /**Returns the node if it is of type `struct_pattern` ([`StructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_struct_pattern(self) -> ::std::option::Option<StructPattern<'tree>> {
            self.as_pattern()?.as_struct_pattern()
        }
        /**Returns the node if it is of type `tuple_pattern` ([`TuplePattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_pattern(self) -> ::std::option::Option<TuplePattern<'tree>> {
            self.as_pattern()?.as_tuple_pattern()
        }
        /**Returns the node if it is of type `tuple_struct_pattern` ([`TupleStructPattern`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))*/
        #[inline]
        pub fn as_tuple_struct_pattern(
            self,
        ) -> ::std::option::Option<TupleStructPattern<'tree>> {
            self.as_pattern()?.as_tuple_struct_pattern()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_integer_literal()
        }
        /**Returns the node if it is of type `negative_literal` ([`NegativeLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_negative_literal(
            self,
        ) -> ::std::option::Option<NegativeLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_negative_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_pattern` ([`Pattern < 'tree >`], from [`as_pattern`](Self::as_pattern))
- `_literal_pattern` ([`LiteralPattern < 'tree >`], from [`as_literal_pattern`](Pattern < 'tree >::as_literal_pattern))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_pattern()?.as_literal_pattern()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Pattern_Self_<'tree> {
        type WithLifetime<'a> = Pattern_Self_<'a>;
        const KIND: &'static str = "{_pattern | self}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Pattern<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Pattern(this));
            }
            if let Ok(this) = <Self_<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Self_(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Self_(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Pattern(x) => x.into_raw(),
                Self::Self_(x) => x.into_raw(),
            }
        }
    }
    /**One of `{scoped_identifier | type_identifier}`:
- [`ScopedIdentifier`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ScopedIdentifier_TypeIdentifier<'tree> {
        ScopedIdentifier(ScopedIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ScopedIdentifier_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ScopedIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = ScopedIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str = "{scoped_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <ScopedIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedIdentifier(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ScopedIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ScopedIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{scoped_type_identifier | type_identifier}`:
- [`ScopedTypeIdentifier`]
- [`TypeIdentifier`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ScopedTypeIdentifier_TypeIdentifier<'tree> {
        ScopedTypeIdentifier(ScopedTypeIdentifier<'tree>),
        TypeIdentifier(TypeIdentifier<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ScopedTypeIdentifier_TypeIdentifier<'tree> {
        ///Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::ScopedTypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::TypeIdentifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for ScopedTypeIdentifier_TypeIdentifier<'tree> {
        type WithLifetime<'a> = ScopedTypeIdentifier_TypeIdentifier<'a>;
        const KIND: &'static str = "{scoped_type_identifier | type_identifier}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <ScopedTypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::ScopedTypeIdentifier(this));
            }
            if let Ok(this) = <TypeIdentifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::TypeIdentifier(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::ScopedTypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::TypeIdentifier(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::ScopedTypeIdentifier(x) => x.into_raw(),
                Self::TypeIdentifier(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_type | attribute_item | parameter | self_parameter | variadic_parameter}`:
- [`Type`]
- [`AttributeItem`]
- [`Parameter`]
- [`SelfParameter`]
- [`VariadicParameter`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'tree> {
        Type(Type<'tree>),
        AttributeItem(AttributeItem<'tree>),
        Parameter(Parameter<'tree>),
        SelfParameter(SelfParameter<'tree>),
        VariadicParameter(VariadicParameter<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'tree> {
        ///Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`
        #[inline]
        pub fn as_type(self) -> ::std::option::Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `attribute_item` ([`AttributeItem`]), otherwise returns `None`
        #[inline]
        pub fn as_attribute_item(self) -> ::std::option::Option<AttributeItem<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::AttributeItem(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `parameter` ([`Parameter`]), otherwise returns `None`
        #[inline]
        pub fn as_parameter(self) -> ::std::option::Option<Parameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Parameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `self_parameter` ([`SelfParameter`]), otherwise returns `None`
        #[inline]
        pub fn as_self_parameter(self) -> ::std::option::Option<SelfParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::SelfParameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `variadic_parameter` ([`VariadicParameter`]), otherwise returns `None`
        #[inline]
        pub fn as_variadic_parameter(
            self,
        ) -> ::std::option::Option<VariadicParameter<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VariadicParameter(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_abstract_type(self) -> ::std::option::Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        /**Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_array_type(self) -> ::std::option::Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        /**Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_bounded_type(self) -> ::std::option::Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        /**Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_dynamic_type(self) -> ::std::option::Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        /**Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        /**Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        /**Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_never_type(self) -> ::std::option::Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        /**Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_pointer_type(self) -> ::std::option::Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        /**Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_reference_type(self) -> ::std::option::Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        /**Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_removed_trait_bound(
            self,
        ) -> ::std::option::Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        /**Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        /**Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        /**Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_unit_type(self) -> ::std::option::Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<'tree> {
        type WithLifetime<'a> = Type_AttributeItem_Parameter_SelfParameter_VariadicParameter<
            'a,
        >;
        const KIND: &'static str = "{_type | attribute_item | parameter | self_parameter | variadic_parameter}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Type<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <AttributeItem<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::AttributeItem(this));
            }
            if let Ok(this) = <Parameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Parameter(this));
            }
            if let Ok(this) = <SelfParameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::SelfParameter(this));
            }
            if let Ok(this) = <VariadicParameter<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::VariadicParameter(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw(x),
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw(x),
                Self::Parameter(x) => ::type_sitter_lib::Node::raw(x),
                Self::SelfParameter(x) => ::type_sitter_lib::Node::raw(x),
                Self::VariadicParameter(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::AttributeItem(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Parameter(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::SelfParameter(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::VariadicParameter(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::AttributeItem(x) => x.into_raw(),
                Self::Parameter(x) => x.into_raw(),
                Self::SelfParameter(x) => x.into_raw(),
                Self::VariadicParameter(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_type | higher_ranked_trait_bound | lifetime}`:
- [`Type`]
- [`HigherRankedTraitBound`]
- [`Lifetime`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_HigherRankedTraitBound_Lifetime<'tree> {
        Type(Type<'tree>),
        HigherRankedTraitBound(HigherRankedTraitBound<'tree>),
        Lifetime(Lifetime<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_HigherRankedTraitBound_Lifetime<'tree> {
        ///Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`
        #[inline]
        pub fn as_type(self) -> ::std::option::Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `higher_ranked_trait_bound` ([`HigherRankedTraitBound`]), otherwise returns `None`
        #[inline]
        pub fn as_higher_ranked_trait_bound(
            self,
        ) -> ::std::option::Option<HigherRankedTraitBound<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::HigherRankedTraitBound(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_abstract_type(self) -> ::std::option::Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        /**Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_array_type(self) -> ::std::option::Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        /**Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_bounded_type(self) -> ::std::option::Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        /**Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_dynamic_type(self) -> ::std::option::Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        /**Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        /**Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        /**Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_never_type(self) -> ::std::option::Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        /**Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_pointer_type(self) -> ::std::option::Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        /**Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_reference_type(self) -> ::std::option::Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        /**Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_removed_trait_bound(
            self,
        ) -> ::std::option::Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        /**Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        /**Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        /**Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_unit_type(self) -> ::std::option::Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for Type_HigherRankedTraitBound_Lifetime<'tree> {
        type WithLifetime<'a> = Type_HigherRankedTraitBound_Lifetime<'a>;
        const KIND: &'static str = "{_type | higher_ranked_trait_bound | lifetime}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Type<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <HigherRankedTraitBound<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::HigherRankedTraitBound(this));
            }
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw(x),
                Self::HigherRankedTraitBound(x) => ::type_sitter_lib::Node::raw(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::HigherRankedTraitBound(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::HigherRankedTraitBound(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_type | lifetime}`:
- [`Type`]
- [`Lifetime`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_Lifetime<'tree> {
        Type(Type<'tree>),
        Lifetime(Lifetime<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_Lifetime<'tree> {
        ///Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`
        #[inline]
        pub fn as_type(self) -> ::std::option::Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `lifetime` ([`Lifetime`]), otherwise returns `None`
        #[inline]
        pub fn as_lifetime(self) -> ::std::option::Option<Lifetime<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Lifetime(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_abstract_type(self) -> ::std::option::Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        /**Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_array_type(self) -> ::std::option::Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        /**Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_bounded_type(self) -> ::std::option::Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        /**Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_dynamic_type(self) -> ::std::option::Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        /**Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        /**Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        /**Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_never_type(self) -> ::std::option::Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        /**Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_pointer_type(self) -> ::std::option::Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        /**Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_reference_type(self) -> ::std::option::Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        /**Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_removed_trait_bound(
            self,
        ) -> ::std::option::Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        /**Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        /**Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        /**Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_unit_type(self) -> ::std::option::Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Type_Lifetime<'tree> {
        type WithLifetime<'a> = Type_Lifetime<'a>;
        const KIND: &'static str = "{_type | lifetime}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Type<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <Lifetime<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Lifetime(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Lifetime(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::Lifetime(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_type | qualified_type}`:
- [`Type`]
- [`QualifiedType`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum Type_QualifiedType<'tree> {
        Type(Type<'tree>),
        QualifiedType(QualifiedType<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> Type_QualifiedType<'tree> {
        ///Returns the node if it is of type `_type` ([`Type`]), otherwise returns `None`
        #[inline]
        pub fn as_type(self) -> ::std::option::Option<Type<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Type(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `qualified_type` ([`QualifiedType`]), otherwise returns `None`
        #[inline]
        pub fn as_qualified_type(self) -> ::std::option::Option<QualifiedType<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::QualifiedType(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `abstract_type` ([`AbstractType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_abstract_type(self) -> ::std::option::Option<AbstractType<'tree>> {
            self.as_type()?.as_abstract_type()
        }
        /**Returns the node if it is of type `array_type` ([`ArrayType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_array_type(self) -> ::std::option::Option<ArrayType<'tree>> {
            self.as_type()?.as_array_type()
        }
        /**Returns the node if it is of type `bounded_type` ([`BoundedType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_bounded_type(self) -> ::std::option::Option<BoundedType<'tree>> {
            self.as_type()?.as_bounded_type()
        }
        /**Returns the node if it is of type `dynamic_type` ([`DynamicType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_dynamic_type(self) -> ::std::option::Option<DynamicType<'tree>> {
            self.as_type()?.as_dynamic_type()
        }
        /**Returns the node if it is of type `function_type` ([`FunctionType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_function_type(self) -> ::std::option::Option<FunctionType<'tree>> {
            self.as_type()?.as_function_type()
        }
        /**Returns the node if it is of type `generic_type` ([`GenericType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_generic_type(self) -> ::std::option::Option<GenericType<'tree>> {
            self.as_type()?.as_generic_type()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_type()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_type()?.as_metavariable()
        }
        /**Returns the node if it is of type `never_type` ([`NeverType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_never_type(self) -> ::std::option::Option<NeverType<'tree>> {
            self.as_type()?.as_never_type()
        }
        /**Returns the node if it is of type `pointer_type` ([`PointerType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_pointer_type(self) -> ::std::option::Option<PointerType<'tree>> {
            self.as_type()?.as_pointer_type()
        }
        /**Returns the node if it is of type `primitive_type` ([`PrimitiveType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_primitive_type(self) -> ::std::option::Option<PrimitiveType<'tree>> {
            self.as_type()?.as_primitive_type()
        }
        /**Returns the node if it is of type `reference_type` ([`ReferenceType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_reference_type(self) -> ::std::option::Option<ReferenceType<'tree>> {
            self.as_type()?.as_reference_type()
        }
        /**Returns the node if it is of type `removed_trait_bound` ([`RemovedTraitBound`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_removed_trait_bound(
            self,
        ) -> ::std::option::Option<RemovedTraitBound<'tree>> {
            self.as_type()?.as_removed_trait_bound()
        }
        /**Returns the node if it is of type `scoped_type_identifier` ([`ScopedTypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_scoped_type_identifier(
            self,
        ) -> ::std::option::Option<ScopedTypeIdentifier<'tree>> {
            self.as_type()?.as_scoped_type_identifier()
        }
        /**Returns the node if it is of type `tuple_type` ([`TupleType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_tuple_type(self) -> ::std::option::Option<TupleType<'tree>> {
            self.as_type()?.as_tuple_type()
        }
        /**Returns the node if it is of type `type_identifier` ([`TypeIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_type_identifier(self) -> ::std::option::Option<TypeIdentifier<'tree>> {
            self.as_type()?.as_type_identifier()
        }
        /**Returns the node if it is of type `unit_type` ([`UnitType`]), otherwise returns `None`.

Follows the following chain:
- `_type` ([`Type < 'tree >`], from [`as_type`](Self::as_type))*/
        #[inline]
        pub fn as_unit_type(self) -> ::std::option::Option<UnitType<'tree>> {
            self.as_type()?.as_unit_type()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for Type_QualifiedType<'tree> {
        type WithLifetime<'a> = Type_QualifiedType<'a>;
        const KIND: &'static str = "{_type | qualified_type}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <Type<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Type(this));
            }
            if let Ok(this) = <QualifiedType<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::QualifiedType(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw(x),
                Self::QualifiedType(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::QualifiedType(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::Type(x) => x.into_raw(),
                Self::QualifiedType(x) => x.into_raw(),
            }
        }
    }
    /**One of `{visibility_modifier | where_clause}`:
- [`VisibilityModifier`]
- [`WhereClause`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum VisibilityModifier_WhereClause<'tree> {
        VisibilityModifier(VisibilityModifier<'tree>),
        WhereClause(WhereClause<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> VisibilityModifier_WhereClause<'tree> {
        ///Returns the node if it is of type `visibility_modifier` ([`VisibilityModifier`]), otherwise returns `None`
        #[inline]
        pub fn as_visibility_modifier(
            self,
        ) -> ::std::option::Option<VisibilityModifier<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::VisibilityModifier(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `where_clause` ([`WhereClause`]), otherwise returns `None`
        #[inline]
        pub fn as_where_clause(self) -> ::std::option::Option<WhereClause<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::WhereClause(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree>
    for VisibilityModifier_WhereClause<'tree> {
        type WithLifetime<'a> = VisibilityModifier_WhereClause<'a>;
        const KIND: &'static str = "{visibility_modifier | where_clause}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <VisibilityModifier<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::VisibilityModifier(this));
            }
            if let Ok(this) = <WhereClause<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::WhereClause(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw(x),
                Self::WhereClause(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::VisibilityModifier(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::WhereClause(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::VisibilityModifier(x) => x.into_raw(),
                Self::WhereClause(x) => x.into_raw(),
            }
        }
    }
    /**One of `{_ | _expression}`:
- [`symbols::__`]
- [`Expression`]*/
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types)]
    pub enum ___Expression<'tree> {
        __(symbols::__<'tree>),
        Expression(Expression<'tree>),
    }
    #[automatically_derived]
    #[allow(unused)]
    impl<'tree> ___Expression<'tree> {
        ///Returns the node if it is of type `_` ([`symbols::__`]), otherwise returns `None`
        #[inline]
        pub fn as___(self) -> ::std::option::Option<symbols::__<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::__(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        ///Returns the node if it is of type `_expression` ([`Expression`]), otherwise returns `None`
        #[inline]
        pub fn as_expression(self) -> ::std::option::Option<Expression<'tree>> {
            #[allow(irrefutable_let_patterns)]
            if let Self::Expression(x) = self {
                ::std::option::Option::Some(x)
            } else {
                ::std::option::Option::None
            }
        }
        /**Returns the node if it is of type `_literal` ([`Literal`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_literal(self) -> ::std::option::Option<Literal<'tree>> {
            self.as_expression()?.as_literal()
        }
        /**Returns the node if it is of type `array_expression` ([`ArrayExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_array_expression(
            self,
        ) -> ::std::option::Option<ArrayExpression<'tree>> {
            self.as_expression()?.as_array_expression()
        }
        /**Returns the node if it is of type `assignment_expression` ([`AssignmentExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_assignment_expression(
            self,
        ) -> ::std::option::Option<AssignmentExpression<'tree>> {
            self.as_expression()?.as_assignment_expression()
        }
        /**Returns the node if it is of type `async_block` ([`AsyncBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_async_block(self) -> ::std::option::Option<AsyncBlock<'tree>> {
            self.as_expression()?.as_async_block()
        }
        /**Returns the node if it is of type `await_expression` ([`AwaitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_await_expression(
            self,
        ) -> ::std::option::Option<AwaitExpression<'tree>> {
            self.as_expression()?.as_await_expression()
        }
        /**Returns the node if it is of type `binary_expression` ([`BinaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_binary_expression(
            self,
        ) -> ::std::option::Option<BinaryExpression<'tree>> {
            self.as_expression()?.as_binary_expression()
        }
        /**Returns the node if it is of type `block` ([`Block`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_block(self) -> ::std::option::Option<Block<'tree>> {
            self.as_expression()?.as_block()
        }
        /**Returns the node if it is of type `break_expression` ([`BreakExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_break_expression(
            self,
        ) -> ::std::option::Option<BreakExpression<'tree>> {
            self.as_expression()?.as_break_expression()
        }
        /**Returns the node if it is of type `call_expression` ([`CallExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_call_expression(self) -> ::std::option::Option<CallExpression<'tree>> {
            self.as_expression()?.as_call_expression()
        }
        /**Returns the node if it is of type `closure_expression` ([`ClosureExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_closure_expression(
            self,
        ) -> ::std::option::Option<ClosureExpression<'tree>> {
            self.as_expression()?.as_closure_expression()
        }
        /**Returns the node if it is of type `compound_assignment_expr` ([`CompoundAssignmentExpr`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_compound_assignment_expr(
            self,
        ) -> ::std::option::Option<CompoundAssignmentExpr<'tree>> {
            self.as_expression()?.as_compound_assignment_expr()
        }
        /**Returns the node if it is of type `const_block` ([`ConstBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_const_block(self) -> ::std::option::Option<ConstBlock<'tree>> {
            self.as_expression()?.as_const_block()
        }
        /**Returns the node if it is of type `continue_expression` ([`ContinueExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_continue_expression(
            self,
        ) -> ::std::option::Option<ContinueExpression<'tree>> {
            self.as_expression()?.as_continue_expression()
        }
        /**Returns the node if it is of type `field_expression` ([`FieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_field_expression(
            self,
        ) -> ::std::option::Option<FieldExpression<'tree>> {
            self.as_expression()?.as_field_expression()
        }
        /**Returns the node if it is of type `for_expression` ([`ForExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_for_expression(self) -> ::std::option::Option<ForExpression<'tree>> {
            self.as_expression()?.as_for_expression()
        }
        /**Returns the node if it is of type `gen_block` ([`GenBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_gen_block(self) -> ::std::option::Option<GenBlock<'tree>> {
            self.as_expression()?.as_gen_block()
        }
        /**Returns the node if it is of type `generic_function` ([`GenericFunction`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_generic_function(
            self,
        ) -> ::std::option::Option<GenericFunction<'tree>> {
            self.as_expression()?.as_generic_function()
        }
        /**Returns the node if it is of type `identifier` ([`Identifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_identifier(self) -> ::std::option::Option<Identifier<'tree>> {
            self.as_expression()?.as_identifier()
        }
        /**Returns the node if it is of type `if_expression` ([`IfExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_if_expression(self) -> ::std::option::Option<IfExpression<'tree>> {
            self.as_expression()?.as_if_expression()
        }
        /**Returns the node if it is of type `index_expression` ([`IndexExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_index_expression(
            self,
        ) -> ::std::option::Option<IndexExpression<'tree>> {
            self.as_expression()?.as_index_expression()
        }
        /**Returns the node if it is of type `loop_expression` ([`LoopExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_loop_expression(self) -> ::std::option::Option<LoopExpression<'tree>> {
            self.as_expression()?.as_loop_expression()
        }
        /**Returns the node if it is of type `macro_invocation` ([`MacroInvocation`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_macro_invocation(
            self,
        ) -> ::std::option::Option<MacroInvocation<'tree>> {
            self.as_expression()?.as_macro_invocation()
        }
        /**Returns the node if it is of type `match_expression` ([`MatchExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_match_expression(
            self,
        ) -> ::std::option::Option<MatchExpression<'tree>> {
            self.as_expression()?.as_match_expression()
        }
        /**Returns the node if it is of type `metavariable` ([`Metavariable`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_metavariable(self) -> ::std::option::Option<Metavariable<'tree>> {
            self.as_expression()?.as_metavariable()
        }
        /**Returns the node if it is of type `parenthesized_expression` ([`ParenthesizedExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_parenthesized_expression(
            self,
        ) -> ::std::option::Option<ParenthesizedExpression<'tree>> {
            self.as_expression()?.as_parenthesized_expression()
        }
        /**Returns the node if it is of type `range_expression` ([`RangeExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_range_expression(
            self,
        ) -> ::std::option::Option<RangeExpression<'tree>> {
            self.as_expression()?.as_range_expression()
        }
        /**Returns the node if it is of type `reference_expression` ([`ReferenceExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_reference_expression(
            self,
        ) -> ::std::option::Option<ReferenceExpression<'tree>> {
            self.as_expression()?.as_reference_expression()
        }
        /**Returns the node if it is of type `return_expression` ([`ReturnExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_return_expression(
            self,
        ) -> ::std::option::Option<ReturnExpression<'tree>> {
            self.as_expression()?.as_return_expression()
        }
        /**Returns the node if it is of type `scoped_identifier` ([`ScopedIdentifier`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_scoped_identifier(
            self,
        ) -> ::std::option::Option<ScopedIdentifier<'tree>> {
            self.as_expression()?.as_scoped_identifier()
        }
        /**Returns the node if it is of type `self` ([`Self_`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_self(self) -> ::std::option::Option<Self_<'tree>> {
            self.as_expression()?.as_self()
        }
        /**Returns the node if it is of type `struct_expression` ([`StructExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_struct_expression(
            self,
        ) -> ::std::option::Option<StructExpression<'tree>> {
            self.as_expression()?.as_struct_expression()
        }
        /**Returns the node if it is of type `try_block` ([`TryBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_block(self) -> ::std::option::Option<TryBlock<'tree>> {
            self.as_expression()?.as_try_block()
        }
        /**Returns the node if it is of type `try_expression` ([`TryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_try_expression(self) -> ::std::option::Option<TryExpression<'tree>> {
            self.as_expression()?.as_try_expression()
        }
        /**Returns the node if it is of type `tuple_expression` ([`TupleExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_tuple_expression(
            self,
        ) -> ::std::option::Option<TupleExpression<'tree>> {
            self.as_expression()?.as_tuple_expression()
        }
        /**Returns the node if it is of type `type_cast_expression` ([`TypeCastExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_type_cast_expression(
            self,
        ) -> ::std::option::Option<TypeCastExpression<'tree>> {
            self.as_expression()?.as_type_cast_expression()
        }
        /**Returns the node if it is of type `unary_expression` ([`UnaryExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unary_expression(
            self,
        ) -> ::std::option::Option<UnaryExpression<'tree>> {
            self.as_expression()?.as_unary_expression()
        }
        /**Returns the node if it is of type `unit_expression` ([`UnitExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unit_expression(self) -> ::std::option::Option<UnitExpression<'tree>> {
            self.as_expression()?.as_unit_expression()
        }
        /**Returns the node if it is of type `unsafe_block` ([`UnsafeBlock`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_unsafe_block(self) -> ::std::option::Option<UnsafeBlock<'tree>> {
            self.as_expression()?.as_unsafe_block()
        }
        /**Returns the node if it is of type `while_expression` ([`WhileExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_while_expression(
            self,
        ) -> ::std::option::Option<WhileExpression<'tree>> {
            self.as_expression()?.as_while_expression()
        }
        /**Returns the node if it is of type `yield_expression` ([`YieldExpression`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))*/
        #[inline]
        pub fn as_yield_expression(
            self,
        ) -> ::std::option::Option<YieldExpression<'tree>> {
            self.as_expression()?.as_yield_expression()
        }
        /**Returns the node if it is of type `boolean_literal` ([`BooleanLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_boolean_literal(self) -> ::std::option::Option<BooleanLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_boolean_literal()
        }
        /**Returns the node if it is of type `char_literal` ([`CharLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_char_literal(self) -> ::std::option::Option<CharLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_char_literal()
        }
        /**Returns the node if it is of type `float_literal` ([`FloatLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_float_literal(self) -> ::std::option::Option<FloatLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_float_literal()
        }
        /**Returns the node if it is of type `integer_literal` ([`IntegerLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_integer_literal(self) -> ::std::option::Option<IntegerLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_integer_literal()
        }
        /**Returns the node if it is of type `raw_string_literal` ([`RawStringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_raw_string_literal(
            self,
        ) -> ::std::option::Option<RawStringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_raw_string_literal()
        }
        /**Returns the node if it is of type `string_literal` ([`StringLiteral`]), otherwise returns `None`.

Follows the following chain:
- `_expression` ([`Expression < 'tree >`], from [`as_expression`](Self::as_expression))
- `_literal` ([`Literal < 'tree >`], from [`as_literal`](Expression < 'tree >::as_literal))*/
        #[inline]
        pub fn as_string_literal(self) -> ::std::option::Option<StringLiteral<'tree>> {
            self.as_expression()?.as_literal()?.as_string_literal()
        }
    }
    #[automatically_derived]
    impl<'tree> ::type_sitter_lib::Node<'tree> for ___Expression<'tree> {
        type WithLifetime<'a> = ___Expression<'a>;
        const KIND: &'static str = "{_ | _expression}";
        #[inline]
        fn try_from_raw(
            node: ::yak_sitter::Node<'tree>,
        ) -> ::type_sitter_lib::NodeResult<'tree, Self> {
            if let Ok(this) = <symbols::__<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::__(this));
            }
            if let Ok(this) = <Expression<
                'tree,
            > as ::type_sitter_lib::Node<'tree>>::try_from_raw(node) {
                return Ok(Self::Expression(this));
            }
            Err(::type_sitter_lib::IncorrectKind::new::<Self>(node))
        }
        #[inline]
        fn raw(&self) -> &::yak_sitter::Node<'tree> {
            match self {
                Self::__(x) => ::type_sitter_lib::Node::raw(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw(x),
            }
        }
        #[inline]
        fn raw_mut(&mut self) -> &mut ::yak_sitter::Node<'tree> {
            match self {
                Self::__(x) => ::type_sitter_lib::Node::raw_mut(x),
                Self::Expression(x) => ::type_sitter_lib::Node::raw_mut(x),
            }
        }
        #[inline]
        fn into_raw(self) -> ::yak_sitter::Node<'tree> {
            match self {
                Self::__(x) => x.into_raw(),
                Self::Expression(x) => x.into_raw(),
            }
        }
    }
}
